{"pages":[{"title":"关于","text":"关于博客为什么选择文字创作在将博客迁移到 Hexo 之后我写了这篇博客：重新审视个人博客，和里边讲的一样，在这个自媒体发达的时代，也许只有搞文字创作才能让我静下心来，去品味生活，去成长，社会太浮躁了，就是算是学习人们也都习惯去找各种视频教程，连文档都不愿看一眼。这个博客便是我心中的净土。 为什么是独立博客独立博客的缺点是一切都需要自己运营，很多独立博客一点曝光度都没有，这给很多博主造成了很大的打击。虽然我把这个博客视为净土，但我也希望它的曝光度更高，能进入更多人的世界，这并不矛盾，博客是我创作的净土，我希望在博客上专心的搞我的创作，我完全可以做个公众号之类的以提高曝光度，但这样很容易就会失去这片净土，因为很可能在维护公众号的过程中，把重心放在吸粉上，而不是创作。 现在这个博客这个博客也是几经折腾才成为现在这个模样，从Gridea到Typecho到现在的Hexo，虽然每一次迁移都思考了很久，但最终还是证明当时的思维成熟度还不够，前前后后经历了一年多吧，而最终选择 Hexo 是因为打算一直更新这个博客，并且保留原始的数据。也有个人原因：自己没有那么多精力去维护服务器，目前也没有那么多资源支持下去。 何许人也南有乔木，北有相思。爱上北方女孩的南方人。 README.MD每个人都有那么几种爱好，我呢，谈不上爱好，也谈不上不喜欢，也许就是一个爱好生活的人，基本上所有的事情都愿意去尝试一番，回顾一下，原来从大一开始我尝试自学过这么多东西： PS、PR、C4D C、Java、Rust、Go、JavaScript、PHP、HTML/CSS、PowerShell、Linux、Arduino 口琴、萧 做饭 有的是我还没入门便放弃的，比如 Rust、C4D 对我来说太难了还有半成品 PS、PR、Linux 等，只能说会用还有需要不断努力学习的乐器和做饭最终确定了在编程方面的技术栈： 大前端 Go NodeJS 当然谁不想成为人生的全栈呢？一起加油吧！","link":"/about/index.html"}],"posts":[{"title":"Apollo-GraphQL快速上手-服务端","text":"上次课程设计做完之后就放松了一阵子，过了这么久才来更新博客其实内心是不好受的，感觉生活缺少了什么。GraphQL 出现了很多年，一直不温不火，想尝试 GraphQL 服务器开发的朋友们可以参考一下本文，你将理解到一种 GraphQL 服务器的通用逻辑。 本文假设你对GraphQL有一定的了解。 Apollo Server 是以 Node 为后端的 GraphQL 实现，我选择 Apollo 是因为它是一套完整的服务框架，它包括前端和后端，可拓展性强，并且 Node 也是后端开发最快的方式。 我不喜欢贴代码，我会从 0 开始搭建一个普通的 web 服务器，从创建一个 GraphQL 的 mock Server 来说明 Apollo Server 的运行逻辑，其实 GraphQL 服务器的运行逻辑也大致如此，最后接入数据库，更接近实战。 基本服务器监听本节为搭建基础服务器而不是 GraphQL 服务器，熟练的朋友可跳过。 Apollo Server 可作为一个独立的服务器，我们可以安装 Apollo 后直接启动服务器监听，但功能它的只限于对数据的增删改查，一个服务器可能还需要如下功能： 模板渲染或 SSR 身份验证 文件上传 … 为了便于拓展业务功能，我将 Apollo Server 作为 Node 服务器的中间件，你可以选择你喜欢的 Node 服务器框架，或者自己搭建 Node 服务器，我选择的是 Koa，接下来开始搭建整体架构： 安装 Koa 和 Apollo ServerPowerShell12npm i koa-generator -gkoa2 项目名 生成的目录如下，长的很像 MVC 架构：app.js 里引入了必备的库并初始化和定义路由，最终由 bin/www 引用并真正将他们使用起来。 接下来安装依赖，除了 koa-generator 生成的依赖，还需要安装apollo-server-koa和graphql，这样将 Apollo Server 作为中间件，如果你使用其他 Node 服务器，可以在这里找到适合的中间件。 开发建议每次编辑代码之后查看更改必须要重新启动服务器，koa-generator 自动为我们安装nodemon，它能监听工作区的文件更改，进行热更新。这样的话，你需要将bin/www文件改为bin/www.js，因为nodemon不会监听没有后缀名文件的更改。 安装依赖后最后使用npm run dev就能启动服务器了，默认端口为 3000，你可以通过localhost:3000访问。 简单的 GraphQL 服务为了方便大家理解本节内容，写这篇博客的时候我也亲自做了一遍，你可以 clone我的仓库，切换到 mock 分支查看。 GitBash12git clone https://github.com/KylinLee/koa-apollo-template.gitgit checkout mock Apollo GraphQL 由以下部分组成： Schema：图、结构 Data：数据源 Resolver：解析器 为了便于理解，先模拟一个查询书籍相关信息的 GraphQL 服务器： SchemaSchema 相当于接口（指 API 接口），定义了客户端可以执行的操作类型，数据结构体，数据字段及类型。在 MVC 架构中，相当于模型，我的理解 Schema 是数据的入口和出口，一个请求传过来首先通过 Schema 校验，响应内容最终也会以 Schema 定义的格式返回，相当于一个模具，固定数据进出的格式。所以新建一个model/schema目录，在目录中建立 Schema 并将其导出备用： model/schema/index.js1234567891011const { gql } = require(\"apollo-server-koa\");const typeDefs = gql` type Book { title: String author: String } type Query { books: [Book] }`;module.exports = typeDefs; GraphQL 中文文档中将类似于上面 Book 的结构叫做“类型”，但我认为对于编程人员将它们叫做“结构体”更容易理解。 Data数据比较容易理解，客户端需要的内容，服务器可返回的内容就是数据。为了简化流程，便于理解，我们选择使用模拟数据，可以新建data目录，将模拟数据放在这里并导出备用： data/index.js1234567891011const books = [ { title: \"Harry Potter and the Chamber of Secrets\", author: \"J.K. Rowling\", }, { title: \"Jurassic Park\", author: \"Michael Crichton\", },];module.exports = books; Resolver解析器的作用是将 Schema 和 Data 联系在一起，即根据客户端传来的查询语句在一大堆 Data 里边找到指定的数据，如果说放在 MVC 里边，可以作为控制器，也可以作为模型，看个人如何理解，其实 MVC 没有很严格的界定，如果你的 Resolver 除了查询数据还具有其他复杂的功能，将其定义为控制器比较合适，如果你的 Resolver 专门用于数据的查询，将其作为模型看待。我将 Resolver 放在model/resolver目录下。 现在我们可以分析一下，查询Books，需要返回一个数组，数组的每一项需要符合Book的结构，即每一项需要包含title和author字段，巧的是我们模拟的数据book正好符合Books的结构。 在开发中，这个分析很重要，请不要忽略！！！ 所以我们的 Resolver 这样写： model/resolver/index.js1234567const books = require(\"../../data/index.js\");const resolvers = { Query: { books: () =&gt; books, },};module.exports = resolvers; 为 Schema 中对应的结构体编写同名的函数，并将这些函数作为resolvers对象的键和值，导出resolvers备用。 Resolver 进阶其实你只编写了 Query 中 books 的解析器，books 是以 Book 为单元的数组，但我们并没有编写 Book 结构体的解析器，它还是返回了我们预期的结果。实际上 Apollo 并不是data是什么就返回什么，将data中的author改为authors，只会返回title字段内容。默认情况下，如果你没有编写某个结构体的解析器，Apollo 将会使用默认解析器，它会根据 books 的结果去验证里边的某一项是否符合 Book 解析器，最终返回符合 Book 的结果，起到了过滤的效果，了解默认解析器可以帮助你少编写代码。 Server将三部分准备其了，接下来将这三部分接入服务器，供服务器调用，首先在www.js这个执行文件中引入这三部分，然后将他们作为选项传入 Apollo Server，最后将 Apollo Server 作为 Koa 中间件，关键代码如下： bin/www.js123456789101112131415161718var app = require(\"../app.js\");const { ApolloServer } = require(\"apollo-server-koa\");const typeDefs = require(\"../model/schema/index.js\");const resolvers = require(\"../model/resolver/index.js\");// 构造Apollo Server;const server = new ApolloServer({ typeDefs, resolvers,});// 将server作为中间件server.applyMiddleware({ app });// 启动监听，注意将原来的server改为appapp.listen(3000, () =&gt; { cosneole.log(\"please open localhost:3000/graphql\");}); 测试结果打开localhost:3000/graphql，进行 GraphQL 查询，GraphQL 基础这里就不讲了，既然决定用 Apollo Server 相信大家都会，测试如下： 使用 MySQL 作为数据源便于大家理解本节，你可以 clone我的仓库，切换到 mysql 分支查看。 GitBash12git clone https://github.com/KylinLee/koa-apollo-template.gitgit checkout mysql 通过上面的讲解你已经理解 Apollo Server 的开发流程了吧，上面这个例子中使用的是模拟的数据，是固定不变的，接下来是重头戏——接入数据库。 我是用的是 MySQL，按照官方文档，可以使用的数据源有数据库和 RESTful API，支持 RESTful API 的原因是帮助使用 RESTful API 的服务迁移到 GraphQL，我使用关系型数据库 MySQL 作为数据源。 上面的例子中我们向 ApolloServer 构造函数传递了一个配置对象，这个配置对象包含了两个内容typeDefs和resolvers。其中数据源是在 resolver 中引入的，我们也可以将数据源传入 ApolloServer 构造函数，在 ApolloServer 实例化的时候就初始化连接数据库，我们使用 Apollo 社区维护的数据源工具datasource-sql，它是基于knex的，knex是一个查询构造器，通过knex我们可以用熟悉的 JavaScript 语法去执行 SQL 查询，datasource-sql的工作是将knex包装成ApolloServer构造函数可接受的对象，让我们先安装它： PowerShell1npm i datasource-sql mysql --save 然后我们需要做三部分的更改： 配置数据库并实例化数据源工具 将数据源实例传入ApolloServer 在 resolver 中使用数据源 配置数据库并实例化数据源工具首先配置数据库，在data文件夹创建data/mysql.config.js： mysql.config.js12345678910const knexConfig = { client: \"mysql\", connection: { host: \"127.0.0.1\", port: 3306, user: \"root\", password: \"\", database: \"Book\", },}; 然后创建data/methods.js，这里边定义了数据库的操作方法供 resolver 调用，这些方法包含了你需要对数据库进行的所有操作，比如下面这段代码就是获取books表中的所有字段，相当于 SQL 语句: SQL1select * from books; 注意：使用 knex 查询器返回的是 Promise。 data/methods.js1234567891011121314151617const { SQLDataSource } = require(\"datasource-sql\");class FetchMethods extends SQLDataSource { getAllBooks() { return this.knex(\"books\") .select(\"*\") .then((res) =&gt; { console.table(res); return res; }) .catch(() =&gt; { 0; }); }}module.exports = FetchMethods; 最终实例化数据库工具的逻辑是：将数据库配置对象传入包含数据库操作方法的类，如下： data/mysql.config.js12345678910111213141516const MyDatabase = require(\"./methods\");const knexConfig = { client: \"mysql\", connection: { host: \"127.0.0.1\", port: 3306, user: \"root\", password: \"\", database: \"Book\", },};const db = new MyDatabase(knexConfig);module.exports = db; 将数据源实例传入ApolloServer通过上面的实例化之后成为了ApolloServer构造函数可接受的数据源对象，对 ApolloServer 配置做如下更改： bin/www.js1234567891011121314151617181920var app = require(\"../app.js\");const { ApolloServer } = require(\"apollo-server-koa\");const typeDefs = require(\"../model/schema/index.js\");const resolvers = require(\"../model/resolver/index.js\");// 引入数据源const db = require(\"../data/mysql.config.js\");// 实例化 ApolloServerconst server = new ApolloServer({ typeDefs, resolvers, dataSources: () =&gt; ({ db }), context: (app) =&gt; { const method = app.ctx.method; return { method, uid: \"20202020\", }; }, tracing: true,}); 关键代码是第 6 行和第 11 行。 context 对象另外我往里边传了context对象，这是非必要的，有context对象之后我们可以在 resolver 中使用他们，如上面这段代码中返回了当前请求的方法和一个uid，我们在 resolver 里边就能使用这两个变量，具体怎么使用将在下一小节中阐述。context对象是很有用的，比如通过 JWT 验证请求者身份之后，可以将记录这个身份的信息传给 resolver，接着 resolver 将这个信息作为数据库查询参数。 在 resolver 中使用数据源使用数据源就比较简单了，和我们之前写简单的 GraphQL 服务一样，在model/resolver/index.js中写 resolver 方法： model/resolver/index.js12345678const resolvers = { Query: { async books(_source, _args, { dataSources }) { return dataSources.db.getAllBooks(); }, },};module.exports = resolvers; 通过前面的一系列构造，我们之前编写的数据库操作方法可以通过dataSources.db来访问，你可以使用await，也可以不使用，因为 resolver 的返回值可以是 Promise 对象，这主要取决于你的数据库操作方法是如何写的。 我们注意到每一个结构的resolver还有几个参数，resolver 可以接收四个参数，最常用的就是上面这段代码中写到的前三个参数。 第一个参数parent上面的代码中是_source，代表上一级解析器的返回值，因为 Schema 中定义的结构体是可以嵌套的，所以出现了多级选择器的概念，GraphQL 的解析顺序是从最外层解析的，返回最外层的解析结果之后才进行下一级解析，我们可以通过这个参数获取上一级的返回值然后将这个值作为下一级的参数。 第二个参数args上面的代码中是_args，顾名思义是参数的意思，指 GraphQL 查询中传递的参数如： GraphQL123query { book(id: 10)} 假设这是查询 id 为 10 的书籍信息，那么 resolver 中可以这样写： JavaScript12345678const resolvers = { Query: { async books(_source, _args, { dataSources }) { return dataSources.db.getAllBooks(_args.id); }, },};module.exports = resolvers; 然后在数据库操作方法的函数中接收这个参数。 第三个参数context第三个参数是上下文，由此可见，构造器其实是将我们的数据源db放在了上下文之中，dataSources.db则是我们的数据源，还记得之前传入ApolloServer的配置文件吗，我传入了一个 context 对象，ApolloServer 将它作为db对象的一个属性，这一点我不清楚为什么要这么设计，访问配置文件中传入的context对象通过如下方式获取： JavaScript12345678const resolvers = { Query: { async books(_source, _args, { dataSources }) { console.log(dataSourses.db.context.uid); // 20202020 return dataSources.db.getAllBooks(); }, },}; 如果你从头看完，至此相信你已经从零入门了，以上讲述的内容已经足够你开发一个功能完善的 GraphQL 服务器了，此外，不理解的话可以去 Apollo GraphQL 的官方网站看看。 如果你不想重复的配置项目，可以从我的仓库拉取代码初始化项目。 本文作者：KylinLee 本文链接：https://kylin.dev/https://kylin.dev/2020/07/07/Apollo-GraphQL快速上手-服务端 版权声明：本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2020/07/07/Apollo-GraphQL%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E6%9C%8D%E5%8A%A1%E7%AB%AF/"},{"title":"Button设计基本规则（译）","text":"对于前端来说，Button 元素是很常用的，虽然说 Button 的设计不是前端工程师的事，但是自己做网站可能会用到，最近看到一篇 Button 设计规则的文章觉得写的挺好，推荐给大家。 原文地址：https://uxplanet.org/7-basic-rules-for-button-design-63dcdf5676b4 为了方便阅读，将文章转成了中文并且做了一些修改（涉及侵权请联系，我将及时删掉） 让 Button 看起来更像按钮 在与用户界面进行交互时，用户需要立即知道什么是“可点击”而哪些不是。设计中的每个 UI 都需要用户解码。通常，用户解码 UI 所需的时间越多，对它们的可用性就越小。 但是，用户如何理解某个元素是否具有交互性？他们使用以前的经验和视觉指示符来解码 UI 的含义。这就是为什么使用适当的视觉指示符（如大小，形状，颜色，阴影等）使元素看起来像一个按钮这么重要。 对于移动用户来说，不太明显的提示一个更重要的问题。在尝试了解单个元素是否具有交互性时，桌面用户可以在元素上移动光标并检查光标是否更改其状态。移动用户没有这样的机会。要了解元素是否具有交互性，用户必须点击它，而没有其他方法可以检查交互性。 不要认为您的 UI 中的某些内容对您的用户来说是显而易见的 在许多情况下，设计者故意不将按钮识别为交互元素，因为他们认为交互元素对用户来说是显而易见的。在设计界面时，您应始终牢记以下规则： 12你对UI的理解能力不代表用户的理解能力，也许只有你知道自己UI设计的含义。 使用熟悉的 Button 样式 以下是大多数用户熟悉的按钮示例： 带方形边框的填充按钮 带圆角的填充按钮 带阴影的填充按钮 Ghost Button（只具备线条边框，不填充颜色的透明按钮） 在所有这些示例中，“带阴影的填充按钮”设计对用户来说是最清晰的。当用户看到对象的维度时，他们立即知道这是他们可以按的东西。 不要忘记空白 不仅按钮本身的视觉属性很重要。按钮附近的空白量使用户更容易（或更难）理解它是否是交互元素。在该示例中，下面的一些用户可能会将 Ghost Button 与信息框混淆。 将 Button 放在正确的位置 按钮应位于用户可以轻松找到或希望看到的位置。不要让用户寻找按钮。如果用户找不到按钮，他们就不会知道它存在。 尽可能使用传统布局和标准 UI 模式 按钮的常规放置提高了可发现性。使用标准布局，用户将很容易理解每一个元素的用途—— 即使它是一个没有强烈指示符的按钮。将标准布局与干净的视觉设计和充足的空白相结合，使布局更容易理解。 在页面中使用提示，当用户首次导航到包含您希望他们采取的某些操作的页面时，应该提示用户找到不同的按钮按钮。 标记 Button 以提示他们在干什么 带有通用或误导性标签的按钮可能会给您的用户带来不好的感受。编写按钮标签，清楚地解释每个按钮的作用。理想情况下，按钮的标签应清楚地描述其动作。 用户应该清楚地了解点击按钮时会发生什么。让我举个简单的例子。想象一下，您不小心触发了删除操作，现在您看到以下错误消息。 目前尚不清楚“OK”和“取消”在此对话框中的含义。大多数用户会问自己“当我点击’取消’时会发生什么？” 所以不要使用“确定”来标记，最好使用“删除”。这将清楚地显示此按钮对用户的作用。此外，如果“删除”是一个潜在的危险操作，您可以使用红色来表明这一操作。 调整按钮为合适的大小 按钮大小应反映此元素在屏幕上的优先级。大按钮意味着更重要的动作。 优先按钮 让最重要的按钮看起来像是最重要的按钮。始终尝试使主要操作按钮更加突出。增加尺寸（通过使按钮更大，使其对用户来说更重要）并使用对比色来吸引用户注意力。 使按钮对移动用户来说更友好 在许多移动应用中，按钮太小。这通常会导致用户输入错误的情况。 麻省理工学院触摸实验室的研究发现，指垫的平均值在 10-14mm 之间，指尖的平均值为 8-10mm。这使得 10mm x 10mm 具有良好的最小触摸目标尺寸。 按照顺序 按钮的顺序应反映用户与系统之间的对话性质。问问自己，用户期望在这个屏幕上有什么样的订单并进行相应的设计。 1用户界面是与用户的对话 例如，如何在分页中订购“上一个/下一个”按钮？合理的是，向前移动的按钮应位于右侧，向后移动的按钮应位于左侧。 避免使用过多按钮 这是许多应用和网站的常见问题。当您提供太多选项时，您的用户可能不知道究竟该点击哪个。在您的应用或网站中设计网页时，请考虑您希望用户采取的最重要的操作。 提供音效和视效反馈 当用户单击或点击按钮时，他们希望用户界面将以适当的反馈进行响应。根据操作类型，这可能是视觉或音频反馈。当用户没有任何反馈时，他们可能会认为系统没有收到命令并会重复操作。这种行为经常导致多次不必要的操作。 为什么会这样？作为人类，我们希望在与对象交互后获得一些反馈。它可能是视觉，音频或触觉反馈——任何承认交互已注册的事实。 对于某些操作，例如下载，不仅要确认用户输入，还要显示进程的当前状态。 结论 尽管按钮是交互设计的普通元素，但值得注意的是要使这个元素尽可能易于使用。按钮用户体验设计应始终与识别和清晰度相关。 本文作者：KylinLee 本文链接：https://kylin.dev/2019/08/18/Button设计基本规则（译） 版权声明：本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2019/08/18/Button%E8%AE%BE%E8%AE%A1%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99%EF%BC%88%E8%AF%91%EF%BC%89/"},{"title":"FirstStrike!","text":"FirstStrike，是一款以核打击为题材的单机游戏，中文名：先发制人。 这是一个我很早以前就开始玩的游戏，因为打游戏不上瘾，经常都不会玩一次，所以我的很多游戏都是还没打完就卸载了的。昨天心血来潮重新开始玩这款我认为超棒的游戏，我这样不太爱玩游戏的人都会时常回来玩两局。这款游戏以前是没有中文版的，所以国内知道的比较少，现在 Google play 上下载的最新版支持中文了，对国人更友好，索性今天写个简单的介绍，将这款游戏推荐给大家。 简单的做个属性介绍： 外文名：First Strike中文名：先发制人游戏标签：战争策略/单机平台：Android iOS厂商：blindflugstudios 游戏玩法：在游戏中，你将扮演一个拥有核打击能力国家的政府首脑，通过战略（研究武器，建立外交，核打击）等征服其他国家，成为世界上唯一的超级大国，同时你也需要保护自己的国家免受核打击。 游戏截图：中文支持这款游戏是非常容易上手的，官方的支持中文一并连 Guide 都支持了 控制面板游戏控制的主体是一个地球，点击你的领土会弹出炫酷的 3D 控制面板 广播每次核打击都会有这样的提示 核打击全面核打击 武器超级核武器 为什么推荐它的意义在战略游戏中获胜往往能给我们带来成就感，尤其是你扮演着一个超级大国的时候，但在这个游戏中获胜时你不会有这种感觉。 你真的赢了吗？你毁灭了多少个国家和地区？你让多少人成为了受害者？你释放了多少当量？ 如果你玩过PLAGUE INC.(瘟疫公司)，再玩这款游戏的时候，你会和玩瘟疫公司时有同样的感慨：“这简直就是毁灭人类的节奏啊！”。 我喜欢这个游戏不仅仅是因为它好玩，而是在于它和别的游戏出发点不同，每一款游戏都是一个作品，但不是所有作品都是有灵魂的，当你玩一个游戏的时候，你仔细想想，这个游戏真正的意义在哪。在 FirstStrike 中你能很清楚的明白创造它的人想告诉我们什么。 制作精良无论是操作，还是整体风格，都是满满的科技感，细节处理也很到位，比如一个地区受到核打击后是不能立即建立防御体系和核武器库的，在细微之处演绎核武器带来的危害。 其他推荐FirstStrike:FinalHour目前 FirstStrike 仅支持 Android 和 iOS 平台，如果你想在电脑上玩，可以尝试FirstStrike:FinalHour，这是 FirstStrike 的制作团队的续作（和 FirstStrike 差别不大），现已登录 steam，FirstStrike:FinalHour 也支持移动版。 Stellar CommandersFirstStrike 团队新近发布的Stellar Commanders，可以理解为 FirstStrike 的联机版本，可以和小伙伴们一起玩。 本文作者：KylinLee 本文链接：https://kylin.dev/2020/05/17/FirstStrike 版权声明：本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2020/05/17/FirstStrike/"},{"title":"ES6解构与剩余参数","text":"解构赋值是 ES6 中引入的非常有用的语法，掌握解构的技巧能让你更愉悦的敲代码，延长生命的长度。这篇文章是JavaScript快速拷贝数组的几种方法的拓展，因为上一篇文章扯远了，不得不再写一篇补充。 基本概念解构赋值是对赋值运算符的扩展。他针对数组或者对象进行模式匹配，然后对其中的变量进行赋值。就是按照视觉上的一一对应关系进行赋值。 数组解构赋值的顺序是数组索引的顺序 JavaScript1234let arr = [\"1\", \"2\", \"3\"];let [one = \"one\", two, three] = arr;console.log(`one: ${one}, two: ${two}, three: ${three}`);// 输出 “one: 1, two: 2, three: 3” 默认值数组解构和对象解构都可以使用默认值上面这段代码中第 2 行one = &quot;one&quot;是将 one 赋予默认值，当且仅当赋予one的值为undefined时使用这个值。 剩余参数数组解构和对象解构都可以使用剩余参数当有多余的值不想一一赋值的时候可以使用剩余参数，即将这些解构没有对应上的值全部放进一个数组： JavaScript123const arr = [\"a\", \"b\", \"c\"];let [a, ...bc];console.log(bc); // [\"b\",\"c\"] 数组解构作用数组解构快速换值JavaScript123var a = \"a\";var b = \"b\";var [b, a] = [a, b]; 一行代码实现变量值对换，这样做是不是延长了寿命？/笑哭 😂 快速拷贝数组JavaScript12const exampleArr = [1, 2, 3];const [...newArr] = exampleArr; 具体请参考我的这篇文章JavaScript快速拷贝数组的几种方法 对象解构语法和数组解构类似，但需要保证赋值的变量名和属性名一致： JavaScript123456const school = { name: \"TUST\", location: \"Tian'Jin\",};let { name: schoolName, location } = school;console.log(`${schoolName} is located in ${location}`); // TUST is located in Tian'Jin 重命名数组解构和对象解构中都可以使用重命名上面这段代码第 5 行，name: schoolName将school对象的name属性的值赋给schoolName，而不是name。 对象解构的作用解析配置对象对象解构常用于配置对象，比如传入一个对象作为配置，并且某些配置项是可选的，比如在 Vue 中使用 ElmentUI： 在引入 Element 时，可以传入一个全局配置对象。该对象目前支持 size 与 zIndex 字段。size 用于改变组件的默认尺寸，zIndex 设置弹框的初始 z-index（默认值：2000）。按照引入 Element 的方式，具体操作如下： JavaScript123import Vue from \"vue\";import Element from \"element-ui\";Vue.use(Element, { size: \"small\", zIndex: 1000 }); 第三行Vue.use除了传入Element，还可以传入一个配置对象作为全局配置，这个配置参数是可选的，那我们可以这样写（不一定是真实写法）： JavaScript1234567Element(...args){ const { size = \"-\", z-index = 2000 } = args[1] // ...若干代码} 实现 import在浏览器中如果我们使用script标签引入了一个 UMD 模块，使用模块中的变量可以用解构来减少写.操作符，比如： HTML1234&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/rxjs/6.3.3/rxjs.umd.min.js\" async&gt;&lt;/script&gt; JavaScript1const { of, map } = rxjs; 剩余参数和扩展运算的区别我们使用的时候一般都不会注意这个问题，通常就是很顺畅的写完了，代码一点错误都没有，即便如此，还是要搞清楚两者的区别啊，我看到很多博客文章都将二者混淆。 其实区分他们很简单，从字面意义上理解就行了，剩余参数是参数，有将参数合并成数组的作用，而拓展运算是展开数组，同样是三个点...，一个是存，一个是取，它们的作用似乎是相反的。 本文作者：KylinLee 本文链接：https://kylin.dev/2020/05/19/ES6解构与剩余参数 版权声明：本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2020/05/19/ES6%E8%A7%A3%E6%9E%84%E4%B8%8E%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0/"},{"title":"JavaScrip实现计数器的多种方法","text":"总结一下 JavaScript 实现计数器的几种方法，对于写出高性能代码有一定的帮助，同时也包含一些蛇皮操作。 普通写法JavaScript12345var counter = 0;function countUp() { return ++counter;}countUp(); 创建一个全局变量counter，每次调用countUp()都会使counter的值＋ 1，但是我们都知道无论是用何种语言写代码，都应该尽量使用少的全局变量，于是就有了下面这种经典写法。 使用闭包JavaScript1234567const countUp = (() =&gt; { let count = 0; return () =&gt; { return ++count; };})();countUp(); 这种写法能使用更少的全局变量，但闭包终归有闭包的缺点，它不会被垃圾回收机制处理，同时也不能像上一种写法那样重置counter，于是就有了下面这种写法。 使用函数属性JavaScript12345const countUp = () =&gt; { return countUp.count++;};countUp.counter = 1;countUp(); 在 JavaScript 中函数是一种特殊的对象，既然是对象，那他自然也有属性，我们定义一个函数来操作它的counter属性。这种写法很好的解决了上面三个问题： 解决闭包的内存占用 可以重置counter 尽量少的全局变量 如果你会TypeScript，那么通过下面这个例子你能更好的理解函数属性。 JavaScript1234interface CountUp { (): number; counter: number;} 上面这段代码定义了一个函数接口，这个函数拥有 0 个参数，返回值是一个number类型的值，并且有counter属性。 让我们看看最后一种写法，这种写法没有任何优势，甚至是大材小用的写法。 GeneratorJavaScript1234567891011const counter = (function* Counter() { let count = 0; while (true) { count++; yield console.log(count); }})();function countUp() { return counter.next();} 在这里，我们使用了一个无限迭代器来实现，通过使用counter.next()来手动使迭代器迭代，个人认为这种写法比使用闭包的开销还要大，用作计数器实在是大材小用了。迭代器在 ES6 之前就被实现了，在 ES6 中才正式成为规范，它在 JavaScript 的作用通常是用来构建异步函数（async/await）。 虽然最后这种写法没有什么实质性的作用，但对于理解迭代器还是有帮助的，另外，有些厂笔试就喜欢出这种花里胡哨的题。 本文作者：KylinLee 本文链接：https://kylin.dev/2020/05/08/JavaScrip实现计数器的多种方法 版权声明：本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2020/05/08/JavaScrip%E5%AE%9E%E7%8E%B0%E8%AE%A1%E6%95%B0%E5%99%A8%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E6%B3%95/"},{"title":"JavaScript快速拷贝数组的几种方法","text":"本文总结快速拷贝数组的几种方法（个人认为总结都很无聊），文章旨(chun)在(shu)总(wu)结(liao)，对于日常编码，只需挑选一种写法即可，通过本文，你将对 JavaScript 数组方法及 ES6 有更多的了解。 为了不重复写代码，所有例子都是以下面这个环境为基础。 JavaScript1const exampleArr = [1, 2, 3]; 循环还是写一些基础的for循环吧 JavaScript12345let length = exampleArr.length;const newArr = [];for (let i = 0; i &lt; length; i++) { newArr.push(exampleArr[i]);} 使用forEach() JavaScript1234const newArr = [];exampleArr.forEach((value) =&gt; { newArr.push(value);}); 如果面试官问你如何拷贝一个数组，你只会for循环，那估计你是凉凉了。 Array.prototype.map()map()方法建一个新数组，其结果是该数组中的每个元素都调用一次提供的函数后的返回值。这种方法和forEach()相差无几，都是通过回调函数来为新数组赋值。 JavaScript1const newArr = exampleArr.map((value) =&gt; value); Array.prototype.filter()filter()方法返回一个回调函数过滤后的新数组，他有一个回调函数和指向当前数组的this（可选参数）作为参数，回调函数的参数和forEach()及map()方法相同，当回调函数返回true时则将当前处理元素放进新数组。 JavaScript1const newArr = exampleArr.filter((i) =&gt; true); Array.prototype.concat()concat()方法用于合并两个或多个数组，并返回一个新数组，参数可以是 0 个或多个数组。当有 0 个参数的时候显然会返回一个拷贝数组： JavaScript1const newArr = exampleArr.concat(); Array.prototype.slice()slice()方法实现了数组的浅拷贝，就是说当拷贝数组里的对象时只会保留引用。它有两个可选索引参数，由于确定从何处开始拷贝，何处停止拷贝，如果省略参数即拷贝整个数组。 JavaScript1const newArr = exampleArr.slice(); 还有一个和slice()方法类似的copyWithin()方法，他们都是浅拷贝，但copyWithin()浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度。说的不是很明白？举个例子： JavaScript12const array1 = [\"a\", \"b\", \"c\", \"d\", \"e\"];array1.copyWithin(0, 3, 4); 它的第一个参数是开始替换的索引位置，后面两个可选参数分别表示从何处开始复制，在何处结束复制，如果省略即复制整个数组。上面这个例子表示复制索引[3,4)的值(左闭右开)，然后将每个值从第 0 个索引开始覆写。最终值将是[“d”,”b”,”c”,”d”,”e”]。 所以下面这种写法并不是拷贝数组，因为它的拷贝值都赋值给自身了，newArr仅仅是保留了引用。 JavaScript1const newArr = exampleArr.copyWithin(0); 数组解构+剩余参数JavaScript1const [...newArr] = exampleArr; 数组解构是 ES6 中的语法，通过数组解构可以将数组的值保存到解构对应的变量中，当不想一一赋值的时候可以使用剩余参数，将所有剩余的值保存在一个数组中，上面这段代码就是这种做法，将所有的值保存在newArr中。注意是剩余参数，而不是扩展运算，二者很像，他们的区别请看这篇文章ES6解构与剩余参数的最后一部分。 本文作者：KylinLee 本文链接：https://kylin.dev/2020/05/09/JavaScript快速拷贝数组的几种方法 版权声明：本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2020/05/09/JavaScript%E5%BF%AB%E9%80%9F%E6%8B%B7%E8%B4%9D%E6%95%B0%E7%BB%84%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"},{"title":"HTML5元素拖拽原理实现","text":"拖拽功能常见于一些模板生成网站，比如 H5 制作网站，我以前都没有注意这一方面，因为功能需要，特地去了解了一下元素拖拽 API。 两种效果：常见的拖拽有两种效果，一种是拖拽到某个区域后放开自动补位，一种是拖动到任意位置。两种效果实现原理是不一样的。 第一种效果原理：先看看用到的 drag 事件的API： dataTransfer：The data that underlies a drag-and-drop operation, known as the drag data store. Protected mode.（机器翻译：作为拖放操作的基础的数据，称为拖放数据存储区.保护模式）【参考】。 target：被拖动元素下方的元素，常作为放置区域元素。 实现原理其实是将被拖拽的元素插入到放置区域元素的节点下，需要用到appendChild。 因为放置区域可能不止一个，所以用drag事件的target方法获取放置区域元素。 而同样的被拖拽的元素可能也不止一个，所以用drag事件的dataTransfer方法传递该元素的 id 或者指向唯一节点元素的值。 注意： 在放置到区域的时候（ondrop）和元素拖拽结束的时候（ondragover）要阻止放置区域元素的默认事件，方法是preventDefault()。 第二种效果原理：涉及到的 drag 事件API： screenX：鼠标相对于屏幕的 X 坐标 screenY：鼠标相对于屏幕的 Y 坐标 clientX：鼠标指针相对于 DOM 的 Y 坐标 clientY：鼠标指针相对于 DOM 的 Y 坐标 实现原理其实也很简单，即记录拖拽过程中的坐标差值，将元素的本身位置坐标加上这个差值。 实现只横向移动，例如滑块验证，只需记录 X 坐标，同理也可以实现竖向滑动。 本文作者：KylinLee 本文链接：https://kylin.dev/2019/12/26/HTML5元素拖拽原理实现 版权声明：本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2019/12/26/HTML5%E5%85%83%E7%B4%A0%E6%8B%96%E6%8B%BD%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0/"},{"title":"JavaScript中的协程","text":"本篇是《尝试用通俗的方式解释协程》的续集，上一篇梳理了一遍协程的概念，现在我们用 JavaScript 为例更深入的了解协程。 协程长啥样直接上代码看看 JavaScript 中协程是怎样的： JavaScript1234567891011function* idMaker() { let index = 0; while (true) yield index++;}let gen = idMaker(); // \"Generator { }\"console.log(gen.next().value); // 0console.log(gen.next().value); // 1console.log(gen.next().value); // 2// ... 没错，就是一个生成器，生成器本身是一个函数，也就是说在 JavaScript 中协程是由一个生成器函数实现的。 协程如何切换协程本身是个函数，协程之间的切换本质是函数执行权的转移。 生成器函数的yield关键字有可以交出函数的执行权，挂起自身，然后 JavaScript 引擎，去执行这个函数后面的语句，在上面这个例子中，第 8 行调用gen.next()开始执行生成器函数的内容，第一次while循环里yield交出了执行权，JavaScript 引擎转而执行第 9 行，再次调用gen.next()，这时候 JavaScript 接着上次挂起的地方执行，不会重新执行let index = 0语句，然后执行函数内的语句，对于这个例子，使用yield和next()方法就能不断的交出和恢复函数的执行权，怎么样，是不是有点感觉了？站在一个线程的角度看，线程的切换就是这样不断让 CPU 暂停和继续对自己执行。 上面这个例子是把生成器函数的执行权交给普通函数（你也可以把非协程看做是一个协程整体），也可以在一个协程中调用另一个协程，实现协程之间的切换，比如这个例子： JavaScript12345678910111213141516171819function* anotherGenerator(i) { yield i + 1; yield i + 2; yield i + 3;}function* generator(i) { yield i; yield* anotherGenerator(i); // 移交执行权 yield i + 10;}var gen = generator(10);console.log(gen.next().value); // 10console.log(gen.next().value); // 11console.log(gen.next().value); // 12console.log(gen.next().value); // 13console.log(gen.next().value); // 20 第 9 行使用yield*将执行权交给另一个生成器函数，接下来要等到这个生成器函数anotherGenertor()执行完毕执行权才会回到generator函数。这和普通函数表现一致，都是后进先出，如果感兴趣可以去看看 JavaScript 事件循环机制（Event Loop），本篇就不再多说了。 协程如何实现异步异步搞清楚什么是同步，什么是异步，问题才能很好的讨论下去。先说同步： JavaScript1234567res = function fetchFun() { // 请求资源 // res = .... return res;};console.log(res); 计算机按照程序顺序执行代码，比如这几行代码一定第三行先给res赋值，然后才是打印res，而非同步（即异步）可以先执行后面的console.log(res)，然后再给res赋值。 为什么需要这么做呢，当一个请求需要耗费大量的时间，程序执行一直停留在这一行，就会引发阻塞，最容易受影响的是eventListener，事件监听没了，在请求数据的时候点击事件都是无效的。 所以实现异步的关键就是把会阻塞线程函数的执行权交出去，让这个函数等待恢复执行，等待的时间内请求（或者其他异步任务）也该执行完了，这时候再来继续执行这个函数。通过前面对协程的运行方式的讲解我们很容易就能想到用协程来解决这个问题，利用yield挂起这个阻塞线程函数，然后继续执行后面的语句，等这个函数不再阻塞了，再回到这个函数继续执行。那么问题来了，应该什么时候继续执行这个挂起的函数呢？你可能想到大概估计一下阻塞时间，设定时间再回来执行，这个方案。。。有点牵强。 Promise这时候 Promise 就派上用场了，Promise 本质是一个状态机，用于表示一个异步操作的最终完成 (或失败), 及其结果值。它有三个状态： pending: 初始状态，既不是成功，也不是失败状态。 fulfilled: 意味着操作成功完成。 rejected: 意味着操作失败。 最终 Promise 会有两种状态，一种成功，一种失败，当 pending 变化的时候，Promise 对象会根据最终的状态调用不同的处理函数。 根据 Promise 的特点，他是一个状态机，在yield之后可以用 Promise 来表示异步任务是否执行完毕（是否是 pending 状态），并且还能够自动判别异步任务成功与否（fulfilled 还是 rejected）并执行处理函数。如此看来用协程+Promise 可以完美实现异步。 好的，让我们来根据上面的理论实现一下吧： JavaScript1234567891011121314151617181920212223// 模拟阻塞事件function resolveAfter2Seconds(val) { return new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve(val); }, 2000); });}// 实现生成器function* coroutineFunc(val) { yield resolveAfter2Seconds(val);}let doIt = coroutineFunc(\"OK\");let value = doIt.next().value;// value是Promise对象value.then((res) =&gt; { console.log(res);});// 模拟后面被阻塞的语句for (let i = 0; i &lt; 10; i++) { console.log(i);} 这段代码的输出顺序是 0=&gt;1=&gt;2=&gt;…=&gt;9，两秒之后输出’OK’，从输出顺序来看我们已经实现了异步。其执行过程和之前说的一样，挂起会阻塞运行的函数，继续执行后面的语句，等待 Promise 改变状态并自动执行处理函数。 使用 Generator、Promise 组合和直接使用 Promise 的区别实际上下面这段代码运行顺序的结果和上面一模一样： JavaScript1234567891011function resolveAfter2Seconds(val) { return new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve(val); }, 2000); });}resolveAfter2Seconds(\"OK\").then((res) =&gt; { console.log(res);}); 为什么要使用上面那种复杂的写法呢？为了简化问题，便于理解，我已经简化了代码，在前一个例子中，生成器函数内，11 行以后完全可以写更多的代码，这些代码一定是在异步获取到数据之后才执行的。如果直接使用 Promise 需要把这些代码放在 then 代码块里边才能保证在异步获取到值之后执行，那么当有多个异步事件的时候问题就来了——可怕的嵌套！ Async、AwaitECMAscript2017 中提供了更高级的协程控制语法，其被看做是对 Generator 和 Promise 组合的封装，使异步函数看起来更像同步函数，减轻开发者的痛苦。上面的例子改写： JavaScript123456789101112function resolveAfter2Seconds(x) { return new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve(x); }, 2000); });}async function f1() { var x = await resolveAfter2Seconds(10); console.log(x); // 10} 可以看出 Async、Await 实现了 Generator 的自动迭代，不需要手动使用next()方法来继续执行。正因为 Async、Await 是对 Generator 和 Promise 组合的封装，所以 Async 和 Await 基本上就只能用来实现异步和并发了，而不具有协程的其他作用。 本文作者：KylinLee 本文链接：https://kylin.dev/2020/06/13/JavaScript中的协程 版权声明：本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2020/06/13/JavaScript%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B/"},{"title":"ThinkPHP5安装","text":"ThinkPHP 是一款开源的 PHP 框架 问题描述 安装时查看《ThinkPHP5.0 完全开发手册》-&gt; 基础 -&gt; 安装 ThinkPHP 采用 Git 安装https://github.com/top-think/thinkhttps://github.com/top-think/framework 执行下载完所有文件之后启动服务器，访问http://localhost/tp5/public/ 很显然下载的文件中没有 tp5 的文件夹 此时只需将下载的项目文件夹改为 tp5 就行了 默认读取 public 目录下的 index.php 文件 但是将得到两条错误信息，大致意思是说 public/index.php 文件的第 17 行有错误，并且提示缺少文件 仔细打开文件查看是require __DIR__ . '/../thinkphp/start.php';这行代码 显而易见，下载的项目中并没有这个 thinkphp 在这个文件夹 于是查看 GitHub 上的 README.md 文件，文件说明上标明了有这个文件夹 经过查找，在简书上看到一篇文章，解决了这个问题 解决方法 在之前我将项目目录改成了 tp5 之后将 framework 文件夹重命名为 thinkphp 再次访问http://localhost/tp5/public/，问题已解决 其实最简单的方法就是在 git clone 的时候重命名文件夹了 Bash12git clone https://github.com/top-think/think tp5git clone https://github.com/top-think/framework thinkphp 本文作者：KylinLee 本文链接：https://kylin.dev/2019/09/26/ThinkPHP5安装 版权声明：本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2019/09/26/ThinkPHP5%E5%AE%89%E8%A3%85/"},{"title":"Vue-CLI优雅的解决跨域问题","text":"跨域问题一直是前端上线调试的一个坑，在 webpack 时代，我们需要开启一种更好的跨域调试方式。 什么是跨域问题这是浏览器的一种安全机制，同源策略，即浏览器不能执行其他网站的脚本。说的比较笼统，可以理解为浏览器只允许网站和同一域名的服务器通过xhr传输数据。注意是xhr请求，通常点一个链接或者使用 JS 跳转页面是不会有跨域问题的。 解决方法解决方法是很多的，细数的话有 5 种以上。 公司解决跨域问题的常见方法 一般都是后端允许跨域即后端在响应头加上Access-Control-Allow-Origin:*，这是一劳永逸的方法，可以在测试期间允许跨域，项目部署好之后再禁止跨域。 利用 Vue 调试服务器优雅的解决首先要明确为什么推荐这样使用 大家都知道 Vue 是数据驱动，离开了数据 Vue 基本上不能呈现想要的页面。 所以在 Vue 调试的时候都是需要连接后端的。 如果部署到 API 服务器，首先 Vue 通过 webpack 打包，然后上传到服务器，这样的确可以解决跨域问题，但是流程复杂，而且在多个人开发一个项目的时候不能协同开发。 Vue-CLI 初始化项目正好自带了开发服务器，不用再安装别的软件或者模块，操作简单。 解决方法笼统的来说是通过反向代理，前端开发者可能对于这些不太了解，但是我们知道怎么做就行了。 在调试的时候打开 devServer，npm run serve或者npm run dev，看具体配置。 这时会启动一个localhost服务器，具体端口看配置文件，通常是localhost:8080。 这时需要配置配置文件了，让这个 devServer 进行代理，因为服务器是没有同源策略限制的。 配置文件关于代理部分的配置. vue.config.js 中的 devServer.proxy 选项来配置。 devServer.proxy 可以是一个指向开发环境 API 服务器的字符串： vue.config.js12345module.exports = { devServer: { proxy: \"http://imakerlab.cn\", },}; 这会告诉 devServer 将任何未知请求 (没有匹配到静态文件的请求) 代理到http://imakerlab.cn如果你想要更多的代理控制行为，也可以使用一个 path: options成对的对象。完整的选项可以查阅http-proxy-middleware vue.config.js1234567891011121314module.exports = { devServer: { proxy: { \"/api\": { target: \"http://imakerlab.cn/api\", ws: true, changeOrigin: true, }, \"/foo\": { target: \"http://imakerlab.cn/foo\", }, }, },}; 其实这个 devSever 就是webpack-dev-server，所以vue.config.js的devServer参数完全可以按照webpack-dev-server配置。 开发实例比如说：将/api开头的 API 转到http://imakerlab.cn vue.config.js12345678module.exports = { //... devServer: { proxy: { \"/user\": { target: \"http://imakerlab.cn\" }, }, },}; 这样，当我们链接写/user/2333的时候，就会访问http://imakerlab.cn/user/2333，而不是localhost:8080/user/2333。这样浏览器表面访问的是localhost，但实际访问的是imakerlab.cn，很好的解决了跨域问题。当然，开发服务器同样支持 url 重写，仔细去看看官方文档吧！ 本文作者：KylinLee 本文链接：https://kylin.dev/2020/02/21/Vue-CLI优雅的解决跨域问题 版权声明：本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2020/02/21/Vue-CLI%E4%BC%98%E9%9B%85%E7%9A%84%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"},{"title":"你永远有做不完的事","text":"这篇文章出自美国作家理查德·卡尔森 Richard·Carlson的笔下，偶然读到，思绪万千，颇有感受。 你永远有做不完的事Richard·Carlson 许多人过日子的方式，好像有一个秘密目标，非要把一切事情都做完不可。我们熬夜、早起、不敢放纵逸乐，让我们所爱的人一直等下去。可悲的是，太多人就是因为让他们所爱的人等太久，最后对方终于放弃了这段感情。以前，我就这个样子。我们通常会说服自己，忙得不可开交只是暂时的，一旦做完了该做的事，我们就能平静放松下来，并且心情愉快。事实上，这样的境界永远不会到来，因为旧的事情刚做完，新的立刻接踵而至。 “待办清单”只意味着你有一些事情尚待处理，并不表示你得全部做完。人永远都有没打完的电话、未结束的计划、未完成的工作。事实上，我们可以说，一张写得满满的待办清单才是成功的要素，因为这代表你的时间很宝贵。 不过，不论你是什么大人物，或者在做什么大事，记住，没有什么事比你和你所爱的人的幸福和内心安宁更重要。如果你一直执著于完成所有事情，那永远不会有幸福的感觉！其实，几乎所有的事情都是可以等的，我们的工作中真正属于“紧急”的事少之又少。只要你专心一意地工作，事情都会及时完成的。 我发现，如果我（经常）提醒自己，人生的目的并非完成所有事情，而是去享受生命旅途上的每一步，过着充满爱的生活，我就不太会有执著于非得完成所有事情不可的念头。记住，在你离开人世的那一天，还是会留下未完的事需要别人代劳，而且也一定会有人来代劳的！别浪费了生命的每一分每一秒，再做无谓的惋惜。 对错，选择生活还是被生活这也许就是每个人的选择吧，无所谓选择取决于你，我们往往会选择前者，因为它是理想的，但也常常会不自觉的走入后者。我们常常感觉被困在生活之中，有很多事你以为你无从选择，但那只是你内心告诉你的。 我的意思也并不是劝人一味的享受受生活，和作者的观点相同，没必要所有事都自己做，在这种没必要的情况下，请别人代劳可能是一种明智的选择。 最典型的例子大概就是“子欲养而亲不待”了吧，别再“等我忙完的时候在回来看您”，因为你永远有做不完的事。 如果你有任何想法，欢迎在下方评论区留言。 本文作者：KylinLee 本文链接：https://kylin.dev/2020/03/07/你永远有做不完的事 版权声明：本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2020/03/07/%E4%BD%A0%E6%B0%B8%E8%BF%9C%E6%9C%89%E5%81%9A%E4%B8%8D%E5%AE%8C%E7%9A%84%E4%BA%8B/"},{"title":"Travelling，下一站去哪？","text":"Travelling是一个随机友链的工具，此博客于 2020 年 2 月 9 日加入 Travelling，同时也希望更多的朋友能加入。 什么是 TravellingTraveling 的本质是网站随机重定向，根据随机得出的结果以及与博客的对应关系，重定向到对应的个人博客链接。当你访问Travelling时，你会被重定向到一个 Travelling 收录的网站，每一个 Travelling 收录的网站都能够继续访问Travelling，这样便完成了接力，不知不觉的走遍了收录的所有个人博客。 Travelling 带来了什么增加流量根据 GitHub 上 Travelling 的作者介绍，Travelling 可以用来增加个人博客的流量。 开往能增加我网站的流量吗？当然。不恰当的估算下：假设当前有 2 个网站加入了开往，每个网站有 10 人使用开往，那么每个网站似乎就增加了 10×2×1/2=10 的流量；如果有 10 个网站加入开往是不是还是平均下来增加 10 人的流量呢？显然不是，因为： 访客可通过开往多次友链接力； 有开往的网站多了，单站击量也会提高； 这样我们再算算，10 个网站加入了开往，接力次数提升到 3，每个网站有 15 人使用开往，那每个网站就增加了 15×10×3/10=45 的流量。 这也是为什么建议将开往的徽标放在您网站明显位置（推荐顶栏，侧栏）的原因，以便让友链一直接力下去，获得更多的流量。 同时增加博客的曝光度。 发现大千世界除了给自己的网站增加流量，提高曝光度，你还可以通过 Travelling 去发现更多的有趣的博客，很多时候我们想去看看更多博客，却无从选择，那就让 Travelling 帮我们选择吧。 说点别的谈谈 Traveling 的设计，和介绍一样，他还太小，很多功能都不完善，这样的设计很简单，现在的 Travelling 就像一个大容器，所有东西不加区分全部都在这个容器里边，管理起来很不方便。而且要拿取里面的东西，只能往这里边拿，当 Traveling 庞大起来，这样的设计缺陷就会很明显。 对 Travelling 的期望个人更倾向于分布式的设计，将不同类别的博客放进不同的小容器，对这些博客加以区分，使用的时候带上标记，这样可以很大概率找到喜欢的博客。此外，除了统一收录，每个博客也应该有一些自己的“朋友圈”，用 Travelling 去寻找每一个网站的“朋友圈”也是一件有趣的事情。Travelling 的潜力还是很大的，希望 Travelling 能越走越远 本文作者：KylinLee 本文链接：https://kylin.dev/2020/04/09/Travelling，下一站去哪？ 版权声明：本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2020/04/09/Travelling%EF%BC%8C%E4%B8%8B%E4%B8%80%E7%AB%99%E5%8E%BB%E5%93%AA%EF%BC%9F/"},{"title":"Windows上值得一荐的应用（19年7月）","text":"Windows 上 PDF 编辑器、浏览器推荐。 PDF 阅读&amp;编辑PDF Element 优点：可以作为 Office 套件的插件，也是一款独立的软件，界面和 Office 相统一。 缺点：免费版本导出为 PDF 后会有水印。 Adobe Acrobat Reader 优点：PDF 格式是由 Adobe 提出的，没有人比自己更了解自己。 缺点：订阅式付费算吗？ Able Word 优点：界面和 Office2003 相统一，一看见就会觉得是老朋友，非常顺手，重点是免费，无水印。 缺点：最新版本是 2015 年的，网站没有关停，但是貌似已经停更了，各位可以坐等诈尸。打开大文件时性能不佳，但是自己写 PDF 文件还是很快的。 还有一个不知道算不算缺点，因为是国外软件，界面是英文，介意的不用折腾了，不过初中的英语水平应该够了。 还有很多优秀的 PDF 编辑软件，比如XXX，等等…（之前还用过一些，记性不好 😂），除此之外还有很多 PDF 工具网站，不久之后再做分享。浏览器Chrome&amp;CentBrowser 优点：开发者专用，二者差不多，都可以使用谷歌账号同步，只是 CenrBrowser 添加了手势等，用起来更方便。 缺点：占用内存大一直是个问题。 Vivaldi 优点：极富创新性的浏览器，可以自定义标签的位置，网页滤镜，显示加载进度，标签随网页变色，3D 旋转网页，自定义主题，窗口分栏显示，同时显示手机浏览器窗口等功能，当然，同样可以安装 Chrome 插件，如果想体验新的东西，绝对是最好的选择。 缺点：Windows 体验不佳，推荐 Linux 或者 X OS 上面体验 BraveBrowser 这是个有故事的浏览器，创始人之一是 JavaScript 之父。这个浏览器同样是 chromium 的核，自带强力广告过滤，当然，因为这个会有很多网站进不去，也因此速度比 Chrome 快两倍，在手机上面比 Chrome 和 Safari 最多快 8 倍。 EpicBrowser * 专注安全的浏览器，内置 VPN，当然，不是国人理解的那种。如果有什么相关的推荐，或者文章有错的地方，欢迎大家评论 本文作者：KylinLee 本文链接：https://kylin.dev/2019/07/27/Windows上值得一荐的应用（19年7月） 版权声明：本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2019/07/27/Windows%E4%B8%8A%E5%80%BC%E5%BE%97%E4%B8%80%E8%8D%90%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%8819%E5%B9%B47%E6%9C%88%EF%BC%89/"},{"title":"Windows上值得一荐的应用（19年8月）","text":"Windows 上媒体播放器、下载管理器推荐。 媒体播放器Dopamine 优点：优秀的音乐播放器，界面非常美观，支持音效，联机获取歌词，音乐动效。 缺点：国内安装包下载慢。 PotPlayer 优秀到不想多说，设置太复杂。各位自行体验好吗。 爱奇艺万能播放器 推荐下载 UWP 版，主要优点就是能直接播放百度云链接。 下载管理器Thunder 说英文高级点，不多说。 IDM 也不多说，很强大。 FDM 全名 Free Download Manager，免费，自定义最大线程数 10000，支持普通链接、磁力、种子下载。 Motrix 最近被吹的很火的一个下载器，支持普通链接、磁力、种子下载，但是实际效果并不太好，很多时候会莫名无法下载，但是界面很漂亮，还是推荐一下。 BitTornado 专门下载种子的下载器，图形界面几乎没有，没有多余的设置，下载速度超快。 本文作者：KylinLee 本文链接：https://kylin.dev/2019/08/20/Windows上值得一荐的应用（19年8月） 版权声明：本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2019/08/20/Windows%E4%B8%8A%E5%80%BC%E5%BE%97%E4%B8%80%E8%8D%90%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%8819%E5%B9%B48%E6%9C%88%EF%BC%89/"},{"title":"Windows上的包管理器","text":"Linux 的软件包管理器，如 apt、yum、dnf、pkg，极大的方便了 Linux 软件的安装，在 Windows 上大家都习惯使用可执行安装文件安装软件，但其实在 Windows 上也有软件包管理器，习惯使用之后会在一定程度上方便软件的管理。 Chocolatey 软件包管理器官网地址：https://chocolatey.org/ 初步讲解 Chocolatey 的安装安装1.电脑以管理员身份运行 cmd 或者 PowerShell如果使用的是 cmd，运行命令@&quot;%SystemRoot%\\System32\\WindowsPowerShell\\v1.0\\powershell.exe&quot; -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command &quot;iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))&quot; &amp;&amp; SET &quot;PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin&quot;如果使用的是 PowerShell，先运行Get-ExecutionPolicy。如果返回Restricted，则运行Set-ExecutionPolicy AllSigned或Set-ExecutionPolicy Bypass -Scope Process。之后运行命令Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))没有出现error，最后使用choco命令或者choco -?命令验证是否安装成功，如安装不成功请查阅官方文档。 本文作者：KylinLee 本文链接：https://kylin.dev/2019/10/25/Windows上的包管理器 版权声明：本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2019/10/25/Windows%E4%B8%8A%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/"},{"title":"前端周报（第一期）","text":"由创新实验室前端组的成员共同完成，每周分享前端经典文章等内容，来源于 GitHub、CSDN、微信公共号、掘金、知乎等平台。 又一个框架来了！被称为要取代 React , vue ，Aangular ！ Excel.js-Node 环境下操作 Excel 文件 前端初级新人，如何撕去菜鸟标签 SheetJS-在浏览器中操作 Excel 文件 ES6 中 export、export default、import 的理解 深入理解 JavaScript 的设计模式 HTML 标签伪元素绑定事件的三种方式 ES6，ES7，ES8，ES9，ES10 新特性一览 ​ 不容错过的 13 个 JavaScript 实用技巧！ GitHub 推出新特性：展示附件文件所有者 Vue 入门","link":"/2019/10/28/%E5%89%8D%E7%AB%AF%E5%91%A8%E6%8A%A5%EF%BC%88%E7%AC%AC%E4%B8%80%E6%9C%9F%EF%BC%89/"},{"title":"在Hexo上分享歌曲","text":"一款大名鼎鼎的 JS 插件，在 Hexo 上也能听歌了！ 这是一款叫做aplayer.js的开源插件，通过简单的配置就能在页面中插入美观的音乐播放控件，插件地址。一起来看一看效果吧！ 本文作者：KylinLee 本文链接：https://kylin.dev/2020/05/09/在Hexo上分享歌曲 版权声明：本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2020/05/09/%E5%9C%A8Hexo%E4%B8%8A%E5%88%86%E4%BA%AB%E6%AD%8C%E6%9B%B2/"},{"title":"jQuery链式操作实现原理","text":"jQuery 是一个快速，小巧，功能丰富的 JavaScript 库。jQuery 的一个特点就是链式操作。本文粗略讲解其原理。 相信大家对链式 jQuery 的链式操作并不陌生，在这里简单的介绍一下链式操作的实现思路（用原生 JS 实现链式操作）。 首先我们观察一下 jQuery 的基本语法 1$(selector).action(); 基本语法由选择器和执行函数组成，jQuery 选择器返回的是一个自建对象（Object），jQuery 函数的方法是属于这个对象的，也就是说这些方法只能由这个对象来调用，所以实现链式操作只需要在执行一个函数后返回对象就行了。 示例如下： JavaScript12345678910var obj = { sayName: function (name) { comsole.log(\"i am \" + name); return this; }, action: function (action) { comsole.log(\"i am \" + action); return this; },}; 这里的return this返回了一个对象，通过obj.sayName(&quot;jQuery&quot;).actoin(&quot;chaining&quot;)就可以实现连续调用函数了。 其实并非是 jQuery 中才有这种链式操作，原生 js 中同样有的，比如有很多字符串和数组的方法都会返回字符串或者数组（字符串通过包装类返回字符串对象并拥有方法），例如反序输出字符串： 12var str=\"Wellcome\"；str.split('').reverse().join('') 综上所述，在一个方法中返回一个 Object 类型的值就能实现类似 jQuery 的链式操作。 本文作者：KylinLee 本文链接：https://kylin.dev/2019/06/03/jQuery链式操作实现原理 版权声明：本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2019/06/03/jQuery%E9%93%BE%E5%BC%8F%E6%93%8D%E4%BD%9C%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},{"title":"响应式设计中设备分辨率的问题","text":"可能有这么一个疑问，为什么在网页中宽度小于 500px 左右就被认定为手机，但手机屏幕宽度明明是 1080px 啊，本篇文章帮你解答这个疑惑。 问题描述在响应式设计中，为了适配移动端，会设置媒体查询，如当媒体查询屏幕尺寸小于某个值的时候应用移动端样式，但是我们一般将这个值设置为 500px 左右或者更小，为什么不是手机的屏幕尺寸呢？如果设置为手机尺寸，为什么不会应用设定好的移动端样式呢？ 进入正文这中间有一个很重要的概念：逻辑分辨率 逻辑分辨率逻辑分辨率的概念应该和物理分辨率区分开物理分辨率是指设备能控制显示的最小物理单位，意指显示器上一个个的点。从屏幕在工厂生产出的那天起，它上面设备像素点就固定不变了，和屏幕尺寸大小有关，单位 pt。而逻辑分辨率可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用的虚拟像素(比如: css 像素)，这个点是没有固定大小的，越小越清晰，然后由相关系统转换为物理像素。简单地说，逻辑分辨率是我们肉眼感知的实际尺寸。应该注意：CSS 中使用的是逻辑分辨率而不是物理分辨率 逻辑分辨率的转化物理分辨率 = 逻辑分辨率 × 设备像素比在 iphone3gs 的时候，逻辑分辨率是 320×480，物理分辨率也是 320×480iphone4 出了之后，逻辑分辨率和 3gs 一样是 320×480，显示的内容是一样多的，但是物理分辨率变成了 640×960，原来在 3gs 的一个像素内容，在 iphone4 上则填充了 4 个像素，因此虽然内容显示还是一样多，但是 iphone4s 的屏幕精细度比 3gs 高了 2 倍。这个 2 倍就是设备像素比。 通过 JavaScript 来验证window.screen.width ，window.screen.height 为设备的逻辑宽高window.devicePixelRatio 为设备像素比验证一下： 本文作者：KylinLee 本文链接：https://kylin.dev/2020/03/08/响应式设计中设备分辨率的问题 版权声明：本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2020/03/08/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%AD%E8%AE%BE%E5%A4%87%E5%88%86%E8%BE%A8%E7%8E%87%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"在Vue中使用GraphQL","text":"本文帮助你在 Vue 中使用 GraphQL，也许你尝试使用过axios，不得不说 axios 并不适合用来发送 GraphQL API 请求，本文介绍一种更简单的方式并且带你上手。如果你对 GraphQL 后端感兴趣可以阅读我的上一篇文章《Apollo-GraphQL快速上手-服务端》。 官方维护的 Apollo Client 是 React 编写的，我使用的是 Vue，虽然说是由社区维护，但 API 基本是按照 React 版本的来写的，用起来障碍也不大。 安装社区维护的 Vue 版本的 Apollo Client 叫vue-apollo，安装也相当简单，首先使用 Vue Cli 创建一个项目，然后在项目文件夹运行命令：vue add apollo。 由于有中文文档，我就取其精要，带大家简单上手，更高级的操作，大家可以去网站上看一看。本文的逻辑和文档大不相同，如果你理解本文的思路，你将可以更灵活的操作 GraphQL 请求 apollo 对象apollo对象是 apollo-vue 的核心，无论是查询还是变更，只要向可接受apollo对象的地方传入它就可以完成 GraphQL 的查询与变更。常用的属性和方法有四个：query、variables、mutation、update()，看起来应该是这样的： template.vue123456789101112apolloObj: { query: gql` query{} `, mutation: gql` mutation{} `, variables: { var1: this.data.name }, update(){}} query：GraphQL 查询代码 mutation：GraphQL 变更代码 variables：GraphQL 代码中不能使用 js 的变量，variables相当于转换器，将 js 代码转换为 GraphQL 代码并使用，在 GraphQL 中，使用$标识符引用变量。 update()：一个回调函数，当 GraphQL 请求有了返回值之后的下一步操作 请求发送时机前面说了只要向可接受apollo对象的地方传入它就可以完成 GraphQL 的查询与变更，所以我们讨论以下两种请求发送的时机。 组件实例化时这个方案是将apollo对象传入组件中名为apollo的对象中，然后在组件实例化的过程中自动完成 GraphQL 请求，这种方案常用于 query，而且示例也是这样做的，其实你也可以进行 mutation，下面这个例子中有两个apollo对象：books和delBooks，分别进行了 query 和 mutation： template.vue1234567891011121314151617181920212223242526272829import gql from \"graphql-tag\";export default { data: function () { return { books: [], }; }, apollo: { books: gql` query { books { title author } } `, delBooks: { mutation: gql` mutation { id: 1 } `, update(res) { console.log(res); }, }, },}; 在apollo对象中创建一个与data对象属性同名的属性，apollo会自动将获得的数据挂载到data对象。如上面这段代码apollo对象中的books属性，只需要在data中注册就能自动拿到请求的结果。 如果你的apollo对象中只有query或者只需要mutation，就可以像上面books对象中那样写，只需要将 gql 构造出的代码作为属性的值就行了。 TIPS：除了在 js 使用 gql 构造 GraphQL 查询代码，也可以将 GraphQL 查询代码写入.gql文件，在 js 中引用。 手动发送请求你可以使用this.$apollo.mutate()方法来发送 GraphQL 请求，它不会自动调用，所以更加灵活，你可以将它放在方法甚至是生命周期中，完全由你控制，它接受 apollo 对象作为参数，使用起来大概是这样的： template.vue1234567891011121314151617import gql from \"graphql-tag\";export default { methods: { check() { this.$apollo.mutate({ query: gql` query { books { title } } `, }); }, },}; 以上就是我对 vue-apollo 的使用小结，使用和文档完全不同的思路完全是我的个人理解，如果有不同的见解希望大家留言评论。 本文作者：KylinLee 本文链接：https://kylin.dev/2020/07/10/在Vue中使用GraphQL 版权声明：本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2020/07/10/%E5%9C%A8Vue%E4%B8%AD%E4%BD%BF%E7%94%A8GraphQL/"},{"title":"我们把爱情想复杂了","text":"有时候是我们把爱情想复杂了。 有时候是我们把爱情想复杂了。 在一段未知的感情面前，我们表现得过于谨慎。 纠结过很多东西，也在心里计算着自己在感情中的得失。 等我们确认无误转身想接受时，却发现那个人已经离开，去寻找他自己的幸福。 什么是爱情？我也很难说清楚。或许就是你看着对方的眼睛，能让你心跳加速； 能将自己身上那些小秘密，毫无保留的说给她听；不论什么时候，都能在对方的身上找到吸引你的点。","link":"/2020/03/20/%E6%88%91%E4%BB%AC%E6%8A%8A%E7%88%B1%E6%83%85%E6%83%B3%E5%A4%8D%E6%9D%82%E4%BA%86/"},{"title":"我眼中的愚人节","text":"也许因为某些原因，这个愚人节在我眼里和往常并不一样，我觉的有必要记录一下这个特殊时期的愚人节。 写在前面在写这篇文章之前，我搜索了两个问题，一个是在百度百科上搜索了愚人节的由来及习俗，其实相当无聊，可以理解为互相取乐，每个人在这一天都在以最夸张的手法获得最大的快乐。另一个是在知乎上搜索愚人节的意义，我选择了其中一条回答作为了我的答案，一个值得思考的答案。 我身边的愚人节我没有过西方节日的习惯，不会去编一些愚人节的笑话，但是氛围在，还是会听到一些“愚弄别人”的消息。 1.班群头像变了一大早醒来，发现班群头像变了，接着发来一条消息，大概内容是“学院被清华大学合并！”，稀里糊涂的我虽然没意识到今天是愚人节，但我还是相信自己的判断，这是不可能的。 2.暑假没了群里突然出现一条消息，标题写道：”教育部通知：全国一本高校取消暑假“，照西方节日习俗，那我算是今年的愚人了。 3.FreeVOOC这是一个拥有 VOOC 充电技术的手机厂商在愚人节当天推送的新浪微博，称 FreeVOOC 实现了 10m 范围内稳定功率无线充电。 愚人节的意义当我在知乎上寻求答案的时候，看到一句很值得思考的一句话，原话是：”一个节日具有什么意义不重要，重要的是你把它过成什么意义。“，这句话也许正好总结出了我的心里话，这大概就是我为什么觉得今年的愚人节不一样的原因吧。 去年的愚人节去年我在 QQ 空间发了一条博客，希望我们每个人都像愚人节这天一样快乐。 我眼中的愚人节这些”愚弄人“的消息，无非是两种，一种是表达愿景，将这些愿景写进去，在今天就好像实现了一样。一种是不想发生的事，当被人揭穿的时候，才证明这些事并没有发生，也算是给自己一些安慰，一些鼓励吧。在这一天，我听到的各种脑洞大开的事，并非是异想天开，其实是在内心深处，一直无法实现的愿景、一直无法面对的痛楚。 落在最后希望每个人都能像过愚人节这样，不管最终结果，大胆的去想，去做 本文作者：KylinLee 本文链接：https://kylin.dev/2020/04/01/我眼中的愚人节 版权声明：本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2020/04/01/%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84%E6%84%9A%E4%BA%BA%E8%8A%82/"},{"title":"数据结构：树","text":"树（Tree）是一种抽象数据类型或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。这篇文章主要介绍树的相关概念、性质及数学推论。 概念树是由 n（n≥0）个有限结点组成一个具有层次关系的集合，当 n=0 时，称这棵树为空树。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下性质： 每个结点都只有有限个子结点或无子结点 没有父结点的结点称为根结点 每一个非根结点有且只有一个父结点 除了根结点外，每个子结点可以分为多个不相交的子树 树里面没有环路(cycle) 相关术语在学习树的过程中，你可能会遇到以下名词：理解这些词应该优先从树或子树的角度出发。 结点树中的一个独立单元，之前我们说了，树是一个集合，结点就是这个集合中的一个元素。 结点的度结点拥有的子树数称为结点的度。 树的度树的度是树内各结点度的最大值。 叶子（叶子结点）度为 0 的结点称为叶子或终端结点。 非终端结点（分支结点）度不为 0 的结点称为非终端结点或分支结点。除根结点之外，非终端结点也称为内部结点。 双亲（双亲结点）、孩子（孩子结点）结点的子树的根称为该结点的孩子，相应地，该结点称为孩子的双亲。 兄弟（结点）同一个双亲的孩子之间互称兄弟。 祖先（祖先结点）从根到该结点所经分支上的所有结点。 子孙（子孙结点）以某结点为根的子树中的任一结点都称为该结点的子孙。 层次结点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中任一结点的层次等千其双亲结点的层次加 1。 堂兄弟（堂兄弟结点）双亲在同一层的结点互为堂兄弟。 树的深度、树的高度树的深度或高度数值上等于树中结点的最大层次，深度以根结点为 1 向叶子结点递增，高度以叶子结点为 1 向根结点递增。 结点的深度、结点的高度结点的深度或高度数值上等于以该结点为根结点的子树的最大层次，深度以目标结点为 1 向叶子结点递增，高度以叶子结点为 1 向目标结点递增。 有序树和无序树如果将树中结点的各子树看成从左至右是有次序的（即不能互换），则称该树为有序树，否则称为无序树。在有序树中最左边的子树的根称为第一个孩子，最右边的称为最后一个孩子。 森林m (m≥0)棵互不相交的树的集合。 路径两个结点之间经过的结点序列，路径的方向为子结点指向子结点（自上而下）。 路径长度一条路径中经过的边的条数。 n 叉树一棵树中允许结点拥有子树的最大数目，如二叉树允许一个结点最多可拥有两个子树。 形象描述为了便于更形象的理解二叉树，我们可以用图形来表示树，通常用圆形表示一个结点，用线段表示结点之间的关系，下面的图中因为某些限制，结点之间的连接是折线，事实上用直线来连接更好一点，此外，连接是具有方向性的，为父结点指向子结点，你可以使用箭头线段来连接，一棵树看起来是这样的： graph TB; A((1))---B((2)) A---C((3)); B---E((4)) B---F((5)) B---H((6)) C---I((7)) 这棵树有 7 个结点，1 结点的度为 2，2 结点的度为 3，3 结点的度为 1，其他结点（4,5,6,7）的度为 0，这些度为 0 结点被称为叶子结点，其他结点为非终端结点（他们的度不为 0），整棵树的度为 3，深度也为 3。 树的存储结构树的存储可以使用顺序存储或链式存储实现，最通用的方式是使用链式存储。树是一个集合，集合中的元素的关系通过指针指向结点元素来表示，还记得单链表吗，单链表有一个存储数据的区域和一个存储下一元素地址的指针区域，它的指针区域通常只有一个，一个结点最多只能连接一个结点，观察我们绘制的树的形象图就能看出树的一个结点后面能连接多个子结点，树的存储结构核心思想就是这样，但我们有很多种方法来储存一棵树。 双亲表示法孩子表示法孩子兄弟表示法树的相关推论结点拥有的结点数为所有结点的度数+1证明：由结点的度和孩子结点的概念可得，结点的度数=该结点孩子结点的个数 ∵ 除根结点外其余结点都可以作为孩子结点 ∴ 树的结点总数=孩子结点总数+根结点数=所有结点的度数+根结点数=所有结点的度数+1 一棵有 n 个结点的树有 n-1 条边（结点之间的连线）证明：∵ 树中除根结点外每个结点都有一个父结点，即这些结点都有一条线与父结点连接 ∴ 边的数目为结点数减去根结点数 1 度为 m 的树中第 i 层最多有 mi-1个结点（i≥1）证明：若考虑最多的情况，则每一个结点的度都为 m，即每一个结点都有 m 个孩子结点，即第 i 层的每一个结点在第 i+1 层都会产生 m 个孩子结点。 设N(i)为第 i 层的结点数，第 i+1 层结点数可表示为 N(i)×m ∵N(i)的个数为N(i-1)×m，可得 N(i+1)=N(i-1)×m×m 依次进行如上的转化，可得到N(i+1)=N(i-n)×mn+1 即 N(i)=N(i-n)×mn 这是一个通式，知道任意一层结点的个数即可推出其他层结点的个数，最好考虑的是第一层 ∵ N(1)=1 ∴ 将上面的 i-n 化为 1 可得N(i)=N(1)×mi-1 ∴ 度为 m 的树中第 i 层最多有mi-1个结点 代码验证：Golang1234567891011121314151617181920212223242526272829package mainimport ( \"fmt\")/*degree：树的度level：层序数*/func getNodeNum(degree, level int) int { if level != 1 { level-- return getNodeNum(degree, level)*degree } else { return 1 }}func main() { var degree, level int fmt.Printf(\"请输入树的度\\n\") fmt.Scan(&amp;degree) fmt.Printf(\"请输入层序数\\n\") fmt.Scan(&amp;level) nodeNum := getNodeNum(degree, level) fmt.Printf(\"度为%d的树中第%d层最多有%d个结点\\n\", degree, level, nodeNum) main()} 从上面的数学证明过程中你应该就想到了用递归的方式实现，代码也是这样做的，让我们检验一下: Powershell12345678910请输入树的度2请输入层序数9度为 2 的树中第 9 层最多有 256 个结点请输入树的度3请输入层序数4度为 3 的树中第 4 层最多有 27 个结点 根据检验，29-1=256，34-1=27，再次证明度为 m 的树中第 i 层最多有 mi-1个结点。 顺便提一句，当度为 2 时，讨论极限条件，这棵树是满二叉树，根据这个结论可以得出它的性质：第 i 层有 2i-1个结点，这在以后的文章中便不做推导了。 高度为 h 的 m 叉树至多有 (mh-1)÷(m-1)个结点这个推论接着上一条结论继续往下推，高度为 h 实际上是告诉了我们这棵树的层数，考虑至多的极限情况，m 就是上一条结论中的度，实际上证明这个推论只需要将每一层的结点数求和，首先将每一层的结点数构造成等比数列，再按等比求和公式求和： 证明：考虑最多情况，m 叉树的每一个结点都会在下一层产生 m 个结点 设N(h)为第 h 层的结点数，第 h+1 层结点数可表示为 N(h)×m 设数列{ah}，a1=N(1)，a2=N(2)，ah=N(h)，ah+1=N(h+1) (h≥1) 由条件可知a1=N(1)=1 ∵ah+1÷ah=N(h+1)÷N(h)=m，h≥2 根据定义，数列{ah}是以首项为1，公比为m(m&gt;0)的等比数列 设数列{ah}的前n项和为Sh 由求和公式 $$S_n=\\frac{a_1\\times(1-q^n)}{1-q}, (q\\neq1)$$ a1=1，q=m，m≠1，n=h 可得 $$S_n=\\frac{(1-m^h)}{1-m}$$ 具有 n 个结点的满 m 叉树的最小高度为 logm(n(m-1)+1)证明：考虑极限条件，要求得最小高度，就需要将每一层填满，之前我们已经证明了 m 叉树每一层的最大结点数，这其实是上一个结论的逆向问题，同样的先将每一层的结点数构造成数列，转换为数学问题就是已知通项公式，前 h 项和，求 h 的值，这个证明这个结论需要做的就是得出通项公式和前 h 项和，通项公式在证明上一个结论时已经得出，进而可以得出前 h 项的和为 $$S_h=\\frac{(1-m^h)}{1-m}$$ 令 Sh=n 反解出 h $$h=\\log_m{(n(m-1)+1)}$$ 本文作者：KylinLee 本文链接：https://kylin.dev/2020/07/12/数据结构：树 版权声明：本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。 if (window.mermaid) { mermaid.initialize({theme: 'forest'}); }","link":"/2020/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91/"},{"title":"尝试用通俗的方式解释协程","text":"协程（英文：Coroutine）这个概念其实并不复杂，但我却花了很多时间理解，后来仔细一想，大概是因为这个概念穿插了很多别的概念，所以这篇文章将这些概念全部疏通一遍再来理解协程。 除了协程，通过本文你将对进程、线程、并发有一定的了解 维基百科是这么定义的： 协程是计算机程序的一类组件，推广了协作式多任务的子程序，允许执行被挂起与被恢复。相对子例程而言，协程更为一般和灵活，但在实践中使用没有子例程那样广泛。 字我都认识，可连起来是什么意思？这就是本文写作的目的。 进程和线程协程和线程对比起来更容易理解，因为他俩实在太像了。 线程线程（英语：thread）是操作系统能够进行运算调度的最小单位。大部分情况下，它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 那么什么是进程呢？ 进程进程是程序运行的一个实例（字面拆解为正在进行的程序），一个程序是静态的二进制文件，是没有灵魂的，当我们启动程序时就会开启一个进程，这个时候系统开始读取程序的二进制文件，并且向系统申请一些资源。 总结起来进程就是一个程序运行的时候系统环境变量和用到的资源以及本身代码的集合，其特点是每个 CPU 核心任何时间内仅能运行一项进程，即同一时刻执行的进程数不会超过核心数，这对支持更高并发是个阻碍，并且为了解决进程阻塞的问题，操作系统遍引入了更轻量的线程。 进程资源分配的最小单位，线程是操作系统能够进行运算调度的最小单位。可以这么理解：在进程这个大圈子中，存在着各种资源，在没有线程时，这些资源全部由一个可执行代码调配，这有点像单线程进程。当引入线程之后，一个进程下可以有很多线程，相当于一个可执行代码被分成了很多段，这些片段可以单独执行，并且使用所在进程内的资源。 当然，要使一个应用程序完整运行起来就必须要把这些细分的线程全都执行起来，于是便需要时间片轮转。操作系统为每一个线程分配 CPU 执行时间（通常为几百毫秒），当运行这个线程的时间超过分配的执行时间时，系统会强制 CPU 去执行下一个等待的线程（补充一下，线程和进程都是有状态的，这里这个正在”等待“的线程应该是”中断“状态），如此快速的不断切换线程便实现了并发。同时程序运行的时候也只会出现线程阻塞，而不是整个进程阻塞，如此便解决了上面的问题。 并发不知不觉提到了并发，根据上面的描述不难看出，并发是指一段时间内（程序开始运行到结束的这段时间）执行多个程序（线程算是一个进程的子程序）。 协程上面提到，线程是为了解决阻塞和并发的并发问题（在一段时间内执行更多的程序），类似的，协程也是为了在一段时间运行更多的“程序”（应该说是函数）并且可以避免线程阻塞。有了之前的铺垫，类比起来讲协程就很容易了。 线程和协程解决的并发问题不是一个问题，线程是为了让操作系统并发运行程序，以达到”同时“运行更多程序的目的，而协程是为了让一个线程内的程序并发服务更多内容，这里我不太好解释，一个直观的例子就是一个单线程的服务器程序同时服务多个用户，如何做到服务更多用户？想想线程是怎么来的，我们只需要把这个线程中的程序继续细分，然后像时间片轮转一样不断的去执行这些细分的“子程序”。即使一个这样的“子程序”执行发生阻塞，也不会导致整个线程阻塞，在这个“子程序”阻塞的时候切换到其他“子程序”继续服务，既解决了阻塞的问题，也实现了并发。大概理解了吧，协程就是线程中可以交替运行的代码片段。 下面说说真实的协程，线程切换是由操作系统的时间片控制的，而协程是程序自己实现的，让协程不断轮流执行才是实现并发，所以实现协程还必须要有一个类似于时间片的结构，不同于线程的切换，协程的切换不是按照时间来算的，而是按照代码既定分配，就是说代码运行到这一行才启动协程，协程是可以由我们程序员自己操控的。 所以尝试控制这些协程是很有趣的事，一起期待下一篇《JavaScript中的协程》吧！ 本文作者：KylinLee 本文链接：https://kylin.dev/2020/06/13/尝试用通俗的方式解释协程 版权声明：本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2020/06/13/%E5%B0%9D%E8%AF%95%E7%94%A8%E9%80%9A%E4%BF%97%E7%9A%84%E6%96%B9%E5%BC%8F%E8%A7%A3%E9%87%8A%E5%8D%8F%E7%A8%8B/"},{"title":"程序员的PC定制指南","text":"推荐程序员电脑设置方法，不针对操作系统，优秀的程序员从会使用电脑出发。 推荐电脑硬件配置一句话就是，性能超级好的配置，不要以为你仅仅是敲敲代码，其实程序员的电脑要求一点也不输游戏玩家。 12345{ \"内存\": \"16GB\", \"CPU\": \"8代i7标压版\", \"SSD\": \"512G\"} 以上是程序员推荐基础配置，其他配置根据工作不同，需要自行考虑，推荐 16GB 及以上，其实跑两个 IDE 和 Chrome 就没了。CPU 要快，编译打包的时候需要高速运算。另外的要求就是需要支持虚拟化，现在电脑基本支持。 为什么要写这一篇指南 当别人看你电脑的时候就能看出你是个优秀的程序员。 提高开发效率。 保持写代码习惯或者工作习惯。 定制之后让自己用的超级爽，而别人不会用。 定制指南从桌面开始 保持简洁的桌面、开始菜单等，桌面图标太多就像声明了一堆变量，当你要使用变量的时候发现忘了变量名了。 图标分类放，比如在桌面划分区，隐式或者显式的规定，这样就像给变量做注释，提高开发效率。 使用启动器启动器理解起来就是打开应用的地方，比如说双击桌面图标可以启动一个应用，点固定任务栏启动应用，桌面，任务栏就是启动器，这里说的使用启动器当然不仅限于桌面。 让常用应用一触直达，这就是和缓存或者内存一样的，将最常用应用以最容易触发的形式启动（快捷键、固定任务栏等），提高了速度，节省了时间。 不常用应用也要快速启动，前面说到了保持简洁的桌面，那么多余的图标去哪了？你可以将这些图标隐藏起来，或者放在另外一个文件夹，用快捷的启动器打开（此处不懂请评论）。 习惯使用快捷键，快捷键是很好的启动器，比如说截图，打开文件管理器，鼠标不用在屏幕上大幅移动，节约时间。 文件管理 分磁盘管理，如同 C 语言声明变量一样，给磁盘做声明。如图：给磁盘标注，每个磁盘的作用，并且在使用中遵守这些标注，哪个盘放需要快速运行的应用，哪个盘放不用特别快运行的应用，哪个盘存储文件等，便于管理。 文件夹管理，将不同类型的项目放在规定的文件夹。如图：这样做无异于给项目加索引，要找什么类型的项目很轻易就能找到，效率快速上升，当你要给别人展示项目时不至于一直让别人等等，然后疯狂的找。 单独设计一个存放框架的地方。模仿 Maven，在本地创建一个框架、库的代码仓库，一般开源代码代码存放在 GitHub 上面，当我们要使用的时候需要上网查找仓库，再 clone 下来，GitHub 一般在国内比较慢，在创建项目的时候其实就浪费了好多时间，在使用的时候就顺便本地某个统一的地方储存一份，下次直接引用就行了，如果需要使用最新版，拉取一下也比重新 clone 快很多。 程序员应该注意的一点，所有目录，文件名尽量使用英文，一是可以多学几个单词，另外就是保证兼容性。 定制浏览器 使用多个不同的浏览器。如政府网站，老的只兼容 IE，使用多个内核可以解决一些兼容性问题。 为不同浏览器分配不同任务。指的是充分利用浏览器特性，如 Vivaldi 分屏和滤镜适合看开发文档，Firefox Developer Edition 内置出色的调试组件，适用于调试，专门的安全浏览器，适用于浏览需要高度隐私的页面。 聪明的使用浏览器插件，避免内存高占用。Chromium 的浏览器插件都是兼容的，当所有插件都安装在 Chrome 上时会显得特别笨重，在做不同的事的时候其实不是安装的所有插件都需要，而频繁启动或者关闭插件也比较麻烦。这样，我们可以吧这些插件分配到其他 Chromium 的浏览器上，比如 Chrome 专门用来浏览 GitHub，我装上会用到的关于 GitHub 的插件。CentBrowser 专门用来看视频，我就只装和视频有关的插件。这样对内存是很友好的。 密码管理程序员免不了注册一些网站的账号，平时基本上不需要用到，但终究还是有用到的时候，管理密码避免了找回密码的时间浪费。 少使用记事本记录密码，因为是明文，被窃取是很有可能的。 使用密码本软件，大多数可以多端同步，用的时候也很方便。 使用本地轻量级数据库如，这是我比较推荐的方法，既可以保证安全性，也可以顺手练手数据库。 习惯使用命令行 即使你是 Windows 用户也要习惯使用命令行，深入使用之后才懂得为什么建议这样做。 使用文件预览工具 有的时候看一个文件是否是要找的文件，往往需要打开才知道。比如一个文本文件，我需要看是不是我需要的，我需要用编辑器打开它，这样显得慢了，使用文件预览工具，直接预览文本图片等等，速度比打开快很多。 本文作者：KylinLee 本文链接：https://kylin.dev/2020/02/26/程序员的PC定制指南 版权声明：本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2020/02/26/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84PC%E5%AE%9A%E5%88%B6%E6%8C%87%E5%8D%97/"},{"title":"自省-细数那些曾经乐此不疲的事","text":"一个人要成长，深刻的自我反省是离不开的。 本文作者：KylinLee 本文链接：https://kylin.dev/2020/07/16/自省-细数那些曾经乐此不疲的事 版权声明：本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2020/07/16/%E8%87%AA%E7%9C%81-%E7%BB%86%E6%95%B0%E9%82%A3%E4%BA%9B%E6%9B%BE%E7%BB%8F%E4%B9%90%E6%AD%A4%E4%B8%8D%E7%96%B2%E7%9A%84%E4%BA%8B/"},{"title":"开始踩坑GoWeb","text":"这是我第一次使用 GoLang 进行 Web 开发，以前用的是 Koa 和 ThinkPHP 进行 Web 后端的开发，也算是有一些经验吧，这篇文章用来记录开发第一个小时遇到的问题。 如果你是GoLang的初学者，并且使用的第一个外部包是 iris ，那么这篇文章对你相当有帮助。 问：开发前一个小时我们在做什么？答：打造开发环境和 initialize。 开发环境开发环境倒是不用配置，这个在安装 GoLang 的时候就配置好了，只需要提一点就行了，后面会提到。 关于GOPATH它指定软件包源代码所在的目录，$GOPATH 默认采用和 $GOROOT（GO 的安装目录） 一样的值，但从 Go 1.1 版本开始，你必须修改为其它路径。它可以包含多个包含 Go 语言源码文件、包文件和可执行文件的路径，而这些路径下又必须分别包含三个规定的目录：src、pkg 和 bin，这三个目录分别用于存放源码文件、包文件和可执行文件。 初始化项目我使用的是iris，这个 Web 框架，选择这个框架的原因主要参考了Awesome Web Frameworks for Gophers这篇文章，毫无疑问，我认为这将是未来几年最具潜力的框架，在开源 GoWeb 框架中性能是最强的，社区也是最活跃的，学习曲线相对容易。 安装按照官方文档首先使用go-get从 GitHub 上将外部包下载到本地，但在国内的话一般是不成功的。 PowerShell1go get github.com/kataras/iris/v12@latest 所以我通过百度找到了热心网友，网友的帖子上说需要先设置GO111MODULE这个环境变量为on，然后设置代理（为了避免从 GitHub 下载源码网速慢而下载失败），根据你的操作系统执行下面两条命令： MacOS/Linux bash12345# Enable the go modules featureexport GO111MODULE=on# Set the GOPROXY environment variableexport GOPROXY=https://goproxy.io Windows PowerShell12345# Enable the go modules feature$env:GO111MODULE=\"on\"# Set the GOPROXY environment variable$env:GOPROXY=\"https://goproxy.io\" 现在我们写入一段示例代码来测试一下： GoProjectDir/main.go12345678910111213package mainimport ( \"github.com/kataras/iris\")func main() { app := iris.New() app.Handle(\"GET\", \"/welcome\", func(ctx iris.Context) { ctx.HTML(\"&lt;h1&gt;Welcome&lt;/h1&gt;\") }) app.Run(iris.Addr(\":8080\")) //8080 监听端口} 这时候 Goland 报错了，告诉我们无法找到引用的包。 问题在哪？这时候我们会很自然的去看这个包是不是真的下载到本地了，于是我们上去GOPATH目录去找，发现目录下只有pkg文件夹，而没有src源文件文件夹。 output12345678PS F:\\ProjectFiles\\Go&gt; cd $env:gopathPS E:\\Application\\GOPATH&gt; ls Directory: E:\\Application\\GOPATHMode LastWriteTime Length Name---- ------------- ------ ----d---- 2020/5/28 21:35 pkg 产生原因正常情况下，引入一个外部包时会在GOPATH下的src目录进行包的查找，很明显没有这个文件夹是导致错误的直接原因。 为什么会这样呢？ 你可能已经注意到我们之前设置了一个环境变量GO111MODULE=on，安装包的时候默认采用是 GOPATH 的模式（GO 最初的依赖管理系统），就是把包的源码放进src目录，而当我们设置了上面这个环境变量的时候就会使用 GoMod 模式，它使用 Go Module 的方式管理包，可以理解为 Module 是 Go packages 的集合。 如何解决使用了不同的依赖管理系统就要用不同的方式，如果你用过 Node 就很好理解，每个 Node 项目都会有一个package.json，里边描述了项目和依赖的信息。对于 GoMod 而言，每一个 Go 项目需要一个go.mod文件来描述这些信息。接着上面的操作，创建一个go.mod文件： PowerShell1go mod init `你的包名，通常是项目名称` 初始化之后里面还没有依赖，在项目文件夹重新使用go-get安装一下包，因为GOPATH已经有了，所以这次直接建立了引用而不需要下载了。现在重新 run 一下，已经没有问题了。 如果你的 GoLand 仍然提示有错误，在设置中的 GOPATH 配置添加上面设置的环境变量即可。 经验总结 不要随便复制别人的操作，比如说如果没有设置GO111MODULE=on，只设置代理，那么后面的问题都不会出现。 但是还是推荐使用 GoMod 这种依赖管理方式，因为你可以对项目的依赖轻松进行删除，升级，添加等操作。 之所以出现这个问题，另外一个原因是，GoMod 是在 2018 年提出使用的，我看的中文文档版本太老压根没有提到，初来乍到，没有关注行情。 本文作者：KylinLee 本文链接：https://kylin.dev/2020/05/28/开始踩坑GoWeb 版权声明：本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2020/05/28/%E5%BC%80%E5%A7%8B%E8%B8%A9%E5%9D%91GoWeb/"},{"title":"浅谈GraphQL的尴尬","text":"本人某校大二学生，最近忙于数据库课设，其中用到了 GraphQL，碰巧在知乎上看到了GraphQL 为何没有火起来？这个问题，虽然是刚用到 GraphQL，但对于这个问题还是有一点想法，的所以这里就浅浅的聊一下 GraphQL 的尴尬吧。 GraphQL 的好处因为刚开始用上，没有很深入的去研究 GraphQL 的好处，我只能列出在使用过程中发现的一些好处： 弹性 API 查询由前端传来的查询参数，需要哪些内容由由前端决定，可多可少，减少返回数据冗余。直接好处就是对于不同的 C 端（Web、App、小程序等），可能需要展示不同的内容，有的数据需要，有的数据不需要，使用 GraphQL 可以不用改后端代码，定制想要的数据字段。 减少路由RESTful 往往会使用到许多路由，服务器对大量路由的解析会延长响应时间，对于 GraphQL，只需要设置一个路由而不需要大量的路由解析，并且方便 API 的管理。 减少请求次数根据上面所说的，我们只需要一个路由，并且可以自定义需要的数据字段，那么对于一个页面，完全可以只发送一个请求来获取所有数据。 更少的代码这是对于服务端来说的，对于查询同一内容，不需要重新再写一遍，只需要一个 resolver 就行了。 更好的前后端联调在开发前期，只要后端给出 GraphQL 接口或者说 Schema 确定，那么在前端就能够通过 GraphQL PlayGround 很轻松的模拟数据，GraphQL PlayGround 就相当于一份 API 文档。而且因为 GraphQL 严格的类型系统，也直接在开发阶段解决掉了类型不相同的问题。 GraphQL 现状我认为现在 GraphQL 目前处在一种进退两难的局面之中，2015 年 GraphQL 正式发布，到现在仅仅 5 年的时间，在圈子中颇具影响力，也获得了很多的关注，可以算得上是新秀。这势头太强劲，是导致 GraphQL 现在窘境的一个原因，如果它发展的慢一点，人们可以慢慢的接受，和现在是不一样的局面吧。 首先要肯定的是 GraphQL 必定会成为未来的 API 查询语言，所以人们炒的很火，但在短期内无法改变仍然开发 RESTful 的局面，这就是发展太快带来的窘境吧。明明很强，大家也很喜欢，但用的人不多，作为 GraphQL 表示很尴尬啊。 原因一个很现实的问题就是，如果一个公司全部都是使用的 RESTful，现在改为使用 GraphQL，那不是要重写了？这对于一个大公司来说是伤筋动骨的事，搞不好服务崩溃，所以对于这些公司来说，继续使用 RESTful 花销会比改用 GraphQL 低得多，GraphQL 带来的好处远不如这些花销。 有些人认为需要前后端都支持是 GraphQL 没有被大量用起来的一个原因，但我对这个说法是不认可的，有需求就有技术支持，究其原因还是上面说的，有需求但没有必要。 兼容方案为了解决上面这个问题，也有一些兼容性方案。 在课设项目的开发中我使用的是ApolloServer，其中 ApolloServer 提供了两类数据源，一类是 RESTful API 数据源，一类是自定义数据源，RESTful API 数据源允许你不改变 RESTful API 来使用 GraphQL 进行查询，虽然看起来是很友好的，但当你使用 GraphQL 查询的内容令一个 RESTful API 不能完整提供的时候，会带来一些问题，举个简单的例子： RESTful API 请求的字段都是固定的，前后端设定一致，就是说客户端直接请求 RESTful API，返回的数据中冗余很少，而 GraphQL 查询中需要的内容由前端来定，往往一个 GraphQL 查询会伴随着多个 RESTful API 请求，而最终是不需要用到所有数据的，这就出现了数据冗余，浪费了资源。 而如果 RESTful API 请求和 GraphQL 查询的内容完全吻合，那相比于直接使用 RESTful API 请求，使用 GraphQL 查询多了一次请求，这就是鸡肋的存在啊。 所以我认为这种兼容并不是完美的，反而会带来更多的资源消耗，并没有达到让大家迁移到 GraphQL 的目的。 以上就是入门级码农对 GraphQL 尴尬境地的浅显描述。如果大家有什么想法，欢迎留言评论。 本文作者：KylinLee 本文链接：https://kylin.dev/2020/05/30/浅谈GraphQL的尴尬 版权声明：本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2020/05/30/%E6%B5%85%E8%B0%88GraphQL%E7%9A%84%E5%B0%B4%E5%B0%AC/"},{"title":"重新审视个人博客","text":"将博客迁移到 Hexo，让我在这个期间重新想想写博客这件事。 第一篇博客还记得第一次写博客的时候根本没有想过为什么，这样做值不值得，总觉得别人有的，自己没有，感觉少了点什么。所以在 2019 年上半年开始了个人博客，最初是使用 Gridea，上手比较快，第一次提交的时间是 4 月 10 日，到现在已经一年了。既然有了，那就好好写下去吧，也没想过为什么。和 CSDN、博客园上的博客一样，起初是记录一些问题，一些学习总结。我也注意到博客的价值问题，我希望我的博客和别的博客不一样，做一些知识总结只是在网上增添重复的内容，我认为这样是没有太大意义的，我更注重原理的阐述，刚入前端的我不会太深入，但是还是坚持做原理的阐述。 迁移到 Typecho因为博客是通过 GitPage 搭建的，访问速度很慢，那时候正好弄了一台阿里云服务器，所以将博客全部迁移到了 Typecho，每一次迁移都代表着思想的转变，不只是因为访问加快速度，更因为作为一个程序员，也想打造一个自己的平台，希望有一天能形成个人品牌。除了在服务器上搭建博客，还搭建了自己的同步网盘，图床等应用。因为奔着个人宣传去的，我的博客里边开始出现了更多生活的气息，甚至有了为博客加上类似于微博，QQ 空间的微型博文的想法。 重新审视将博客迁移到 Hexo 的这段时间，我考虑了很多，对于现在的我，博客流量几乎都是自己创造的，那博客对于我的意义在于记录每天的成长，这些数据都是我的回忆。所以考虑到高额的维护成本，以及保留更原始的数据，我选择 Hexo，保持博客更新的热情。选择 Github 这个平台更多是因为数据不会丢失。 我们为什么要写个人博客 时至 2020 年，大众都在用微博，用 Facebook 等自媒体，很多这种平台都被娱乐充斥着，也许自己的博客才是那唯一一片净土。 对于一些很有特色的博客，那是打造自己的圈子，打造个人品牌的一个方法。 在 IT 界博客的占比很高，但都是和编程相关的，用来记录自己遇到的问题，解决思路，做知识沉淀。 让博客重新起航吧！ 本文作者：KylinLee 本文链接：https://kylin.dev/2020/04/25/重新审视个人博客 版权声明：本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2020/04/25/%E9%87%8D%E6%96%B0%E5%AE%A1%E8%A7%86%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"title":"简单易懂讲闭包","text":"刚看到了 Rust 语言中利用闭包实现匿名函数，想着博客许久没更新了，那就写一篇帮助大家理解吧。闭包是 JavaScript 的一个特点，搜索引擎搜索闭包基本都会用 JavaScript 做例子，同时闭包也是 JavaScript 初学者较难理解的一个部分。 前置知识作用域规则JavaScript1234567const variable = \"variable\";function readVar() { var innerVariable = \"innerVariable\"; return variable;}console.log(innerVariable); //undefined 这段代码说明的是 JavaScript 的作用域链规则，readVar函数执行时没有在自身作用域内找到variable变量，于是向上层作用域寻找，并使用它。简单来说就是子作用域能使用父作用域的变量，而父作用域不能使用子作用域的变量。 讲清楚什么是闭包一句话闭包保存的是函数和函数运行的必要环境（使用到的变量等），它和作用域类似，但闭包只是包含一部分作用域，它是函数和函数使用的外部变量的集合。 产生闭包在函数创建时就会产生，只要使用函数就存在闭包。 利用闭包按照上面所述，只要有函数就有闭包，但是我们在使用的时候感受不到闭包的存在。要怎么利用闭包呢？ 这个例子已经被用烂了，但是用它来讲闭包也再合适不过了。 JavaScript12345678const countUp = (() =&gt; { let count = 0; return () =&gt; { return ++count; };})();// 每调用一次返回一个比上一次大1的值countUp(); 第 4 行使用了一个父作用域的变量count，可以改变count的值，第 3 行将一个匿名函数返回到countUp外部，相当于创建了一个快照并保存到立即执行函数外部，里边包含了函数内部环境和该函数使用的外部变量count，这样通过闭包就能用countUp函数控制count值。你可以看到，利用闭包可以在函数外部控制函数内部的值。所以，利用闭包的核心是将函数和环境保存到外部变量。 我们都知道，当函数执行完毕，执行上下文离开作用域（这里指函数作用域），作用域会被立即销毁，按照常理来说代码不可能运行起来。但是因为返回了一个闭包，这之后闭包为countUp函数提供环境，这就是为什么上面的例子中立即执行函数执行完之后，通过countUp访问到的count是之前的状态。 所以，在使用闭包的时候你需要清楚的一点是，闭包会造成内存泄漏，如果你返回了一个函数作为闭包，只要返回的函数存在，这个闭包就一直存在，会占用内存。 说点其他的这里我们利用《Understanding ECMAScript 6》块级绑定中的一个例子 典型错误JavaScript123456789var funcs = [];for (var i = 0; i &lt; 10; i++) { funcs.push(function () { console.log(i); });}funcs.forEach(function (func) { func(); // 输出 10 共10次}); 在第 3 行，console.log()使用了变量i，它的闭包中除了本身，还应该保存有变量i，这个闭包被保存到了funcs[i]，但你要注意到，变量i是用var声明的，它在函数作用域中，i存在的作用域只有 window 一个，在循环中虽然产生了 10 个闭包，但他们都保存着同一个i，当循环执行完，i = 10，所以最后从闭包中取到的i也全都是 10。 解决思路上面提到了，因为变量i存在的作用域只有一个，而一个作用域中只能有一个i，要使i值不一样，就需要创建不同的作用域，解决方法有两个。 方法一：使用块级作用域只需要把var声明改为let声明即可 JavaScript123456789var funcs = [];for (let i = 0; i &lt; 10; i++) { funcs.push(function () { console.log(i); });}funcs.forEach(function (func) { func(); // 输出 0，1，2 ... 9}); 在 for 循环初始化的时候使用进行 let 声明,这时变量的作用域是局部块作用域，每进入一次循环都会重新创建一个i变量。所以每次循环产生的闭包中的i都来自不同的作用域，而且每个作用域中的i都是随循环变化的，最终达成目的输出 0~9。 这时候不妨回去检验一下（已经头晕请跳过）我们将i变量和funcs变量放在同级作用域下，代码如下： JavaScript12345678910var funcs = [];let i;for (i = 0; i &lt; 10; i++) { funcs.push(function () { console.log(i); });}funcs.forEach(function (func) { func(); // 输出 10 共10次}); 我不是故意把你弄晕的，这样就能再次证明导致 bug 的根本原因是 10 个闭包使用同一个作用域的变量。 方法二：创建函数作用域这种方法的思路是创建函数内部的i变量，根据作用域链规则，当函数内部存在i变量时，就会屏蔽掉上层的i变量，通过函数返回闭包，这样闭包内的i变量就来自于函数，而不是函数上层的i变量。每个函数都会生成独一无二的作用域，根据上面的结论，同样能解决问题。 JavaScript12345678910111213var funcs = [];for (var i = 0; i &lt; 10; i++) { funcs.push( (function (value) { return function () { console.log(value); }; })(i) );}funcs.forEach(function (func) { func(); // 输出 0，1，2 ... 9}); 本文作者：KylinLee 本文链接：https://kylin.dev/2020/05/03/简单易懂讲闭包 版权声明：本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2020/05/03/%E7%AE%80%E5%8D%95%E6%98%93%E6%87%82%E8%AE%B2%E9%97%AD%E5%8C%85/"},{"title":"记一次服务器配置经历","text":"开始的时候是做前端，会 Linux 基本命令，第一次用 PHP 开发后端，代码本身很简单，但是让代码跑起来很难。本地测试时用 Windows 的 wampserver 不用怎么配置，但是到了 Linux 服务器就。。。配置起来有点复杂，问题也很多。 运行环境lnmp (Linux+Nginx+Mysql+PHP)详细信息：Debian 8.9nginx 1.10.5mysql 5.6php php-fpm7.2 常用命令Bash123456789101112#检查nginx配置是否合法nginx -t#重新加载nginx配置nginx -s reload#查看端口是否开启，保证下面三个端口开启lsof -i:3306 #mysql默认端口lsof -i:9000 #php服务端口lsof -i:80 #http服务端口#查看进程ps aux | grep 进程名称#关闭进程kill 进程号 配置要点 修改防火墙保证能访问到 3306 端口（需要远程连接数据库时开启） 修改 my.cnf 文件的bind-address=0.0.0.0:*,保证外域所有 ip 能够访问 修改时区为北京时间 修改 nginx 配置，site_available/default文件或者site_available/域名文件的root字段更改为网站起始目录。取消注释location ~ \\.php{}代码块，取消注释里面的include字段，取消注释fastcgi_pass字段，并将值改为127.0.0.1:9000，最后用nginx -t验证配置文件是否有错误，用nginx -s reload来重新加载配置文件。 修改 php-fpm 安装目录下的*.d/www.conf文件，将listen的值改为127.0.0.1:9000,配置完之后最好重启 nginx 和 php-fpm。 最后用端口扫描工具测试一下 80、3306 这两个端口是否开启。 本文作者：KylinLee 本文链接：https://kylin.dev/2019/12/11/记一次服务器配置经历 版权声明：本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2019/12/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E7%BB%8F%E5%8E%86/"},{"title":"输入法增强","text":"输入法 14 键，17 键，18 键增强显示。 14 键，17 键，18 键，看起来是不是很神秘，很多朋友问我用了什么输入法，其实并不是用了什么神奇的输入法，科技以换壳为本，只需要换个皮肤就行了。 准备工具 百度输入法/讯飞输入法/搜狗输入法/IOS 内置输入法 公众号“森林集” 开始干活 进入公众号“森林集”，点击“皮肤商城”，打开了新世界的大门，上面的皮肤基本上是标注付费的，但是不要着急购买，有很多一元皮肤是可以用优惠券兑换的。 用优惠券获取皮肤下载链接 以百度输入法为例，下载皮肤以后，将皮肤复制进手机起始目录的 baidu/ime/skins/目录下，进入百度输入法超级皮肤，查看本地皮肤，下载的皮肤已经在里面了。 PS：如果是 14 键，17 键，18 键的皮肤，需要切换输入法为拼音九键才能有效果。 本文作者：KylinLee 本文链接：https://kylin.dev/2019/06/20/输入法增强 版权声明：本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2019/06/20/%E8%BE%93%E5%85%A5%E6%B3%95%E5%A2%9E%E5%BC%BA/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"GraphQL","slug":"GraphQL","link":"/tags/GraphQL/"},{"name":"Other","slug":"Other","link":"/tags/Other/"},{"name":"Recommend","slug":"Recommend","link":"/tags/Recommend/"},{"name":"Concept","slug":"Concept","link":"/tags/Concept/"},{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"Essay","slug":"Essay","link":"/tags/Essay/"},{"name":"Application","slug":"Application","link":"/tags/Application/"},{"name":"Weekly","slug":"Weekly","link":"/tags/Weekly/"},{"name":"HTML&#x2F;CSS","slug":"HTML-CSS","link":"/tags/HTML-CSS/"},{"name":"Love","slug":"Love","link":"/tags/Love/"},{"name":"DataStructure","slug":"DataStructure","link":"/tags/DataStructure/"},{"name":"GoLang","slug":"GoLang","link":"/tags/GoLang/"}],"categories":[{"name":"Code","slug":"Code","link":"/categories/Code/"},{"name":"Life","slug":"Life","link":"/categories/Life/"},{"name":"Frontend","slug":"Code/Frontend","link":"/categories/Code/Frontend/"},{"name":"Backend","slug":"Code/Backend","link":"/categories/Code/Backend/"},{"name":"Game","slug":"Life/Game","link":"/categories/Life/Game/"},{"name":"Tool","slug":"Tool","link":"/categories/Tool/"},{"name":"Music","slug":"Life/Music","link":"/categories/Life/Music/"},{"name":"Love","slug":"Life/Love","link":"/categories/Life/Love/"}]}