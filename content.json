{"pages":[{"title":"关于","text":"这个博客也是几经折腾才成为现在这个模样，从Gridea到Typecho到现在的Hexo，每一次改变都是思想的进化，而最终选择 Hexo 是因为打算一直更新这个博客，并且保留原始的数据。因为自己没有那么多精力去维护服务器，目前也没有那么多资源维持下去。 何许人也南有乔木，北有相思。爱上北方女孩的南方人。 README.MD每个人都有那么几种爱好，我呢，谈不上爱好，也谈不上不喜欢，也许就是一个爱好生活的人，基本上所有的事情都愿意去尝试一番，这也是大一进步很慢的原因之一了，大一学过 C、写过算法、学了前端、搞过 Python，也做过 Java，PS 花了一个寒假搞了点名堂，玩过 Arduino，曾经热爱刷机，电脑多系统。所有的都想尝试一番，大一就这么玩过去了，现在想起来，如果专心学一样，也不至于这么差劲，但我也不后悔，至少磕磕绊绊让我知道了自己适合的，也懂得了不少其他方面的知识。 现在呢，因为微软的不断开源，成为了微软的死忠粉，希望能和志同道合的人交流。","link":"/about/index.html"}],"posts":[{"title":"HTML5元素拖拽原理实现","text":"拖拽功能常见于一些模板生成网站，比如 H5 制作网站，我以前都没有注意这一方面，因为功能需要，特地去了解了一下元素拖拽 API。 两种效果：常见的拖拽有两种效果，一种是拖拽到某个区域后放开自动补位，一种是拖动到任意位置。两种效果实现原理是不一样的。 第一种效果原理：先看看用到的 drag 事件的API： dataTransfer：The data that underlies a drag-and-drop operation, known as the drag data store. Protected mode.（机器翻译：作为拖放操作的基础的数据，称为拖放数据存储区.保护模式）【参考】。 target：被拖动元素下方的元素，常作为放置区域元素。 实现原理其实是将被拖拽的元素插入到放置区域元素的节点下，需要用到appendChild。 因为放置区域可能不止一个，所以用drag事件的target方法获取放置区域元素。 而同样的被拖拽的元素可能也不止一个，所以用drag事件的dataTransfer方法传递该元素的 id 或者指向唯一节点元素的值。 注意： 在放置到区域的时候（ondrop）和元素拖拽结束的时候（ondragover）要阻止放置区域元素的默认事件，方法是preventDefault()。 第二种效果原理：涉及到的 drag 事件API： screenX：鼠标相对于屏幕的 X 坐标 screenY：鼠标相对于屏幕的 Y 坐标 clientX：鼠标指针相对于 DOM 的 Y 坐标 clientY：鼠标指针相对于 DOM 的 Y 坐标 实现原理其实也很简单，即记录拖拽过程中的坐标差值，将元素的本身位置坐标加上这个差值。 实现只横向移动，例如滑块验证，只需记录 X 坐标，同理也可以实现竖向滑动。 本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2019/12/26/HTML5%E5%85%83%E7%B4%A0%E6%8B%96%E6%8B%BD%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0/"},{"title":"JavaScrip实现计数器的多种方法","text":"总结一下 JavaScript 实现计数器的几种方法，对于写出高性能代码有一定的帮助，同时也包含一些蛇皮操作。 普通写法JavaScript12345var counter = 0;function countUp() { return ++counter;}countUp(); 创建一个全局变量counter，每次调用countUp()都会使counter的值＋ 1，但是我们都知道无论是用何种语言写代码，都应该尽量使用少的全局变量，于是就有了下面这种经典写法。 使用闭包JavaScript1234567const countUp = (() =&gt; { let count = 0; return () =&gt; { return ++count; };})();countUp(); 这种写法能使用更少的全局变量，但闭包终归有闭包的缺点，它不会被垃圾回收机制处理，同时也不能像上一种写法那样重置counter，于是就有了下面这种写法。 使用函数属性JavaScript12345const countUp = () =&gt; { return countUp.count++;};countUp.counter = 1;countUp(); 在 JavaScript 中函数是一种特殊的对象，既然是对象，那他自然也有属性，我们定义一个函数来操作它的counter属性。这种写法很好的解决了上面三个问题： 解决闭包的内存占用 可以重置counter 尽量少的全局变量 如果你会TypeScript，那么通过下面这个例子你能更好的理解函数属性。 JavaScript1234interface CountUp { (): number; counter: number;} 上面这段代码定义了一个函数接口，这个函数拥有 0 个参数，返回值是一个number类型的值，并且有counter属性。 让我们看看最后一种写法，这种写法没有任何优势，甚至是大材小用的写法。 GeneratorJavaScript1234567891011const counter = (function* Counter() { let count = 0; while (true) { count++; yield console.log(count); }})();function countUp() { return counter.next();} 在这里，我们使用了一个无限迭代器来实现，通过使用counter.next()来手动使迭代器迭代，个人认为这种写法比使用闭包的开销还要大，用作计数器实在是大材小用了。迭代器在 ES6 之前就被实现了，在 ES6 中才正式成为规范，它在 JavaScript 的作用通常是用来构建异步函数（async/await）。 虽然最后这种写法没有什么实质性的作用，但对于理解迭代器还是有帮助的，另外，有些厂笔试就喜欢出这种花里胡哨的题。 本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2020/05/08/JavaScrip%E5%AE%9E%E7%8E%B0%E8%AE%A1%E6%95%B0%E5%99%A8%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E6%B3%95/"},{"title":"FirstStrike!","text":"FirstStrike，是一款以核打击为题材的单机游戏，中文名：先发制人。 这是一个很早以前就开始玩的游戏，因为打游戏不上瘾，经常都不会玩一次，所以我的很多游戏都是还没打完就卸载了的，昨天心血来潮重新开始玩这款游戏，真的是非常好的一款游戏，我这样不太爱玩游戏的人都会时常回来玩两局，以前是没有中文版的，所以国内知道的比较少，现在 Google play 上下载的最新版支持中文了，对国人更友好，索性今天写个简单的介绍，将这款游戏推荐给大家。 简单的做个属性介绍： 外文名：First Strike中文名：先发制人游戏类别：战争策略平台：Android iOS厂商：blindflugstudios 游戏玩法：在游戏中，你将扮演一个拥有核打击能力国家的政府首脑，通过战略（研究武器，建立外交，核打击）等征服其他国家，成为世界上唯一的超级大国，同时你也需要保护自己的国家免受核打击。 游戏截图：中文支持这款游戏是非常容易上手的，官方的支持中文一并连 Guide 都支持了 控制面板游戏控制的主体是一个地球，点击你的领土会弹出炫酷的 3D 控制面板 广播每次核打击都会有这样的提示 核打击全面核打击 武器超级核武器 为什么推荐它的意义在战略游戏中获胜往往能给我们带来成就感，尤其是你扮演着一个超级大国的时候，但在这个游戏中获胜时你不会有这种感觉。 如果你玩过PLAGUE INC.(瘟疫公司)，再玩这款游戏的时候，你会和玩瘟疫公司时有同样的感慨：“这简直就是毁灭人类的节奏啊！”。 你真的赢了吗？你毁灭了多少个国家和地区？你让多少人成为了受害者？你释放了多少当量？ 我喜欢这个游戏不仅仅是因为它好玩，而是在于它和别的游戏出发点不同，每一款游戏都是一个作品，但不是所有作品都是有灵魂的，当你玩一个游戏的时候，你仔细想想，这个游戏真正的意义在哪。在 FirstStrike 中你能很清楚的明白创造它的人想告诉我们什么。 制作精良无论是操作，还是整体风格，都是满满的科技感，细节处理也很到位，比如一个地区受到核打击后是不能立即建立防御体系和核武器库的，在细微之处演绎核武器带来的危害。 其他推荐FirstStrike:FinalHour目前 FirstStrike 仅支持 Android 和 iOS 平台，如果你想在电脑上玩，可以尝试FirstStrike:FinalHour，这是 FirstStrike 的制作团队的续作（和 FirstStrike 差别不大），现已登录 steam，FirstStrike:FinalHour 也支持移动版。 Stellar CommandersFirstStrike 团队新近发布的Stellar Commanders，可以理解为 FirstStrike 的联机版本，可以和小伙伴们一起玩。 本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2020/05/17/FirstStrike/"},{"title":"Button设计基本规则（译）","text":"对于前端来说，Button 元素是很常用的，虽然说 Button 的设计不是前端工程师的事，但是自己做网站可能会用到，最近看到一篇 Button 设计规则的文章觉得写的挺好，推荐给大家。 原文地址：https://uxplanet.org/7-basic-rules-for-button-design-63dcdf5676b4 为了方便阅读，将文章转成了中文并且做了一些修改（涉及侵权请联系，我将及时删掉） 让 Button 看起来更像按钮 在与用户界面进行交互时，用户需要立即知道什么是“可点击”而哪些不是。设计中的每个 UI 都需要用户解码。通常，用户解码 UI 所需的时间越多，对它们的可用性就越小。 但是，用户如何理解某个元素是否具有交互性？他们使用以前的经验和视觉指示符来解码 UI 的含义。这就是为什么使用适当的视觉指示符（如大小，形状，颜色，阴影等）使元素看起来像一个按钮这么重要。 对于移动用户来说，不太明显的提示一个更重要的问题。在尝试了解单个元素是否具有交互性时，桌面用户可以在元素上移动光标并检查光标是否更改其状态。移动用户没有这样的机会。要了解元素是否具有交互性，用户必须点击它，而没有其他方法可以检查交互性。 不要认为您的 UI 中的某些内容对您的用户来说是显而易见的 在许多情况下，设计者故意不将按钮识别为交互元素，因为他们认为交互元素对用户来说是显而易见的。在设计界面时，您应始终牢记以下规则： 12你对UI的理解能力不代表用户的理解能力，也许只有你知道自己UI设计的含义。 使用熟悉的 Button 样式 以下是大多数用户熟悉的按钮示例： 带方形边框的填充按钮 带圆角的填充按钮 带阴影的填充按钮 Ghost Button（只具备线条边框，不填充颜色的透明按钮） 在所有这些示例中，“带阴影的填充按钮”设计对用户来说是最清晰的。当用户看到对象的维度时，他们立即知道这是他们可以按的东西。 不要忘记空白 不仅按钮本身的视觉属性很重要。按钮附近的空白量使用户更容易（或更难）理解它是否是交互元素。在该示例中，下面的一些用户可能会将 Ghost Button 与信息框混淆。 将 Button 放在正确的位置 按钮应位于用户可以轻松找到或希望看到的位置。不要让用户寻找按钮。如果用户找不到按钮，他们就不会知道它存在。 尽可能使用传统布局和标准 UI 模式 按钮的常规放置提高了可发现性。使用标准布局，用户将很容易理解每一个元素的用途—— 即使它是一个没有强烈指示符的按钮。将标准布局与干净的视觉设计和充足的空白相结合，使布局更容易理解。 在页面中使用提示，当用户首次导航到包含您希望他们采取的某些操作的页面时，应该提示用户找到不同的按钮按钮。 标记 Button 以提示他们在干什么 带有通用或误导性标签的按钮可能会给您的用户带来不好的感受。编写按钮标签，清楚地解释每个按钮的作用。理想情况下，按钮的标签应清楚地描述其动作。 用户应该清楚地了解点击按钮时会发生什么。让我举个简单的例子。想象一下，您不小心触发了删除操作，现在您看到以下错误消息。 目前尚不清楚“OK”和“取消”在此对话框中的含义。大多数用户会问自己“当我点击’取消’时会发生什么？” 所以不要使用“确定”来标记，最好使用“删除”。这将清楚地显示此按钮对用户的作用。此外，如果“删除”是一个潜在的危险操作，您可以使用红色来表明这一操作。 调整按钮为合适的大小 按钮大小应反映此元素在屏幕上的优先级。大按钮意味着更重要的动作。 优先按钮 让最重要的按钮看起来像是最重要的按钮。始终尝试使主要操作按钮更加突出。增加尺寸（通过使按钮更大，使其对用户来说更重要）并使用对比色来吸引用户注意力。 使按钮对移动用户来说更友好 在许多移动应用中，按钮太小。这通常会导致用户输入错误的情况。 麻省理工学院触摸实验室的研究发现，指垫的平均值在 10-14mm 之间，指尖的平均值为 8-10mm。这使得 10mm x 10mm 具有良好的最小触摸目标尺寸。 按照顺序 按钮的顺序应反映用户与系统之间的对话性质。问问自己，用户期望在这个屏幕上有什么样的订单并进行相应的设计。 1用户界面是与用户的对话 例如，如何在分页中订购“上一个/下一个”按钮？合理的是，向前移动的按钮应位于右侧，向后移动的按钮应位于左侧。 避免使用过多按钮 这是许多应用和网站的常见问题。当您提供太多选项时，您的用户可能不知道究竟该点击哪个。在您的应用或网站中设计网页时，请考虑您希望用户采取的最重要的操作。 提供音效和视效反馈 当用户单击或点击按钮时，他们希望用户界面将以适当的反馈进行响应。根据操作类型，这可能是视觉或音频反馈。当用户没有任何反馈时，他们可能会认为系统没有收到命令并会重复操作。这种行为经常导致多次不必要的操作。 为什么会这样？作为人类，我们希望在与对象交互后获得一些反馈。它可能是视觉，音频或触觉反馈——任何承认交互已注册的事实。 对于某些操作，例如下载，不仅要确认用户输入，还要显示进程的当前状态。 结论 尽管按钮是交互设计的普通元素，但值得注意的是要使这个元素尽可能易于使用。按钮用户体验设计应始终与识别和清晰度相关。","link":"/2019/08/18/Button%E8%AE%BE%E8%AE%A1%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99%EF%BC%88%E8%AF%91%EF%BC%89/"},{"title":"JavaScript快速拷贝数组的几种方法","text":"本文总结快速拷贝数组的几种方法（个人认为总结都很无聊），文章旨(chun)在(shu)总(wu)结(liao)，对于日常编码，只需挑选一种写法即可，通过本文，你将对 JavaScript 数组方法及 ES6 有更多的了解。 为了不重复写代码，所有例子都是以下面这个环境为基础。 JavaScript1const exampleArr = [1, 2, 3]; 循环还是写一些基础的for循环吧 JavaScript12345let length = exampleArr.length;const newArr = [];for (let i = 0; i &lt; length; i++) { newArr.push(exampleArr[i]);} 使用forEach() JavaScript1234const newArr = [];exampleArr.forEach((value) =&gt; { newArr.push(value);}); 如果面试官问你如何拷贝一个数组，你只会for循环，那估计你是凉凉了。 Array.prototype.map()map()方法建一个新数组，其结果是该数组中的每个元素都调用一次提供的函数后的返回值。这种方法和forEach()相差无几，都是通过回调函数来为新数组赋值。 JavaScript1const newArr = exampleArr.map((value) =&gt; value); Array.prototype.filter()filter()方法返回一个回调函数过滤后的新数组，他有一个回调函数和指向当前数组的this（可选参数）作为参数，回调函数的参数和forEach()及map()方法相同，当回调函数返回true时则将当前处理元素放进新数组。 JavaScript1const newArr = exampleArr.filter((i) =&gt; true); Array.prototype.concat()concat()方法用于合并两个或多个数组，并返回一个新数组，参数可以是 0 个或多个数组。当有 0 个参数的时候显然会返回一个拷贝数组： JavaScript1const newArr = exampleArr.concat(); Array.prototype.slice()slice()方法实现了数组的浅拷贝，就是说当拷贝数组里的对象时只会保留引用。它有两个可选索引参数，由于确定从何处开始拷贝，何处停止拷贝，如果省略参数即拷贝整个数组。 JavaScript1const newArr = exampleArr.slice(); 还有一个和slice()方法类似的copyWithin()方法，他们都是浅拷贝，但copyWithin()浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度。说的不是很明白？举个例子： JavaScript12const array1 = [\"a\", \"b\", \"c\", \"d\", \"e\"];array1.copyWithin(0, 3, 4); 它的第一个参数是开始替换的索引位置，后面两个可选参数分别表示从何处开始复制，在何处结束复制，如果省略即复制整个数组。上面这个例子表示复制索引[3,4)的值(左闭右开)，然后将每个值从第 0 个索引开始覆写。最终值将是[“d”,”b”,”c”,”d”,”e”]。 所以下面这种写法并不是拷贝数组，因为它的拷贝值都赋值给自身了，newArr仅仅是保留了引用。 JavaScript1const newArr = exampleArr.copyWithin(0); 数组解构+剩余参数JavaScript1const [...newArr] = exampleArr; 数组解构是 ES6 中的语法，通过数组解构可以将数组的值保存到解构对应的变量中，当不想一一赋值的时候可以使用剩余参数，将所有剩余的值保存在一个数组中，上面这段代码就是这种做法，将所有的值保存在newArr中。注意是剩余参数，而不是扩展运算，二者很像，他们的区别在下一篇文章中讨论，欢迎关注。 本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2020/05/09/JavaScript%E5%BF%AB%E9%80%9F%E6%8B%B7%E8%B4%9D%E6%95%B0%E7%BB%84%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"},{"title":"ThinkPHP5安装","text":"ThinkPHP 是一款开源的 PHP 框架 问题描述 安装时查看《ThinkPHP5.0 完全开发手册》-&gt; 基础 -&gt; 安装 ThinkPHP 采用 Git 安装https://github.com/top-think/thinkhttps://github.com/top-think/framework 执行下载完所有文件之后启动服务器，访问http://localhost/tp5/public/ 很显然下载的文件中没有 tp5 的文件夹 此时只需将下载的项目文件夹改为 tp5 就行了 默认读取 public 目录下的 index.php 文件 但是将得到两条错误信息，大致意思是说 public/index.php 文件的第 17 行有错误，并且提示缺少文件 仔细打开文件查看是require __DIR__ . '/../thinkphp/start.php';这行代码 显而易见，下载的项目中并没有这个 thinkphp 在这个文件夹 于是查看 GitHub 上的 README.md 文件，文件说明上标明了有这个文件夹 经过查找，在简书上看到一篇文章，解决了这个问题 解决方法 在之前我将项目目录改成了 tp5 之后将 framework 文件夹重命名为 thinkphp 再次访问http://localhost/tp5/public/，问题已解决 其实最简单的方法就是在 git clone 的时候重命名文件夹了 Bash12git clone https://github.com/top-think/think tp5git clone https://github.com/top-think/framework thinkphp 本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2019/09/26/ThinkPHP5%E5%AE%89%E8%A3%85/"},{"title":"Travelling，下一站去哪？","text":"Travelling是一个随机友链的工具，此博客于 2020 年 2 月 9 日加入 Travelling，同时也希望更多的朋友能加入。 什么是 TravellingTraveling 的本质是网站随机重定向，根据随机得出的结果以及与博客的对应关系，重定向到对应的个人博客链接。当你访问Travelling时，你会被重定向到一个 Travelling 收录的网站，每一个 Travelling 收录的网站都能够继续访问Travelling，这样便完成了接力，不知不觉的走遍了收录的所有个人博客。 Travelling 带来了什么增加流量根据 GitHub 上 Travelling 的作者介绍，Travelling 可以用来增加个人博客的流量。 开往能增加我网站的流量吗？当然。不恰当的估算下：假设当前有 2 个网站加入了开往，每个网站有 10 人使用开往，那么每个网站似乎就增加了 10×2×1/2=10 的流量；如果有 10 个网站加入开往是不是还是平均下来增加 10 人的流量呢？显然不是，因为： 访客可通过开往多次友链接力； 有开往的网站多了，单站击量也会提高； 这样我们再算算，10 个网站加入了开往，接力次数提升到 3，每个网站有 15 人使用开往，那每个网站就增加了 15×10×3/10=45 的流量。 这也是为什么建议将开往的徽标放在您网站明显位置（推荐顶栏，侧栏）的原因，以便让友链一直接力下去，获得更多的流量。 同时增加博客的曝光度。 发现大千世界除了给自己的网站增加流量，提高曝光度，你还可以通过 Travelling 去发现更多的有趣的博客，很多时候我们想去看看更多博客，却无从选择，那就让 Travelling 帮我们选择吧。 说点别的谈谈 Traveling 的设计，和介绍一样，他还太小，很多功能都不完善，这样的设计很简单，现在的 Travelling 就像一个大容器，所有东西不加区分全部都在这个容器里边，管理起来很不方便。而且要拿取里面的东西，只能往这里边拿，当 Traveling 庞大起来，这样的设计缺陷就会很明显。 对 Travelling 的期望个人更倾向于分布式的设计，将不同类别的博客放进不同的小容器，对这些博客加以区分，使用的时候带上标记，这样可以很大概率找到喜欢的博客。此外，除了统一收录，每个博客也应该有一些自己的“朋友圈”，用 Travelling 去寻找每一个网站的“朋友圈”也是一件有趣的事情。Travelling 的潜力还是很大的，希望 Travelling 能越走越远 本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2020/04/09/Travelling%EF%BC%8C%E4%B8%8B%E4%B8%80%E7%AB%99%E5%8E%BB%E5%93%AA%EF%BC%9F/"},{"title":"Vue-CLI优雅的解决跨域问题","text":"跨域问题一直是前端上线调试的一个坑，在 webpack 时代，我们需要开启一种更好的跨域调试方式。 什么是跨域问题这是浏览器的一种安全机制，同源策略，即浏览器不能执行其他网站的脚本。说的比较笼统，可以理解为浏览器只允许网站和同一域名的服务器通过xhr传输数据。注意是xhr请求，通常点一个链接或者使用 JS 跳转页面是不会有跨域问题的。 解决方法解决方法是很多的，细数的话有 5 种以上。 公司解决跨域问题的常见方法 一般都是后端允许跨域即后端在响应头加上Access-Control-Allow-Origin:*，这是一劳永逸的方法，可以在测试期间允许跨域，项目部署好之后再禁止跨域。 利用 Vue 调试服务器优雅的解决首先要明确为什么推荐这样使用 大家都知道 Vue 是数据驱动，离开了数据 Vue 基本上不能呈现想要的页面。 所以在 Vue 调试的时候都是需要连接后端的。 如果部署到 API 服务器，首先 Vue 通过 webpack 打包，然后上传到服务器，这样的确可以解决跨域问题，但是流程复杂，而且在多个人开发一个项目的时候不能协同开发。 Vue-CLI 初始化项目正好自带了开发服务器，不用再安装别的软件或者模块，操作简单。 解决方法笼统的来说是通过反向代理，前端开发者可能对于这些不太了解，但是我们知道怎么做就行了。 在调试的时候打开 devServer，npm run serve或者npm run dev，看具体配置。 这时会启动一个localhost服务器，具体端口看配置文件，通常是localhost:8080。 这时需要配置配置文件了，让这个 devServer 进行代理，因为服务器是没有同源策略限制的。 配置文件关于代理部分的配置. vue.config.js 中的 devServer.proxy 选项来配置。 devServer.proxy 可以是一个指向开发环境 API 服务器的字符串： vue.config.js12345module.exports = { devServer: { proxy: \"http://imakerlab.cn\" }}; 这会告诉 devServer 将任何未知请求 (没有匹配到静态文件的请求) 代理到http://imakerlab.cn如果你想要更多的代理控制行为，也可以使用一个 path: options成对的对象。完整的选项可以查阅http-proxy-middleware vue.config.js1234567891011121314module.exports = { devServer: { proxy: { \"/api\": { target: \"http://imakerlab.cn/api\", ws: true, changeOrigin: true }, \"/foo\": { target: \"http://imakerlab.cn/foo\" } } }}; 其实这个 devSever 就是webpack-dev-server，所以vue.config.js的devServer参数完全可以按照webpack-dev-server配置。 开发实例比如说：将/api开头的 API 转到http://imakerlab.cn vue.config.js12345678module.exports = { //... devServer: { proxy: { \"/user\": { target: \"http://imakerlab.cn\" } } }}; 这样，当我们链接写/user/2333的时候，就会访问http://imakerlab.cn/user/2333，而不是localhost:8080/user/2333。这样浏览器表面访问的是localhost，但实际访问的是imakerlab.cn，很好的解决了跨域问题。当然，开发服务器同样支持 url 重写，仔细去看看官方文档吧！ 本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2020/02/21/Vue-CLI%E4%BC%98%E9%9B%85%E7%9A%84%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"},{"title":"Windows上的包管理器","text":"Linux 的软件包管理器，如 apt、yum、dnf、pkg，极大的方便了 Linux 软件的安装，在 Windows 上大家都习惯使用可执行安装文件安装软件，但其实在 Windows 上也有软件包管理器，习惯使用之后会在一定程度上方便软件的管理。 Chocolatey 软件包管理器官网地址：https://chocolatey.org/ 初步讲解 Chocolatey 的安装安装1.电脑以管理员身份运行 cmd 或者 PowerShell如果使用的是 cmd，运行命令@&quot;%SystemRoot%\\System32\\WindowsPowerShell\\v1.0\\powershell.exe&quot; -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command &quot;iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))&quot; &amp;&amp; SET &quot;PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin&quot;如果使用的是 PowerShell，先运行Get-ExecutionPolicy。如果返回Restricted，则运行Set-ExecutionPolicy AllSigned或Set-ExecutionPolicy Bypass -Scope Process。之后运行命令Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))没有出现error，最后使用choco命令或者choco -?命令验证是否安装成功，如安装不成功请查阅官方文档。 本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2019/10/25/Windows%E4%B8%8A%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/"},{"title":"Windows上值得一荐的应用（19年7月）","text":"Windows 上 PDF 编辑器、浏览器推荐。 PDF 阅读&amp;编辑PDF Element 优点：可以作为 Office 套件的插件，也是一款独立的软件，界面和 Office 相统一。 缺点：免费版本导出为 PDF 后会有水印。 Adobe Acrobat Reader 优点：PDF 格式是由 Adobe 提出的，没有人比自己更了解自己。 缺点：订阅式付费算吗？ Able Word 优点：界面和 Office2003 相统一，一看见就会觉得是老朋友，非常顺手，重点是免费，无水印。 缺点：最新版本是 2015 年的，网站没有关停，但是貌似已经停更了，各位可以坐等诈尸。打开大文件时性能不佳，但是自己写 PDF 文件还是很快的。 还有一个不知道算不算缺点，因为是国外软件，界面是英文，介意的不用折腾了，不过初中的英语水平应该够了。 还有很多优秀的 PDF 编辑软件，比如XXX，等等…（之前还用过一些，记性不好 😂），除此之外还有很多 PDF 工具网站，不久之后再做分享。浏览器Chrome&amp;CentBrowser 优点：开发者专用，二者差不多，都可以使用谷歌账号同步，只是 CenrBrowser 添加了手势等，用起来更方便。 缺点：占用内存大一直是个问题。 Vivaldi 优点：极富创新性的浏览器，可以自定义标签的位置，网页滤镜，显示加载进度，标签随网页变色，3D 旋转网页，自定义主题，窗口分栏显示，同时显示手机浏览器窗口等功能，当然，同样可以安装 Chrome 插件，如果想体验新的东西，绝对是最好的选择。 缺点：Windows 体验不佳，推荐 Linux 或者 X OS 上面体验 BraveBrowser 这是个有故事的浏览器，创始人之一是 JavaScript 之父。这个浏览器同样是 chromium 的核，自带强力广告过滤，当然，因为这个会有很多网站进不去，也因此速度比 Chrome 快两倍，在手机上面比 Chrome 和 Safari 最多快 8 倍。 EpicBrowser * 专注安全的浏览器，内置 VPN，当然，不是国人理解的那种。如果有什么相关的推荐，或者文章有错的地方，欢迎大家评论 本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2019/07/27/Windows%E4%B8%8A%E5%80%BC%E5%BE%97%E4%B8%80%E8%8D%90%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%8819%E5%B9%B47%E6%9C%88%EF%BC%89/"},{"title":"Windows上值得一荐的应用（19年8月）","text":"Windows 上媒体播放器、下载管理器推荐。 媒体播放器Dopamine 优点：优秀的音乐播放器，界面非常美观，支持音效，联机获取歌词，音乐动效。 缺点：国内安装包下载慢。 PotPlayer 优秀到不想多说，设置太复杂。各位自行体验好吗。 爱奇艺万能播放器 推荐下载 UWP 版，主要优点就是能直接播放百度云链接。 下载管理器Thunder 说英文高级点，不多说。 IDM 也不多说，很强大。 FDM 全名 Free Download Manager，免费，自定义最大线程数 10000，支持普通链接、磁力、种子下载。 Motrix 最近被吹的很火的一个下载器，支持普通链接、磁力、种子下载，但是实际效果并不太好，很多时候会莫名无法下载，但是界面很漂亮，还是推荐一下。 BitTornado 专门下载种子的下载器，图形界面几乎没有，没有多余的设置，下载速度超快。 本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2019/08/20/Windows%E4%B8%8A%E5%80%BC%E5%BE%97%E4%B8%80%E8%8D%90%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%8819%E5%B9%B48%E6%9C%88%EF%BC%89/"},{"title":"jQuery链式操作实现原理","text":"jQuery 是一个快速，小巧，功能丰富的 JavaScript 库。jQuery 的一个特点就是链式操作。本文粗略讲解其原理。 相信大家对链式 jQuery 的链式操作并不陌生，在这里简单的介绍一下链式操作的实现思路（用原生 JS 实现链式操作）。 首先我们观察一下 jQuery 的基本语法 1$(selector).action(); 基本语法由选择器和执行函数组成，jQuery 选择器返回的是一个自建对象（Object），jQuery 函数的方法是属于这个对象的，也就是说这些方法只能由这个对象来调用，所以实现链式操作只需要在执行一个函数后返回对象就行了。 示例如下： JavaScript12345678910var obj = { sayName: function (name) { comsole.log(\"i am \" + name); return this; }, action: function (action) { comsole.log(\"i am \" + action); return this; }}; 这里的return this返回了一个对象，通过obj.sayName(&quot;jQuery&quot;).actoin(&quot;chaining&quot;)就可以实现连续调用函数了。 其实并非是 jQuery 中才有这种链式操作，原生 js 中同样有的，比如有很多字符串和数组的方法都会返回字符串或者数组（字符串通过包装类返回字符串对象并拥有方法），例如反序输出字符串： 12var str=\"Wellcome\"；str.split('').reverse().join('') 综上所述，在一个方法中返回一个 Object 类型的值就能实现类似 jQuery 的链式操作。 本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2019/06/03/jQuery%E9%93%BE%E5%BC%8F%E6%93%8D%E4%BD%9C%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},{"title":"你永远有做不完的事","text":"这篇文章出自美国作家理查德·卡尔森 Richard·Carlson的笔下，偶然读到，思绪万千，颇有感受。 你永远有做不完的事Richard·Carlson 许多人过日子的方式，好像有一个秘密目标，非要把一切事情都做完不可。我们熬夜、早起、不敢放纵逸乐，让我们所爱的人一直等下去。可悲的是，太多人就是因为让他们所爱的人等太久，最后对方终于放弃了这段感情。以前，我就这个样子。我们通常会说服自己，忙得不可开交只是暂时的，一旦做完了该做的事，我们就能平静放松下来，并且心情愉快。事实上，这样的境界永远不会到来，因为旧的事情刚做完，新的立刻接踵而至。 “待办清单”只意味着你有一些事情尚待处理，并不表示你得全部做完。人永远都有没打完的电话、未结束的计划、未完成的工作。事实上，我们可以说，一张写得满满的待办清单才是成功的要素，因为这代表你的时间很宝贵。 不过，不论你是什么大人物，或者在做什么大事，记住，没有什么事比你和你所爱的人的幸福和内心安宁更重要。如果你一直执著于完成所有事情，那永远不会有幸福的感觉！其实，几乎所有的事情都是可以等的，我们的工作中真正属于“紧急”的事少之又少。只要你专心一意地工作，事情都会及时完成的。 我发现，如果我（经常）提醒自己，人生的目的并非完成所有事情，而是去享受生命旅途上的每一步，过着充满爱的生活，我就不太会有执著于非得完成所有事情不可的念头。记住，在你离开人世的那一天，还是会留下未完的事需要别人代劳，而且也一定会有人来代劳的！别浪费了生命的每一分每一秒，再做无谓的惋惜。 对错，选择生活还是被生活这也许就是每个人的选择吧，无所谓选择取决于你，我们往往会选择前者，因为它是理想的，但也常常会不自觉的走入后者。我们常常感觉被困在生活之中，有很多事你以为你无从选择，但那只是你内心告诉你的。 我的意思也并不是劝人一味的享受受生活，和作者的观点相同，没必要所有事都自己做，在这种没必要的情况下，请别人代劳可能是一种明智的选择。 最典型的例子大概就是“子欲养而亲不待”了吧，别再“等我忙完的时候在回来看您”，因为你永远有做不完的事。 如果你有任何想法，欢迎在下方评论区留言。 本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2020/03/07/%E4%BD%A0%E6%B0%B8%E8%BF%9C%E6%9C%89%E5%81%9A%E4%B8%8D%E5%AE%8C%E7%9A%84%E4%BA%8B/"},{"title":"前端周报（第一期）","text":"由创新实验室前端组的成员共同完成，每周分享前端经典文章等内容，来源于 GitHub、CSDN、微信公共号、掘金、知乎等平台。 又一个框架来了！被称为要取代 React , vue ，Aangular ！ Excel.js-Node 环境下操作 Excel 文件 前端初级新人，如何撕去菜鸟标签 SheetJS-在浏览器中操作 Excel 文件 ES6 中 export、export default、import 的理解 深入理解 JavaScript 的设计模式 HTML 标签伪元素绑定事件的三种方式 ES6，ES7，ES8，ES9，ES10 新特性一览 ​ 不容错过的 13 个 JavaScript 实用技巧！ GitHub 推出新特性：展示附件文件所有者 Vue 入门","link":"/2019/10/28/%E5%89%8D%E7%AB%AF%E5%91%A8%E6%8A%A5%EF%BC%88%E7%AC%AC%E4%B8%80%E6%9C%9F%EF%BC%89/"},{"title":"响应式设计中设备分辨率的问题","text":"可能有这么一个疑问，为什么在网页中宽度小于 500px 左右就被认定为手机，但手机屏幕宽度明明是 1080px 啊，本篇文章帮你解答这个疑惑。 问题描述在响应式设计中，为了适配移动端，会设置媒体查询，如当媒体查询屏幕尺寸小于某个值的时候应用移动端样式，但是我们一般将这个值设置为 500px 左右或者更小，为什么不是手机的屏幕尺寸呢？如果设置为手机尺寸，为什么不会应用设定好的移动端样式呢？ 进入正文这中间有一个很重要的概念：逻辑分辨率 逻辑分辨率逻辑分辨率的概念应该和物理分辨率区分开物理分辨率是指设备能控制显示的最小物理单位，意指显示器上一个个的点。从屏幕在工厂生产出的那天起，它上面设备像素点就固定不变了，和屏幕尺寸大小有关，单位 pt。而逻辑分辨率可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用的虚拟像素(比如: css 像素)，这个点是没有固定大小的，越小越清晰，然后由相关系统转换为物理像素。简单地说，逻辑分辨率是我们肉眼感知的实际尺寸。应该注意：CSS 中使用的是逻辑分辨率而不是物理分辨率 逻辑分辨率的转化物理分辨率 = 逻辑分辨率 × 设备像素比在 iphone3gs 的时候，逻辑分辨率是 320×480，物理分辨率也是 320×480iphone4 出了之后，逻辑分辨率和 3gs 一样是 320×480，显示的内容是一样多的，但是物理分辨率变成了 640×960，原来在 3gs 的一个像素内容，在 iphone4 上则填充了 4 个像素，因此虽然内容显示还是一样多，但是 iphone4s 的屏幕精细度比 3gs 高了 2 倍。这个 2 倍就是设备像素比。 通过 JavaScript 来验证window.screen.width ，window.screen.height 为设备的逻辑宽高window.devicePixelRatio 为设备像素比验证一下： 本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2020/03/08/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%AD%E8%AE%BE%E5%A4%87%E5%88%86%E8%BE%A8%E7%8E%87%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"在Hexo上分享歌曲","text":"一款大名鼎鼎的 JS 插件，在 Hexo 上也能听歌了！ 这是一款叫做aplayer.js的开源插件，通过简单的配置就能在页面中插入美观的音乐播放控件，插件地址。一起来看一看效果吧！ 本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2020/05/09/%E5%9C%A8Hexo%E4%B8%8A%E5%88%86%E4%BA%AB%E6%AD%8C%E6%9B%B2/"},{"title":"我们把爱情想复杂了","text":"有时候是我们把爱情想复杂了。 有时候是我们把爱情想复杂了。 在一段未知的感情面前，我们表现得过于谨慎。 纠结过很多东西，也在心里计算着自己在感情中的得失。 等我们确认无误转身想接受时，却发现那个人已经离开，去寻找他自己的幸福。 什么是爱情？我也很难说清楚。或许就是你看着对方的眼睛，能让你心跳加速； 能将自己身上那些小秘密，毫无保留的说给她听；不论什么时候，都能在对方的身上找到吸引你的点。","link":"/2020/03/20/%E6%88%91%E4%BB%AC%E6%8A%8A%E7%88%B1%E6%83%85%E6%83%B3%E5%A4%8D%E6%9D%82%E4%BA%86/"},{"title":"简单易懂讲闭包","text":"刚看到了 Rust 语言中利用闭包实现匿名函数，想着博客许久没更新了，那就写一篇帮助大家理解吧。闭包是 JavaScript 的一个特点，搜索引擎搜索闭包基本都会用 JavaScript 做例子，同时闭包也是 JavaScript 初学者较难理解的一个部分。 前置知识作用域规则JavaScript1234567const variable = \"variable\";function readVar() { var innerVariable = \"innerVariable\"; return variable;}console.log(innerVariable); //undefined 这段代码说明的是 JavaScript 的作用域链规则，readVar函数执行时没有在自身作用域内找到variable变量，于是向上层作用域寻找，并使用它。简单来说就是子作用域能使用父作用域的变量，而父作用域不能使用子作用域的变量。 讲清楚什么是闭包一句话闭包保存的是函数和函数运行的必要环境（使用到的变量等），它和作用域类似，但闭包只是包含一部分作用域，它是函数和函数使用的外部变量的集合。 产生闭包在函数创建时就会产生，只要使用函数就存在闭包。 利用闭包按照上面所述，只要有函数就有闭包，但是我们在使用的时候感受不到闭包的存在。要怎么利用闭包呢？ 这个例子已经被用烂了，但是用它来讲闭包也再合适不过了。 JavaScript12345678const countUp = (() =&gt; { let count = 0; return () =&gt; { return ++count; };})();// 每调用一次返回一个比上一次大1的值countUp(); 第 4 行使用了一个父作用域的变量count，可以改变count的值，第 3 行将一个匿名函数返回到countUp外部，相当于创建了一个快照并保存到立即执行函数外部，里边包含了函数内部环境和该函数使用的外部变量count，这样通过闭包就能用countUp函数控制count值。你可以看到，利用闭包可以在函数外部控制函数内部的值。所以，利用闭包的核心是将函数和环境保存到外部变量。 我们都知道，当函数执行完毕，执行上下文离开作用域（这里指函数作用域），作用域会被立即销毁，按照常理来说代码不可能运行起来。但是因为返回了一个闭包，这之后闭包为countUp函数提供环境，这就是为什么上面的例子中立即执行函数执行完之后，通过countUp访问到的count是之前的状态。 所以，在使用闭包的时候你需要清楚的一点是，闭包会造成内存泄漏，如果你返回了一个函数作为闭包，只要返回的函数存在，这个闭包就一直存在，会占用内存。 说点其他的这里我们利用《Understanding ECMAScript 6》块级绑定中的一个例子 典型错误JavaScript123456789var funcs = [];for (var i = 0; i &lt; 10; i++) { funcs.push(function () { console.log(i); });}funcs.forEach(function (func) { func(); // 输出 10 共10次}); 在第 3 行，console.log()使用了变量i，它的闭包中除了本身，还应该保存有变量i，这个闭包被保存到了funcs[i]，但你要注意到，变量i是用var声明的，它在函数作用域中，i存在的作用域只有 window 一个，在循环中虽然产生了 10 个闭包，但他们都保存着同一个i，当循环执行完，i = 10，所以最后从闭包中取到的i也全都是 10。 解决思路上面提到了，因为变量i存在的作用域只有一个，而一个作用域中只能有一个i，要使i值不一样，就需要创建不同的作用域，解决方法有两个。 方法一：使用块级作用域只需要把var声明改为let声明即可 JavaScript123456789var funcs = [];for (let i = 0; i &lt; 10; i++) { funcs.push(function () { console.log(i); });}funcs.forEach(function (func) { func(); // 输出 0，1，2 ... 9}); 在 for 循环初始化的时候使用进行 let 声明,这时变量的作用域是局部块作用域，每进入一次循环都会重新创建一个i变量。所以每次循环产生的闭包中的i都来自不同的作用域，而且每个作用域中的i都是随循环变化的，最终达成目的输出 0~9。 这时候不妨回去检验一下（已经头晕请跳过）我们将i变量和funcs变量放在同级作用域下，代码如下： JavaScript12345678910var funcs = [];let i;for (i = 0; i &lt; 10; i++) { funcs.push(function () { console.log(i); });}funcs.forEach(function (func) { func(); // 输出 10 共10次}); 我不是故意把你弄晕的，这样就能再次证明导致 bug 的根本原因是 10 个闭包使用同一个作用域的变量。 方法二：创建函数作用域这种方法的思路是创建函数内部的i变量，根据作用域链规则，当函数内部存在i变量时，就会屏蔽掉上层的i变量，通过函数返回闭包，这样闭包内的i变量就来自于函数，而不是函数上层的i变量。每个函数都会生成独一无二的作用域，根据上面的结论，同样能解决问题。 JavaScript12345678910111213var funcs = [];for (var i = 0; i &lt; 10; i++) { funcs.push( (function (value) { return function () { console.log(value); }; })(i) );}funcs.forEach(function (func) { func(); // 输出 0，1，2 ... 9}); 本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2020/05/03/%E7%AE%80%E5%8D%95%E6%98%93%E6%87%82%E8%AE%B2%E9%97%AD%E5%8C%85/"},{"title":"我眼中的愚人节","text":"也许因为某些原因，这个愚人节在我眼里和往常并不一样，我觉的有必要记录一下这个特殊时期的愚人节。 写在前面在写这篇文章之前，我搜索了两个问题，一个是在百度百科上搜索了愚人节的由来及习俗，其实相当无聊，可以理解为互相取乐，每个人在这一天都在以最夸张的手法获得最大的快乐。另一个是在知乎上搜索愚人节的意义，我选择了其中一条回答作为了我的答案，一个值得思考的答案。 我身边的愚人节我没有过西方节日的习惯，不会去编一些愚人节的笑话，但是氛围在，还是会听到一些“愚弄别人”的消息。 1.班群头像变了一大早醒来，发现班群头像变了，接着发来一条消息，大概内容是“学院被清华大学合并！”，稀里糊涂的我虽然没意识到今天是愚人节，但我还是相信自己的判断，这是不可能的。 2.暑假没了群里突然出现一条消息，标题写道：”教育部通知：全国一本高校取消暑假“，照西方节日习俗，那我算是今年的愚人了。 3.FreeVOOC这是一个拥有 VOOC 充电技术的手机厂商在愚人节当天推送的新浪微博，称 FreeVOOC 实现了 10m 范围内稳定功率无线充电。 愚人节的意义当我在知乎上寻求答案的时候，看到一句很值得思考的一句话，原话是：”一个节日具有什么意义不重要，重要的是你把它过成什么意义。“，这句话也许正好总结出了我的心里话，这大概就是我为什么觉得今年的愚人节不一样的原因吧。 去年的愚人节去年我在 QQ 空间发了一条博客，希望我们每个人都像愚人节这天一样快乐。 我眼中的愚人节这些”愚弄人“的消息，无非是两种，一种是表达愿景，将这些愿景写进去，在今天就好像实现了一样。一种是不想发生的事，当被人揭穿的时候，才证明这些事并没有发生，也算是给自己一些安慰，一些鼓励吧。在这一天，我听到的各种脑洞大开的事，并非是异想天开，其实是在内心深处，一直无法实现的愿景、一直无法面对的痛楚。 落在最后希望每个人都能像过愚人节这样，不管最终结果，大胆的去想，去做 本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2020/04/01/%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84%E6%84%9A%E4%BA%BA%E8%8A%82/"},{"title":"程序员的PC定制指南","text":"推荐程序员电脑设置方法，不针对操作系统，优秀的程序员从会使用电脑出发。 推荐电脑硬件配置一句话就是，性能超级好的配置，不要以为你仅仅是敲敲代码，其实程序员的电脑要求一点也不输游戏玩家。 12345{ \"内存\": \"16GB\", \"CPU\": \"8代i7标压版\", \"SSD\": \"512G\"} 以上是程序员推荐基础配置，其他配置根据工作不同，需要自行考虑，推荐 16GB 及以上，其实跑两个 IDE 和 Chrome 就没了。CPU 要快，编译打包的时候需要高速运算。另外的要求就是需要支持虚拟化，现在电脑基本支持。 为什么要写这一篇指南 当别人看你电脑的时候就能看出你是个优秀的程序员。 提高开发效率。 保持写代码习惯或者工作习惯。 定制之后让自己用的超级爽，而别人不会用。 定制指南从桌面开始 保持简洁的桌面、开始菜单等，桌面图标太多就像声明了一堆变量，当你要使用变量的时候发现忘了变量名了。 图标分类放，比如在桌面划分区，隐式或者显式的规定，这样就像给变量做注释，提高开发效率。 使用启动器启动器理解起来就是打开应用的地方，比如说双击桌面图标可以启动一个应用，点固定任务栏启动应用，桌面，任务栏就是启动器，这里说的使用启动器当然不仅限于桌面。 让常用应用一触直达，这就是和缓存或者内存一样的，将最常用应用以最容易触发的形式启动（快捷键、固定任务栏等），提高了速度，节省了时间。 不常用应用也要快速启动，前面说到了保持简洁的桌面，那么多余的图标去哪了？你可以将这些图标隐藏起来，或者放在另外一个文件夹，用快捷的启动器打开（此处不懂请评论）。 习惯使用快捷键，快捷键是很好的启动器，比如说截图，打开文件管理器，鼠标不用在屏幕上大幅移动，节约时间。 文件管理 分磁盘管理，如同 C 语言声明变量一样，给磁盘做声明。如图：给磁盘标注，每个磁盘的作用，并且在使用中遵守这些标注，哪个盘放需要快速运行的应用，哪个盘放不用特别快运行的应用，哪个盘存储文件等，便于管理。 文件夹管理，将不同类型的项目放在规定的文件夹。如图：这样做无异于给项目加索引，要找什么类型的项目很轻易就能找到，效率快速上升，当你要给别人展示项目时不至于一直让别人等等，然后疯狂的找。 单独设计一个存放框架的地方。模仿 Maven，在本地创建一个框架、库的代码仓库，一般开源代码代码存放在 GitHub 上面，当我们要使用的时候需要上网查找仓库，再 clone 下来，GitHub 一般在国内比较慢，在创建项目的时候其实就浪费了好多时间，在使用的时候就顺便本地某个统一的地方储存一份，下次直接引用就行了，如果需要使用最新版，拉取一下也比重新 clone 快很多。 程序员应该注意的一点，所有目录，文件名尽量使用英文，一是可以多学几个单词，另外就是保证兼容性。 定制浏览器 使用多个不同的浏览器。如政府网站，老的只兼容 IE，使用多个内核可以解决一些兼容性问题。 为不同浏览器分配不同任务。指的是充分利用浏览器特性，如 Vivaldi 分屏和滤镜适合看开发文档，Firefox Developer Edition 内置出色的调试组件，适用于调试，专门的安全浏览器，适用于浏览需要高度隐私的页面。 聪明的使用浏览器插件，避免内存高占用。Chromium 的浏览器插件都是兼容的，当所有插件都安装在 Chrome 上时会显得特别笨重，在做不同的事的时候其实不是安装的所有插件都需要，而频繁启动或者关闭插件也比较麻烦。这样，我们可以吧这些插件分配到其他 Chromium 的浏览器上，比如 Chrome 专门用来浏览 GitHub，我装上会用到的关于 GitHub 的插件。CentBrowser 专门用来看视频，我就只装和视频有关的插件。这样对内存是很友好的。 密码管理程序员免不了注册一些网站的账号，平时基本上不需要用到，但终究还是有用到的时候，管理密码避免了找回密码的时间浪费。 少使用记事本记录密码，因为是明文，被窃取是很有可能的。 使用密码本软件，大多数可以多端同步，用的时候也很方便。 使用本地轻量级数据库如，这是我比较推荐的方法，既可以保证安全性，也可以顺手练手数据库。 习惯使用命令行 即使你是 Windows 用户也要习惯使用命令行，深入使用之后才懂得为什么建议这样做。 使用文件预览工具 有的时候看一个文件是否是要找的文件，往往需要打开才知道。比如一个文本文件，我需要看是不是我需要的，我需要用编辑器打开它，这样显得慢了，使用文件预览工具，直接预览文本图片等等，速度比打开快很多。 本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2020/02/26/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84PC%E5%AE%9A%E5%88%B6%E6%8C%87%E5%8D%97/"},{"title":"输入法增强","text":"输入法 14 键，17 键，18 键增强显示。 14 键，17 键，18 键，看起来是不是很神秘，很多朋友问我用了什么输入法，其实并不是用了什么神奇的输入法，科技以换壳为本，只需要换个皮肤就行了。 准备工具 百度输入法/讯飞输入法/搜狗输入法/IOS 内置输入法 公众号“森林集” 开始干活 进入公众号“森林集”，点击“皮肤商城”，打开了新世界的大门，上面的皮肤基本上是标注付费的，但是不要着急购买，有很多一元皮肤是可以用优惠券兑换的。 用优惠券获取皮肤下载链接 以百度输入法为例，下载皮肤以后，将皮肤复制进手机起始目录的 baidu/ime/skins/目录下，进入百度输入法超级皮肤，查看本地皮肤，下载的皮肤已经在里面了。 PS：如果是 14 键，17 键，18 键的皮肤，需要切换输入法为拼音九键才能有效果。 本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2019/06/20/%E8%BE%93%E5%85%A5%E6%B3%95%E5%A2%9E%E5%BC%BA/"},{"title":"记一次服务器配置经历","text":"开始的时候是做前端，会 Linux 基本命令，第一次用 PHP 开发后端，代码本身很简单，但是让代码跑起来很难。本地测试时用 Windows 的 wampserver 不用怎么配置，但是到了 Linux 服务器就。。。配置起来有点复杂，问题也很多。 运行环境lnmp (Linux+Nginx+Mysql+PHP)详细信息：Debian 8.9nginx 1.10.5mysql 5.6php php-fpm7.2 常用命令Bash123456789101112#检查nginx配置是否合法nginx -t#重新加载nginx配置nginx -s reload#查看端口是否开启，保证下面三个端口开启lsof -i:3306 #mysql默认端口lsof -i:9000 #php服务端口lsof -i:80 #http服务端口#查看进程ps aux | grep 进程名称#关闭进程kill 进程号 配置要点 修改防火墙保证能访问到 3306 端口（需要远程连接数据库时开启） 修改 my.cnf 文件的bind-address=0.0.0.0:*,保证外域所有 ip 能够访问 修改时区为北京时间 修改 nginx 配置，site_available/default文件或者site_available/域名文件的root字段更改为网站起始目录。取消注释location ~ \\.php{}代码块，取消注释里面的include字段，取消注释fastcgi_pass字段，并将值改为127.0.0.1:9000，最后用nginx -t验证配置文件是否有错误，用nginx -s reload来重新加载配置文件。 修改 php-fpm 安装目录下的*.d/www.conf文件，将listen的值改为127.0.0.1:9000,配置完之后最好重启 nginx 和 php-fpm。 最后用端口扫描工具测试一下 80、3306 这两个端口是否开启。 本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2019/12/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E7%BB%8F%E5%8E%86/"},{"title":"重新审视个人博客","text":"将博客迁移到 Hexo，让我在这个期间重新想想写博客这件事。 第一篇博客还记得第一次写博客的时候根本没有想过为什么，这样做值不值得，总觉得别人有的，自己没有，感觉少了点什么。所以在 2019 年上半年开始了个人博客，最初是使用 Gridea，上手比较快，第一次提交的时间是 4 月 10 日，到现在已经一年了。既然有了，那就好好写下去吧，也没想过为什么。和 CSDN、博客园上的博客一样，起初是记录一些问题，一些学习总结。我也注意到博客的价值问题，我希望我的博客和别的博客不一样，做一些知识总结只是在网上增添重复的内容，我认为这样是没有太大意义的，我更注重原理的阐述，刚入前端的我不会太深入，但是还是坚持做原理的阐述。 迁移到 Typecho因为博客是通过 GitPage 搭建的，访问速度很慢，那时候正好弄了一台阿里云服务器，所以将博客全部迁移到了 Typecho，每一次迁移都代表着思想的转变，不只是因为访问加快速度，更因为作为一个程序员，也想打造一个自己的平台，希望有一天能形成个人品牌。除了在服务器上搭建博客，还搭建了自己的同步网盘，图床等应用。因为奔着个人宣传去的，我的博客里边开始出现了更多生活的气息，甚至有了为博客加上类似于微博，QQ 空间的微型博文的想法。 重新审视将博客迁移到 Hexo 的这段时间，我考虑了很多，对于现在的我，博客流量几乎都是自己创造的，那博客对于我的意义在于记录每天的成长，这些数据都是我的回忆。所以考虑到高额的维护成本，以及保留更原始的数据，我选择 Hexo，保持博客更新的热情。选择 Github 这个平台更多是因为数据不会丢失。 我们为什么要写个人博客 时至 2020 年，大众都在用微博，用 Facebook 等自媒体，很多这种平台都被娱乐充斥着，也许自己的博客才是那唯一一片净土。 对于一些很有特色的博客，那是打造自己的圈子，打造个人品牌的一个方法。 在 IT 界博客的占比很高，但都是和编程相关的，用来记录自己遇到的问题，解决思路，做知识沉淀。 让博客重新起航吧！ 本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。","link":"/2020/04/25/%E9%87%8D%E6%96%B0%E5%AE%A1%E8%A7%86%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Recommend","slug":"Recommend","link":"/tags/Recommend/"},{"name":"Other","slug":"Other","link":"/tags/Other/"},{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"Life","slug":"Life","link":"/tags/Life/"},{"name":"Application","slug":"Application","link":"/tags/Application/"},{"name":"Weekly","slug":"Weekly","link":"/tags/Weekly/"},{"name":"HTML&#x2F;CSS","slug":"HTML-CSS","link":"/tags/HTML-CSS/"},{"name":"Love","slug":"Love","link":"/tags/Love/"}],"categories":[{"name":"Code","slug":"Code","link":"/categories/Code/"},{"name":"Life","slug":"Life","link":"/categories/Life/"},{"name":"Game","slug":"Life/Game","link":"/categories/Life/Game/"},{"name":"Tool","slug":"Tool","link":"/categories/Tool/"},{"name":"Music","slug":"Life/Music","link":"/categories/Life/Music/"},{"name":"Love","slug":"Life/Love","link":"/categories/Life/Love/"}]}