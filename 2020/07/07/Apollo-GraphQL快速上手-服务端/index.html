<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Apollo-GraphQL快速上手-服务端 - 蝶恋花-等风也等你</title><meta description="上次课程设计做完之后就放松了一阵子，过了这么久才来更新博客其实内心是不好受的，感觉生活缺少了什么。GraphQL 出现了很多年，一直不温不火，想尝试 GraphQL 服务器开发的朋友们可以参考一下本文，你将理解到一种 GraphQL 服务器的通用逻辑。   本文假设你对GraphQL有一定的了解。"><meta property="og:type" content="blog"><meta property="og:title" content="Apollo-GraphQL快速上手-服务端"><meta property="og:url" content="https://kylin.dev/2020/07/07/Apollo-GraphQL%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E6%9C%8D%E5%8A%A1%E7%AB%AF/"><meta property="og:site_name" content="蝶恋花-等风也等你"><meta property="og:description" content="上次课程设计做完之后就放松了一阵子，过了这么久才来更新博客其实内心是不好受的，感觉生活缺少了什么。GraphQL 出现了很多年，一直不温不火，想尝试 GraphQL 服务器开发的朋友们可以参考一下本文，你将理解到一种 GraphQL 服务器的通用逻辑。   本文假设你对GraphQL有一定的了解。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://i.loli.net/2020/07/07/6jbzi9kqFVEJWB3.png"><meta property="og:image" content="https://i.loli.net/2020/07/09/TLayrYwQmhIBKp6.png"><meta property="article:published_time" content="2020-07-07T10:06:26.000Z"><meta property="article:modified_time" content="2020-07-11T02:56:44.962Z"><meta property="article:author" content="KylinLee"><meta property="article:tag" content="JavaScript"><meta property="article:tag" content="GraphQL"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://i.loli.net/2020/07/07/6jbzi9kqFVEJWB3.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://kylin.dev/2020/07/07/Apollo-GraphQL%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E6%9C%8D%E5%8A%A1%E7%AB%AF/"},"headline":"蝶恋花-等风也等你","image":["https://i.loli.net/2020/07/07/6jbzi9kqFVEJWB3.png","https://i.loli.net/2020/07/09/TLayrYwQmhIBKp6.png"],"datePublished":"2020-07-07T10:06:26.000Z","dateModified":"2020-07-11T02:56:44.962Z","author":{"@type":"Person","name":"KylinLee"},"description":"上次课程设计做完之后就放松了一阵子，过了这么久才来更新博客其实内心是不好受的，感觉生活缺少了什么。GraphQL 出现了很多年，一直不温不火，想尝试 GraphQL 服务器开发的朋友们可以参考一下本文，你将理解到一种 GraphQL 服务器的通用逻辑。   本文假设你对GraphQL有一定的了解。"}</script><link rel="canonical" href="https://kylin.dev/2020/07/07/Apollo-GraphQL%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E6%9C%8D%E5%8A%A1%E7%AB%AF/"><link rel="alternative" href="/atom.xml" title="蝶恋花-等风也等你" type="application/atom+xml"><link rel="icon" href="https://i.loli.net/2020/04/25/iIF2oqRkzYEAhx1.png"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?4c6e2bf3c9db9fa9b7809e5e794dfc53";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://i.loli.net/2020/04/25/iIF2oqRkzYEAhx1.png" alt="蝶恋花-等风也等你" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="View on GitHub" href="https://github.com/KylinLee/KylinLee.github.io"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-07-07T10:06:26.000Z" title="2020-07-07T10:06:26.000Z">2020-07-07</time><span class="level-item"> KylinLee </span><span class="level-item"><a class="link-muted" href="/categories/Code/">Code</a></span><span class="level-item">24 分钟 读完 (大约 3594 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Apollo-GraphQL快速上手-服务端</h1><div class="content"><p>上次课程设计做完之后就放松了一阵子，过了这么久才来更新博客其实内心是不好受的，感觉生活缺少了什么。GraphQL 出现了很多年，一直不温不火，想尝试 GraphQL 服务器开发的朋友们可以参考一下本文，你将理解到一种 GraphQL 服务器的通用逻辑。</p>
<div class="message message-immersive is-warning">
<div class="message-body">
<p>本文假设你对GraphQL有一定的了解。</p>
</div>
</div>

<a id="more"></a>

<p><a href="https://www.apollographql.com/docs/apollo-server/">Apollo Server</a> 是以 Node 为后端的 GraphQL 实现，我选择 Apollo 是因为它是一套完整的服务框架，它包括前端和后端，可拓展性强，并且 Node 也是后端开发最快的方式。</p>
<p>我不喜欢贴代码，我会从 0 开始搭建一个普通的 web 服务器，从创建一个 GraphQL 的 mock Server 来说明 Apollo Server 的运行逻辑，其实 GraphQL 服务器的运行逻辑也大致如此，最后接入数据库，更接近实战。</p>
<h1 id="基本服务器监听"><a href="#基本服务器监听" class="headerlink" title="基本服务器监听"></a>基本服务器监听</h1><p><em>本节为搭建基础服务器而不是 GraphQL 服务器，熟练的朋友可跳过。</em></p>
<p>Apollo Server 可作为一个独立的服务器，我们可以安装 Apollo 后直接启动服务器监听，但功能它的只限于对数据的增删改查，一个服务器可能还需要如下功能：</p>
<ul>
<li>模板渲染或 SSR</li>
<li>身份验证</li>
<li>文件上传</li>
<li>…</li>
</ul>
<p>为了便于拓展业务功能，我将 Apollo Server 作为 Node 服务器的中间件，你可以选择你喜欢的 Node 服务器框架，或者自己搭建 Node 服务器，我选择的是 <a href="https://www.koajs.com.cn/">Koa</a>，接下来开始搭建整体架构：</p>
<h2 id="安装-Koa-和-Apollo-Server"><a href="#安装-Koa-和-Apollo-Server" class="headerlink" title="安装 Koa 和 Apollo Server"></a>安装 Koa 和 Apollo Server</h2><figure class="highlight powershell"><figcaption><span>PowerShell</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i koa<span class="literal">-generator</span> <span class="literal">-g</span></span><br><span class="line">koa2 项目名</span><br></pre></td></tr></table></figure>

<p>生成的目录如下，长的很像 MVC 架构：<br><img src="https://i.loli.net/2020/07/07/6jbzi9kqFVEJWB3.png" alt="origin-dir.png"><br><code>app.js</code> 里引入了必备的库并初始化和定义路由，最终由 <code>bin/www</code> 引用并真正将他们使用起来。</p>
<p>接下来安装依赖，除了 koa-generator 生成的依赖，还需要安装<code>apollo-server-koa</code>和<code>graphql</code>，这样将 Apollo Server 作为中间件，如果你使用其他 Node 服务器，可以在<a href="https://www.apollographql.com/docs/apollo-server/integrations/middleware/">这里</a>找到适合的中间件。</p>
<h2 id="开发建议"><a href="#开发建议" class="headerlink" title="开发建议"></a>开发建议</h2><p>每次编辑代码之后查看更改必须要重新启动服务器，koa-generator 自动为我们安装<code>nodemon</code>，它能监听工作区的文件更改，进行热更新。这样的话，你需要将<code>bin/www</code>文件改为<code>bin/www.js</code>，因为<code>nodemon</code>不会监听没有后缀名文件的更改。</p>
<p>安装依赖后最后使用<code>npm run dev</code>就能启动服务器了，默认端口为 3000，你可以通过<code>localhost:3000</code>访问。</p>
<h1 id="简单的-GraphQL-服务"><a href="#简单的-GraphQL-服务" class="headerlink" title="简单的 GraphQL 服务"></a>简单的 GraphQL 服务</h1><p><strong>为了方便大家理解本节内容，写这篇博客的时候我也亲自做了一遍，你可以 clone<a href="https://github.com/KylinLee/koa-apollo-template/tree/mock">我的仓库</a>，切换到 mock 分支查看。</strong></p>
<figure class="highlight bash"><figcaption><span>GitBash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/KylinLee/koa-apollo-template.git</span><br><span class="line">git checkout mock</span><br></pre></td></tr></table></figure>

<p>Apollo GraphQL 由以下部分组成：</p>
<ul>
<li>Schema：图、结构</li>
<li>Data：数据源</li>
<li>Resolver：解析器</li>
</ul>
<p>为了便于理解，先模拟一个查询书籍相关信息的 GraphQL 服务器</p>
<h2 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h2><p>Schema 相当于接口（指 API 接口），定义了客户端可以执行的操作类型，数据结构体，数据字段及类型。在 MVC 架构中，相当于模型，我的理解 Schema 是数据的入口和出口，一个请求传过来首先通过 Schema 校验，响应内容最终也会以 Schema 定义的格式返回，相当于一个模具，固定数据进出的格式。<br>所以新建一个<code>model/schema</code>目录，在目录中建立 Schema 并将其导出备用：</p>
<figure class="highlight javascript"><figcaption><span>model/schema/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; gql &#125; = <span class="built_in">require</span>(<span class="string">"apollo-server-koa"</span>);</span><br><span class="line"><span class="keyword">const</span> typeDefs = gql<span class="string">`</span></span><br><span class="line"><span class="string">    type Book &#123;</span></span><br><span class="line"><span class="string">        title: String</span></span><br><span class="line"><span class="string">        author: String</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    type Query &#123;</span></span><br><span class="line"><span class="string">        books: [Book]</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = typeDefs;</span><br></pre></td></tr></table></figure>

<p>GraphQL 中文文档中将类似于上面 <code>Book</code> 的结构叫做“<strong>类型</strong>”，但我认为对于编程人员将它们叫做“<strong>结构体</strong>”更容易理解。</p>
<h2 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h2><p>数据比较容易理解，客户端需要的内容，服务器可返回的内容就是数据。为了简化流程，便于理解，我们选择使用模拟数据，可以新建<code>data</code>目录，将模拟数据放在这里并导出备用：</p>
<figure class="highlight javascript"><figcaption><span>data/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> books = [</span><br><span class="line">    &#123;</span><br><span class="line">        title: <span class="string">"Harry Potter and the Chamber of Secrets"</span>,</span><br><span class="line">        author: <span class="string">"J.K. Rowling"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        title: <span class="string">"Jurassic Park"</span>,</span><br><span class="line">        author: <span class="string">"Michael Crichton"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="built_in">module</span>.exports = books;</span><br></pre></td></tr></table></figure>

<h2 id="Resolver"><a href="#Resolver" class="headerlink" title="Resolver"></a>Resolver</h2><p>解析器的作用是将 Schema 和 Data 联系在一起，即根据客户端传来的查询语句在一大堆 Data 里边找到指定的数据，如果说放在 MVC 里边，可以作为控制器，也可以作为模型，看个人如何理解，其实 MVC 没有很严格的界定，如果你的 Resolver 除了查询数据还具有其他复杂的功能，将其定义为控制器比较合适，如果你的 Resolver 专门用于数据的查询，将其作为模型看待。我将 Resolver 放在<code>model/resolver</code>目录下。</p>
<p>现在我们可以分析一下，查询<code>Books</code>，需要返回一个数组，数组的每一项需要符合<code>Book</code>的结构，即每一项需要包含<code>title</code>和<code>author</code>字段，巧的是我们模拟的数据<code>book</code>正好符合<code>Books</code>的结构。</p>
<p><strong>在开发中，这个分析很重要，请不要忽略！！！</strong></p>
<p>所以我们的 Resolver 这样写：</p>
<figure class="highlight javascript"><figcaption><span>model/resolver/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> books = <span class="built_in">require</span>(<span class="string">"../../data/index.js"</span>);</span><br><span class="line"><span class="keyword">const</span> resolvers = &#123;</span><br><span class="line">    Query: &#123;</span><br><span class="line">        books: <span class="function"><span class="params">()</span> =&gt;</span> books,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = resolvers;</span><br></pre></td></tr></table></figure>

<p>为 Schema 中对应的结构体编写同名的函数，并将这些函数作为<code>resolvers</code>对象的键和值，导出<code>resolvers</code>备用。</p>
<h3 id="Resolver-进阶"><a href="#Resolver-进阶" class="headerlink" title="Resolver 进阶"></a>Resolver 进阶</h3><p>其实你只编写了 Query 中 books 的解析器，books 是以 Book 为单元的数组，但我们并没有编写 Book 结构体的解析器，它还是返回了我们预期的结果。实际上 Apollo 并不是<code>data</code>是什么就返回什么，将<code>data</code>中的<code>author</code>改为<code>authors</code>，只会返回<code>title</code>字段内容。默认情况下，如果你没有编写某个结构体的解析器，Apollo 将会使用默认解析器，它会根据 books 的结果去验证里边的某一项是否符合 Book 解析器，最终返回符合 Book 的结果，起到了过滤的效果，了解默认解析器可以帮助你少编写代码。</p>
<h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><p>将三部分准备其了，接下来将这三部分接入服务器，供服务器调用，首先在<code>www.js</code>这个执行文件中引入这三部分，然后将他们作为选项传入 Apollo Server，最后将 Apollo Server 作为 Koa 中间件，<strong>关键代码</strong>如下：</p>
<figure class="highlight javascript"><figcaption><span>bin/www.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">"../app.js"</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; ApolloServer &#125; = <span class="built_in">require</span>(<span class="string">"apollo-server-koa"</span>);</span><br><span class="line"><span class="keyword">const</span> typeDefs = <span class="built_in">require</span>(<span class="string">"../model/schema/index.js"</span>);</span><br><span class="line"><span class="keyword">const</span> resolvers = <span class="built_in">require</span>(<span class="string">"../model/resolver/index.js"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造Apollo Server;</span></span><br><span class="line"><span class="keyword">const</span> server = <span class="keyword">new</span> ApolloServer(&#123;</span><br><span class="line">    typeDefs,</span><br><span class="line">    resolvers,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将server作为中间件</span></span><br><span class="line">server.applyMiddleware(&#123; app &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动监听，注意将原来的server改为app</span></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">    cosneole.log(<span class="string">"please open localhost:3000/graphql"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>打开<code>localhost:3000/graphql</code>，进行 GraphQL 查询，GraphQL 基础这里就不讲了，既然决定用 Apollo Server 相信大家都会，测试如下：<br><img src="https://i.loli.net/2020/07/09/TLayrYwQmhIBKp6.png" alt="test-graphql.png"></p>
<h1 id="使用-MySQL-作为数据源"><a href="#使用-MySQL-作为数据源" class="headerlink" title="使用 MySQL 作为数据源"></a>使用 MySQL 作为数据源</h1><p><strong>便于大家理解本节，你可以 clone<a href="https://github.com/KylinLee/koa-apollo-template/tree/mysql">我的仓库</a>，切换到 mysql 分支查看。</strong></p>
<figure class="highlight bash"><figcaption><span>GitBash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/KylinLee/koa-apollo-template.git</span><br><span class="line">git checkout mysql</span><br></pre></td></tr></table></figure>

<p>通过上面的讲解你已经理解 Apollo Server 的开发流程了吧，上面这个例子中使用的是模拟的数据，是固定不变的，接下来是重头戏——接入数据库。</p>
<p>我是用的是 MySQL，按照官方文档，可以使用的数据源有数据库和 RESTful API，支持 RESTful API 的原因是帮助使用 RESTful API 的服务迁移到 GraphQL，我使用关系型数据库 MySQL 作为数据源。</p>
<p>上面的例子中我们向 <code>ApolloServer</code> 构造函数传递了一个配置对象，这个配置对象包含了两个内容<code>typeDefs</code>和<code>resolvers</code>。其中数据源是在 resolver 中引入的，我们也可以将数据源传入 <code>ApolloServer</code> 构造函数，在 <code>ApolloServer</code> 实例化的时候就初始化连接数据库，我们使用 Apollo 社区维护的数据源工具<a href="https://github.com/cvburgess/SQLDataSource">datasource-sql</a>，它是基于<a href="http://knexjs.org/">knex</a>的，<code>knex</code>是一个查询构造器，通过<code>knex</code>我们可以用熟悉的 JavaScript 语法去执行 SQL 查询，<code>datasource-sql</code>的工作是将<code>knex</code>包装成<code>ApolloServer</code>构造函数可接受的对象，让我们先安装它：</p>
<figure class="highlight powershell"><figcaption><span>PowerShell</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i datasource<span class="literal">-sql</span> mysql -<span class="literal">-save</span></span><br></pre></td></tr></table></figure>

<p>然后我们需要做三部分的更改：</p>
<ol>
<li>配置数据库并实例化数据源工具</li>
<li>将数据源实例传入<code>ApolloServer</code></li>
<li>在 resolver 中使用数据源</li>
</ol>
<h2 id="配置数据库并实例化数据源工具"><a href="#配置数据库并实例化数据源工具" class="headerlink" title="配置数据库并实例化数据源工具"></a>配置数据库并实例化数据源工具</h2><p>首先配置数据库，在<code>data</code>文件夹创建<code>data/mysql.config.js</code>：</p>
<figure class="highlight javascript"><figcaption><span>mysql.config.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> knexConfig = &#123;</span><br><span class="line">    client: <span class="string">"mysql"</span>,</span><br><span class="line">    connection: &#123;</span><br><span class="line">        host: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">        port: <span class="number">3306</span>,</span><br><span class="line">        user: <span class="string">"root"</span>,</span><br><span class="line">        password: <span class="string">""</span>,</span><br><span class="line">        database: <span class="string">"Book"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后创建<code>data/methods.js</code>，这里边定义了数据库的操作方法供 resolver 调用，这些方法包含了你需要对数据库进行的所有操作，比如下面这段代码就是获取<code>books</code>表中的所有字段，相当于 SQL 语句:</p>
<figure class="highlight plain"><figcaption><span>SQL</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from books;</span><br></pre></td></tr></table></figure>

<p><strong>注意：使用 knex 查询器返回的是 Promise。</strong></p>
<figure class="highlight javascript"><figcaption><span>data/methods.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SQLDataSource &#125; = <span class="built_in">require</span>(<span class="string">"datasource-sql"</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FetchMethods</span> <span class="keyword">extends</span> <span class="title">SQLDataSource</span> </span>&#123;</span><br><span class="line">    getAllBooks() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.knex(<span class="string">"books"</span>)</span><br><span class="line">            .select(<span class="string">"*"</span>)</span><br><span class="line">            .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.table(res);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;)</span><br><span class="line">            .catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="number">0</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = FetchMethods;</span><br></pre></td></tr></table></figure>

<p>最终实例化数据库工具的逻辑是：将数据库配置对象传入包含数据库操作方法的类，如下：</p>
<figure class="highlight javascript"><figcaption><span>data/mysql.config.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyDatabase = <span class="built_in">require</span>(<span class="string">"./methods"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> knexConfig = &#123;</span><br><span class="line">    client: <span class="string">"mysql"</span>,</span><br><span class="line">    connection: &#123;</span><br><span class="line">        host: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">        port: <span class="number">3306</span>,</span><br><span class="line">        user: <span class="string">"root"</span>,</span><br><span class="line">        password: <span class="string">""</span>,</span><br><span class="line">        database: <span class="string">"Book"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db = <span class="keyword">new</span> MyDatabase(knexConfig);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = db;</span><br></pre></td></tr></table></figure>

<h2 id="将数据源实例传入ApolloServer"><a href="#将数据源实例传入ApolloServer" class="headerlink" title="将数据源实例传入ApolloServer"></a>将数据源实例传入<code>ApolloServer</code></h2><p>通过上面的实例化之后成为了<code>ApolloServer</code>构造函数可接受的数据源对象，对 ApolloServer 配置做如下更改：</p>
<figure class="highlight javascript"><figcaption><span>bin/www.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">"../app.js"</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; ApolloServer &#125; = <span class="built_in">require</span>(<span class="string">"apollo-server-koa"</span>);</span><br><span class="line"><span class="keyword">const</span> typeDefs = <span class="built_in">require</span>(<span class="string">"../model/schema/index.js"</span>);</span><br><span class="line"><span class="keyword">const</span> resolvers = <span class="built_in">require</span>(<span class="string">"../model/resolver/index.js"</span>);</span><br><span class="line"><span class="comment">// 引入数据源</span></span><br><span class="line"><span class="keyword">const</span> db = <span class="built_in">require</span>(<span class="string">"../data/mysql.config.js"</span>);</span><br><span class="line"><span class="comment">// 实例化 ApolloServer</span></span><br><span class="line"><span class="keyword">const</span> server = <span class="keyword">new</span> ApolloServer(&#123;</span><br><span class="line">    typeDefs,</span><br><span class="line">    resolvers,</span><br><span class="line">    dataSources: <span class="function"><span class="params">()</span> =&gt;</span> (&#123; db &#125;),</span><br><span class="line">    context: <span class="function">(<span class="params">app</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> method = app.ctx.method;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            method,</span><br><span class="line">            uid: <span class="string">"20202020"</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    tracing: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>关键代码是第 6 行和第 11 行，</p>
<h3 id="context-对象"><a href="#context-对象" class="headerlink" title="context 对象"></a>context 对象</h3><p>另外我往里边传了<code>context</code>对象，这是非必要的，有<code>context</code>对象之后我们可以在 resolver 中使用他们，如上面这段代码中返回了当前请求的方法和一个<code>uid</code>，我们在 resolver 里边就能使用这两个变量，具体怎么使用将在下一小节中阐述。<code>context</code>对象是很有用的，比如通过 JWT 验证请求者身份之后，可以将记录这个身份的信息传给 resolver，接着 resolver 将这个信息作为数据库查询参数。</p>
<h2 id="在-resolver-中使用数据源"><a href="#在-resolver-中使用数据源" class="headerlink" title="在 resolver 中使用数据源"></a>在 resolver 中使用数据源</h2><p>使用数据源就比较简单了，和我们之前写简单的 GraphQL 服务一样，在<code>model/resolver/index.js</code>中写 resolver 方法：</p>
<figure class="highlight javascript"><figcaption><span>model/resolver/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolvers = &#123;</span><br><span class="line">    Query: &#123;</span><br><span class="line">        <span class="keyword">async</span> books(_source, _args, &#123; dataSources &#125;) &#123;</span><br><span class="line">            <span class="keyword">return</span> dataSources.db.getAllBooks();</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = resolvers;</span><br></pre></td></tr></table></figure>

<p>通过前面的一系列构造，我们之前编写的数据库操作方法可以通过<code>dataSources.db</code>来访问，你可以使用<code>await</code>，也可以不使用，因为 resolver 的返回值可以是 Promise 对象，这主要取决于你的数据库操作方法是如何写的。</p>
<p>我们注意到每一个结构的<code>resolver</code>还有几个参数，resolver 可以接收四个参数，最常用的就是上面这段代码中写到的前三个参数。</p>
<h3 id="第一个参数parent"><a href="#第一个参数parent" class="headerlink" title="第一个参数parent"></a>第一个参数<code>parent</code></h3><p>上面的代码中是<code>_source</code>，代表上一级解析器的返回值，因为 Schema 中定义的结构体是可以嵌套的，所以出现了多级选择器的概念，GraphQL 的解析顺序是从最外层解析的，返回最外层的解析结果之后才进行下一级解析，我们可以通过这个参数获取上一级的返回值然后将这个值作为下一级的参数</p>
<h3 id="第二个参数args"><a href="#第二个参数args" class="headerlink" title="第二个参数args"></a>第二个参数<code>args</code></h3><p>上面的代码中是<code>_args</code>，顾名思义是参数的意思，指 GraphQL 查询中传递的参数如：</p>
<figure class="highlight plain"><figcaption><span>GraphQL</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">    book(id: 10)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设这是查询 id 为 10 的书籍信息，那么 resolver 中可以这样写：</p>
<figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolvers = &#123;</span><br><span class="line">    Query: &#123;</span><br><span class="line">        <span class="keyword">async</span> books(_source, _args, &#123; dataSources &#125;) &#123;</span><br><span class="line">            <span class="keyword">return</span> dataSources.db.getAllBooks(_args.id);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = resolvers;</span><br></pre></td></tr></table></figure>

<p>然后在数据库操作方法的函数中接收这个参数。</p>
<h3 id="第三个参数context"><a href="#第三个参数context" class="headerlink" title="第三个参数context"></a>第三个参数<code>context</code></h3><p>第三个参数是上下文，由此可见，构造器其实是将我们的数据源<code>db</code>放在了上下文之中，<code>dataSources.db</code>则是我们的数据源，还记得之前传入<code>ApolloServer</code>的配置文件吗，我传入了一个 context 对象，ApolloServer 将它作为<code>db</code>对象的一个属性，这一点我不清楚为什么要这么设计，访问配置文件中传入的<code>context</code>对象通过如下方式获取：</p>
<figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolvers = &#123;</span><br><span class="line">    Query: &#123;</span><br><span class="line">        <span class="keyword">async</span> books(_source, _args, &#123; dataSources &#125;) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(dataSourses.db.context.uid); <span class="comment">// 20202020</span></span><br><span class="line">            <span class="keyword">return</span> dataSources.db.getAllBooks();</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果你从头看完，至此相信你已经从零入门了，以上讲述的内容已经足够你开发一个功能完善的 GraphQL 服务器了，此外，不理解的话可以去 Apollo GraphQL 的<a href="https://www.apollographql.com/">官方网站</a>看看。</p>
<article class="message message-immersive is-warning">
<div class="message-body">
<p>本文作者：KylinLee</p>
<p>本文链接：<a href="https://kylin.dev/2020/07/07/Apollo-GraphQL快速上手-服务端/">https://kylin.dev/https://kylin.dev/2020/07/07/Apollo-GraphQL快速上手-服务端</a></p>
<p>版权声明：本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p>
</div>
</article>
</div><div class="article-tags size-small is-uppercase mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/JavaScript/">JavaScript</a><a class="link-muted mr-2" rel="tag" href="/tags/GraphQL/">GraphQL</a></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><div class="social-share"></div><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="https://i.loli.net/2020/05/17/rEJdt7RFbVqhYn4.png" alt="支付宝"></span></a><a class="button is-success donate"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="https://i.loli.net/2020/05/17/e7yltg1LYB5mwXd.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/07/10/%E5%9C%A8Vue%E4%B8%AD%E4%BD%BF%E7%94%A8GraphQL/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">在Vue中使用GraphQL</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/06/13/JavaScript%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B/"><span class="level-item">JavaScript中的协程</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread' ,
            notify: false,
            verify: true,
            appId: 'iJT9oiFouP7hSK4BlRcbtanJ-gzGzoHsz',
            appKey: 'tfHhx5u2oGMMrs1WLReQL3h8',
            placeholder: '欢迎讨论',
            avatar: '',
            avatarForce: false,
            meta: ["nick","mail","link"],
            pageSize: 10,
            visitor: false,
            highlight: true,
            recordIP: true
        });</script></div></div></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3 is-sticky"><div class="card widget" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex" href="#基本服务器监听"><span class="mr-2">1</span><span>基本服务器监听</span></a><ul class="menu-list"><li><a class="is-flex" href="#安装-Koa-和-Apollo-Server"><span class="mr-2">1.1</span><span>安装 Koa 和 Apollo Server</span></a></li><li><a class="is-flex" href="#开发建议"><span class="mr-2">1.2</span><span>开发建议</span></a></li></ul></li><li><a class="is-flex" href="#简单的-GraphQL-服务"><span class="mr-2">2</span><span>简单的 GraphQL 服务</span></a><ul class="menu-list"><li><a class="is-flex" href="#Schema"><span class="mr-2">2.1</span><span>Schema</span></a></li><li><a class="is-flex" href="#Data"><span class="mr-2">2.2</span><span>Data</span></a></li><li><a class="is-flex" href="#Resolver"><span class="mr-2">2.3</span><span>Resolver</span></a><ul class="menu-list"><li><a class="is-flex" href="#Resolver-进阶"><span class="mr-2">2.3.1</span><span>Resolver 进阶</span></a></li></ul></li><li><a class="is-flex" href="#Server"><span class="mr-2">2.4</span><span>Server</span></a></li><li><a class="is-flex" href="#测试结果"><span class="mr-2">2.5</span><span>测试结果</span></a></li></ul></li><li><a class="is-flex" href="#使用-MySQL-作为数据源"><span class="mr-2">3</span><span>使用 MySQL 作为数据源</span></a><ul class="menu-list"><li><a class="is-flex" href="#配置数据库并实例化数据源工具"><span class="mr-2">3.1</span><span>配置数据库并实例化数据源工具</span></a></li><li><a class="is-flex" href="#将数据源实例传入ApolloServer"><span class="mr-2">3.2</span><span>将数据源实例传入ApolloServer</span></a><ul class="menu-list"><li><a class="is-flex" href="#context-对象"><span class="mr-2">3.2.1</span><span>context 对象</span></a></li></ul></li><li><a class="is-flex" href="#在-resolver-中使用数据源"><span class="mr-2">3.3</span><span>在 resolver 中使用数据源</span></a><ul class="menu-list"><li><a class="is-flex" href="#第一个参数parent"><span class="mr-2">3.3.1</span><span>第一个参数parent</span></a></li><li><a class="is-flex" href="#第二个参数args"><span class="mr-2">3.3.2</span><span>第二个参数args</span></a></li><li><a class="is-flex" href="#第三个参数context"><span class="mr-2">3.3.3</span><span>第三个参数context</span></a></li></ul></li></ul></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-10T03:51:15.000Z">2020-07-10</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/10/%E5%9C%A8Vue%E4%B8%AD%E4%BD%BF%E7%94%A8GraphQL/">在Vue中使用GraphQL</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Code/">Code</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-07T10:06:26.000Z">2020-07-07</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/07/Apollo-GraphQL%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E6%9C%8D%E5%8A%A1%E7%AB%AF/">Apollo-GraphQL快速上手-服务端</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Code/">Code</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-13T15:24:56.000Z">2020-06-13</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/13/JavaScript%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B/">JavaScript中的协程</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Code/">Code</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-13T09:22:44.000Z">2020-06-13</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/13/%E5%B0%9D%E8%AF%95%E7%94%A8%E9%80%9A%E4%BF%97%E7%9A%84%E6%96%B9%E5%BC%8F%E8%A7%A3%E9%87%8A%E5%8D%8F%E7%A8%8B/">尝试用通俗的方式解释协程</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Code/">Code</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-05-30T08:47:21.000Z">2020-05-30</time></p><p class="title is-6"><a class="link-muted" href="/2020/05/30/%E6%B5%85%E8%B0%88GraphQL%E7%9A%84%E5%B0%B4%E5%B0%AC/">浅谈GraphQL的尴尬</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Code/">Code</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://i.loli.net/2020/04/25/iIF2oqRkzYEAhx1.png" alt="蝶恋花-等风也等你" height="28"></a><p class="size-small"><span>&copy; 2020 KylinLee</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><a href="https://icp.gov.moe" target="_blank">萌ICP备</a><a href="https://icp.gov.moe/?keyword=202022019" target="_blank">202022019号</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Noncommercial 4.0 International" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"><i class="fab fa-creative-commons-nc"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="ShareAlike 4.0 International" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"><i class="fab fa-creative-commons-sa"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://kylin.dev',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>