<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>蝶恋花-等风也等你</title>
  
  <subtitle>等风也等你</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kylin.dev/"/>
  <updated>2020-10-01T06:23:08.605Z</updated>
  <id>https://kylin.dev/</id>
  
  <author>
    <name>Kylin Lee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一次性搞懂Flux，Redux和Vuex（Flux架构）篇</title>
    <link href="https://kylin.dev/2020/09/24/%E4%B8%80%E6%AC%A1%E6%80%A7%E6%90%9E%E6%87%82Flux%EF%BC%8CRedux%E5%92%8CVuex/"/>
    <id>https://kylin.dev/2020/09/24/%E4%B8%80%E6%AC%A1%E6%80%A7%E6%90%9E%E6%87%82Flux%EF%BC%8CRedux%E5%92%8CVuex/</id>
    <published>2020-09-24T10:30:21.000Z</published>
    <updated>2020-10-01T06:23:08.605Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这次的野心有点大，想要一次性讲清楚三个状态管理工具，但是毫不夸张，这篇文章将带你快速理解并掌握这三个工具，本篇将介绍最重要的<code>Flux</code>架构。</p><a id="more"></a><h1 id="他们之间的关系"><a href="#他们之间的关系" class="headerlink" title="他们之间的关系"></a>他们之间的关系</h1><p>使用过其中任一状态管理工具的朋友或多或少都会听说过<code>Flux</code>，<code>Flux</code>既是一种架构也是一个状态管理工具，三者都是根据<code>Flux</code>架构的原理进行设计的，所以搞清楚<code>Flux</code>架构就能轻松掌握三种状态管理工具，这个系列将分三次讲诉：</p><ol><li><code>Flux</code>架构</li><li><code>Redux</code>基础</li><li><code>Vuex</code>基础</li></ol><p><code>Flux</code>架构是三大状态管理的工具的基础，搞懂<code>Flux</code>架构，从此的学习一马平川。</p><h1 id="Flux-架构"><a href="#Flux-架构" class="headerlink" title="Flux 架构"></a>Flux 架构</h1><h2 id="什么是-Flux"><a href="#什么是-Flux" class="headerlink" title="什么是 Flux"></a>什么是 Flux</h2><p>Flux 是管理应用程序中数据流的模式，其核心思想是数据向一个方向流动。数据的流动方向如下图所示：</p><p><img src="https://i.loli.net/2020/10/01/s73pcAQrt9ZvoDS.png" alt="flux-overview.png"></p><p>从上图可以看到数据在 Dispatcher、Store、View、Action 之间形成了一个闭环，并且流动方向都是单向的，这样做的好处是使逻辑组织更加清晰，并且更方便管理。</p><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>在我看来 Action 在数据改变的过程中充当信使的作用，Action 本质上是一个包含 type 属性的对象，用 TypeScript 表示，其接口类似于下面这样：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Action &#123;</span><br><span class="line">    <span class="keyword">type</span>: <span class="built_in">string</span>;</span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h3><p>中文译作”调度器“，和其名字一样，作用是根据传递过来的 Action 的 type 类型控制执行哪些函数，起到了调度器的作用。</p><h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>Flux 架构通常应用于 APP 全局，Store 就是整个应用的中心仓库，本质也是一个对象，可以储存所有你想要在应用中使用的变量，这些变量的值通常被称为状态，如果将 Store 用于整个应用，那么在应用销毁之前，在应用内任何地方都能访问到 Store 中的内容，如果将 Store 应用于某个组件，那么 Store 将伴随着组件的生命周期重新创建和销毁，仅能在该组件存在的时候在该组件或者子组件内访问到。</p><h2 id="各个部分是如何配合完成状态更新的"><a href="#各个部分是如何配合完成状态更新的" class="headerlink" title="各个部分是如何配合完成状态更新的"></a>各个部分是如何配合完成状态更新的</h2><p>模拟一个真实的需求场景，网站的登陆状态几乎是页面所有组件都需要获取的，现在需要根据登录状态显示个性化内容，一开始并没有登录这个网站，现在点击登录，使用 Flux 架构，数据应该是这样改变的：</p><ol><li>经过后台验证后（验证成功），创建一个 Action 对象</li><li>这时候我们向 Dispatcher 传入准备好的 Action</li><li>Dispatcher 匹配到 Action 的 type 属性，调用对应的函数改变 Store 中的登录状态</li><li>Store 是一个订阅兑对象，当 Store 发生变化时，订阅 Store 相应内容的对象就会收到订阅改变的事件，执行相应的回调或者更新视图。</li></ol><h1 id="Flux-实战"><a href="#Flux-实战" class="headerlink" title="Flux 实战"></a>Flux 实战</h1><p>通过上面的讲解，也许你还不太能理解，接下来，将通过简单的代码实现来深入理解这个过程。</p><article class="message message-immersive is-warning"><div class="message-body"><p>本文作者：KylinLee</p><p>本文链接：<a href="https://kylin.dev/2020/09/24/一次性搞懂Flux，Redux和Vuex">https://kylin.dev/2020/09/24/一次性搞懂Flux，Redux和Vuex</a></p><p>版权声明：本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p></div></article>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次的野心有点大，想要一次性讲清楚三个状态管理工具，但是毫不夸张，这篇文章将带你快速理解并掌握这三个工具，本篇将介绍最重要的&lt;code&gt;Flux&lt;/code&gt;架构。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Code" scheme="https://kylin.dev/categories/Code/"/>
    
    
      <category term="JavaScript" scheme="https://kylin.dev/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>自省-细数那些曾经乐此不疲的事</title>
    <link href="https://kylin.dev/2020/07/16/%E8%87%AA%E7%9C%81-%E7%BB%86%E6%95%B0%E9%82%A3%E4%BA%9B%E6%9B%BE%E7%BB%8F%E4%B9%90%E6%AD%A4%E4%B8%8D%E7%96%B2%E7%9A%84%E4%BA%8B/"/>
    <id>https://kylin.dev/2020/07/16/%E8%87%AA%E7%9C%81-%E7%BB%86%E6%95%B0%E9%82%A3%E4%BA%9B%E6%9B%BE%E7%BB%8F%E4%B9%90%E6%AD%A4%E4%B8%8D%E7%96%B2%E7%9A%84%E4%BA%8B/</id>
    <published>2020-07-16T12:32:50.000Z</published>
    <updated>2020-07-24T05:16:00.113Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在成长的过程中不妨也回头看看当年的自己，这篇文章就来说一说我曾经乐此不疲但又没什么用处的事，简称瞎折腾。</p><a id="more"></a><h1 id="写作初衷"><a href="#写作初衷" class="headerlink" title="写作初衷"></a>写作初衷</h1><p>看到标题你就会明白，为什么是“曾经乐此不疲”，也许你也和我一样，在很长一段时间内兴致勃勃的做同一件事，最后发现，这些事其实并没有什么用，甚至是绕了一圈又回到原地，有些懊恼，却又有些怀念。</p><p>并不是说这种折腾毫无用处，其实我在折腾中学到了很多，写这篇文章是站在现在看过去的自己，才发现在成长的过程中。</p><h1 id="怀念那颗超级好奇的心"><a href="#怀念那颗超级好奇的心" class="headerlink" title="怀念那颗超级好奇的心"></a>怀念那颗超级好奇的心</h1><p>一个人年龄越大，经历的越多，什么事都司空见惯，好奇心逐渐就没了，所以老人往往更稳重，感觉自己便是刚经历了这么一段什么事都好奇的一段时期，回过头来看那时为了什么而折腾半天，还真的有些想笑，“笑”当时能为一点小小的突破高兴一天，“笑”为了做一件事而不断地用不同的方式折腾，“笑”不值得熬夜的熬夜······</p><h1 id="细数那些乐此不疲的事"><a href="#细数那些乐此不疲的事" class="headerlink" title="细数那些乐此不疲的事"></a>细数那些乐此不疲的事</h1><p>和大都数人一样，都喜欢视觉上的折腾，总结起来就是：</p><ol><li>折腾主题、折腾皮肤</li><li>折腾系统</li><li>折腾博客</li></ol><h2 id="折腾主题、皮肤"><a href="#折腾主题、皮肤" class="headerlink" title="折腾主题、皮肤"></a>折腾主题、皮肤</h2><p>可能是人类共有的一种“本领”，而且，那些商家正好抓住了这种心理，比如 LOL 买几个皮肤、主题商店买几套主题。</p><p>高中那会儿，开始折腾手机主题，不会画图标，就从别人的包里边找一堆拼在一起，不会编程，XML 布局全部靠 copy，就这样拿着别人的的主题来自己组装，玩的不亦乐乎。后来不知怎么的就觉得没什么意思了，学到的其实不多，但至少我了解到的足够让我指导一个新人如何去制作主题包，那时很菜的我在群里解答一个新人问题也是比较有自豪感的。</p><p>至于皮肤，我不玩游戏，所以不是指游戏皮肤啦，我说的是输入法皮肤，那时候看到输入法 14 键觉得很新奇，然后寻他千百度，终于找到了来源，具体可以查看我的这篇文章：<a href="/2019/06/20/%E8%BE%93%E5%85%A5%E6%B3%95%E5%A2%9E%E5%BC%BA/" title="输入法增强">输入法增强</a>，关于皮肤作者的一系列主题我基本上都用过，着实花了不少时间来换。</p><p>你不得不承认，换皮肤、主题这种不是刚需的功能，其实是很容易让你掏腰包的。</p><h2 id="折腾系统"><a href="#折腾系统" class="headerlink" title="折腾系统"></a>折腾系统</h2><p>最开始是搞安卓系统，当时我连刷机的不知道，后来参加了 OPPO 的系统内测，涉及到降级，在刷降级包的时候才知道刷机的一般手法，也不是什么系统都刷，我只是用刷机工具刷了别人制作好的精简版 root 系统。因为只有一个手机，刷坏了就完了，所以我并没有养成刷机的习惯。</p><p>大一下期，自己掏钱换了台电脑，多了台闲置的电脑，果不其然养成了我爱折腾系统的毛病。在换电脑之前我还是挣扎了一下，本来机子是 x64 的，但人家给装的 x86，然后我换成了 Windows 10 x64，本以为这样能快一点，可 14 年 i3 的机子托 x64 的系统显得更慢了，换了条 8G 内存条也无果，最后选择换电脑。所以我就在这台闲置电脑上装多系统，最开始装的是 Deepin，也是我迄今为止体验过最棒的 Linux 桌面系统。后来在电脑上装好几个系统，有<a href="https://www.microsoft.com/zh-cn/windows/">Windows 10</a>，<a href="https://www.microsoft.com/zh-cn/windows/">Deepin 15</a>，<a href="https://ubuntu.com/">Ubuntu</a>，<a href="https://manjaro.org/">Manjaro</a>，还有大多数人不知道的<a href="http://www.gd-linux.com/">新支点操作系统</a>，ChromeOS 的一个第三方发行版<a href="https://fydeos.com/">FydeOS</a>，其实现在想一想，装这么多系统没有什么实用性，让我慢慢停止这种做法的原因就在于此，注重实用性，所以我又开始折腾 WSL 和 WSL2 了（我真的是生命不息折腾不止）。</p><h2 id="折腾博客和站点"><a href="#折腾博客和站点" class="headerlink" title="折腾博客和站点"></a>折腾博客和站点</h2><h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><p>这个是我今年经常干的事，一开始我的博客站点是使用<a href="https://gridea.dev">Gridea</a>，后来看到别人说<a href="http://typecho.org/">Typecho</a>就去尝试了。可以想象一下将一个静态站点转为动态的苦恼，还好写的文章不算多，迁移没有花太多时间，后来将 Typecho 上的文章迁移到 Hexo 才悔不当初。不管用什么博客平台，换主题是免不了的，我也是主题市场的常客。</p><p><img src="https://i.loli.net/2020/07/24/ofKVTqEl72i9jsI.png" alt="liqilinhub.cloud.png"></p><p><img src="https://i.loli.net/2020/07/24/Frsofka746ILR5Y.png" alt="lqilinhub.cloud-about.png"></p><p>想着服务器上只放个博客太浪费了，于是部署了很多服务在上面。</p><h3 id="Chevereto"><a href="#Chevereto" class="headerlink" title="Chevereto"></a>Chevereto</h3><p><a href="https://chevereto.com/">Chevereto</a>，PHP 作为后端的图床应用：</p><p><img src="https://i.loli.net/2020/07/24/2Wr7yMJSHiGBEmt.jpg" alt="image.liqilinhub.cloud-home.jpg"></p><p><img src="https://i.loli.net/2020/07/24/PCQlIE2eudKOfj5.jpg" alt="image.liqilinhub.cloud-image.jpg"></p><p>我会将我拍的一些照片放在上面。</p><h3 id="Seafile"><a href="#Seafile" class="headerlink" title="Seafile"></a>Seafile</h3><p><a href="https://www.seafile.com/home/">Seafile</a>，开源的网盘应用，我用来搭建私人网盘，可以解决传文件的困苦，同时支持 WEBDAV，做云同步很方便。</p><p><img src="https://i.loli.net/2020/07/24/7zyqcZj5RWXlCK1.png" alt="pan.liqilinhub.cloud.png"></p><h3 id="GOGS"><a href="#GOGS" class="headerlink" title="GOGS"></a>GOGS</h3><p><a href="https://gogs.io/">GOGS</a>，用来搭建自用的 Git 服务，类似于一个轻量级的 GitHub。</p><p><img src="https://i.loli.net/2020/07/24/rcuLDzs47PATy2k.png" alt="git.liqilinhub.cloud.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>就到这里，现在的我总是羡慕过去的自己，做着自己喜欢的事，有很多时间去做。希望未来的我也将保持这种好奇心，什么事总要去尝试一番。</p><article class="message message-immersive is-primary"><div class="message-body"><p>看到这篇文章的朋友，如果对上面提及的应用的使用和部署有疑问，欢迎在下面留言，也许我可以给你提供帮助。</p></div></article><article class="message message-immersive is-warning"><div class="message-body"><p>本文作者：KylinLee</p><p>本文链接：<a href="https://kylin.dev/2020/07/16/自省-细数那些曾经乐此不疲的事">https://kylin.dev/2020/07/16/自省-细数那些曾经乐此不疲的事</a></p><p>版权声明：本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p></div></article>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在成长的过程中不妨也回头看看当年的自己，这篇文章就来说一说我曾经乐此不疲但又没什么用处的事，简称瞎折腾。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Life" scheme="https://kylin.dev/categories/Life/"/>
    
    
      <category term="Other" scheme="https://kylin.dev/tags/Other/"/>
    
      <category term="Essay" scheme="https://kylin.dev/tags/Essay/"/>
    
  </entry>
  
  <entry>
    <title>数据结构：树</title>
    <link href="https://kylin.dev/2020/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91/"/>
    <id>https://kylin.dev/2020/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91/</id>
    <published>2020-07-12T10:54:55.000Z</published>
    <updated>2020-10-19T12:08:03.013Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>树（Tree）是一种抽象数据类型或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。这篇文章主要介绍树的相关概念、性质及数学推论。</p><a id="more"></a><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>树是由 n（n≥0）个有限结点组成一个具有层次关系的集合，当 n=0 时，称这棵树为空树。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下性质：</p><ul><li>每个结点都只有有限个子结点或无子结点</li><li>没有父结点的结点称为根结点</li><li>每一个非根结点有且只有一个父结点</li><li>除了根结点外，每个子结点可以分为多个不相交的子树</li><li>树里面没有环路(cycle)</li></ul><h1 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h1><p>在学习树的过程中，你可能会遇到以下名词：<br><strong>理解这些词应该优先从树或子树的角度出发。</strong></p><ul><li><strong>结点</strong><br>树中的一个独立单元，之前我们说了，树是一个集合，结点就是这个集合中的一个元素。</li><li><strong>结点的度</strong><br>结点拥有的子树数称为结点的度。</li><li><strong>树的度</strong><br>树的度是树内各结点度的最大值。</li><li><strong>叶子（叶子结点）</strong><br>度为 0 的结点称为叶子或终端结点。</li><li><strong>非终端结点（分支结点）</strong><br>度不为 0 的结点称为非终端结点或分支结点。除根结点之外，非终端结点也称为内部结点。</li><li><strong>双亲（双亲结点）、孩子（孩子结点）</strong><br>结点的子树的根称为该结点的孩子，相应地，该结点称为孩子的双亲。</li><li><strong>兄弟（结点）</strong><br>同一个双亲的孩子之间互称兄弟。</li><li><strong>祖先（祖先结点）</strong><br>从根到该结点所经分支上的所有结点。</li><li><strong>子孙（子孙结点）</strong><br>以某结点为根的子树中的任一结点都称为该结点的子孙。</li><li><strong>层次</strong><br>结点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中任一结点的层次等千其双亲结点的层次加 1。</li><li><strong>堂兄弟（堂兄弟结点）</strong><br>双亲在同一层的结点互为堂兄弟。</li><li><strong>树的深度、树的高度</strong><br>树的深度或高度数值上等于树中结点的最大层次，深度以根结点为 1 向叶子结点递增，高度以叶子结点为 1 向根结点递增。</li><li><strong>结点的深度、结点的高度</strong><br>结点的深度或高度数值上等于以该结点为根结点的子树的最大层次，深度以目标结点为 1 向叶子结点递增，高度以叶子结点为 1 向目标结点递增。</li><li><strong>有序树和无序树</strong><br>如果将树中结点的各子树看成从左至右是有次序的（即不能互换），则称该树为有序树，否则称为无序树。在有序树中最左边的子树的根称为第一个孩子，最右边的称为最后一个孩子。</li><li><strong>森林</strong><br>m (m≥0)棵互不相交的树的集合。</li><li><strong>路径</strong><br>两个结点之间经过的结点序列，路径的方向为子结点指向子结点（自上而下）。</li><li><strong>路径长度</strong><br>一条路径中经过的边的条数。</li><li><strong>n 叉树</strong><br>一棵树中允许结点拥有子树的最大数目，如二叉树允许一个结点最多可拥有两个子树。</li></ul><h1 id="形象描述"><a href="#形象描述" class="headerlink" title="形象描述"></a>形象描述</h1><p>为了便于更形象的理解二叉树，我们可以用图形来表示树，通常用圆形表示一个结点，用线段表示结点之间的关系，下面的图中因为某些限制，结点之间的连接是折线，事实上用直线来连接更好一点，此外，连接是具有方向性的，为父结点指向子结点，你可以使用箭头线段来连接，一棵树看起来是这样的：</p><p><img src="https://i.loli.net/2020/10/01/OFgvi1Lhw5Bea6C.png" alt="tree.png"></p><p>这棵树有 7 个结点，1 结点的度为 2，2 结点的度为 3，3 结点的度为 1，其他结点（4,5,6,7）的度为 0，这些度为 0 结点被称为叶子结点，其他结点为非终端结点（他们的度不为 0），整棵树的度为 3，深度也为 3。</p><h1 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h1><p>树的存储可以使用顺序存储或链式存储实现，顺序存储结构不是很灵活，通常用于储存特定的 M 叉树，如二叉树的存储可以使用顺序存储。最通用的方式是使用链式存储。无论哪种存储结构，其每个结点的结构都是相似的，都有数据区和指针区，因为一个结点可以有很多孩子结点，所以指针区相对于链表要复杂一点，如果说链表的每一个结点的指针域都指向空或者唯一的结点，而树中每一个结点的指针指向多少结点是不确定的。</p><h2 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h2><p>一个结点可能没有孩子结点，但一定有一个唯一的双亲结点（除根节点外），利用这个方式可以很快的找到双亲结点。但是如果仅仅是这样表示，只能连接两个结点，要表示一棵完整的树还需要指针将所有节点连接起来，最简单的方式是利用顺序存储结构，可以避免手动创建指针，当然，你也可以利用链表将他们连起来。<br><img src="https://i.loli.net/2020/10/19/WLvg9IZ1k3CNfP6.png" alt="parent-tree.png"><br>这种方法能方便的找到父节点，但要找到兄弟节点和孩子节点比较复杂。</p><h2 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h2><p>树的孩子表示法通过线性表来实现，首先将每个结点存入顺序表中，顺序表的每一个结点除了保存树中每个结点的信息，还包含一个指针域，指向该结点的直接子元素构成的链表。</p><p><img src="https://i.loli.net/2020/10/19/f9NTdtKJk73RXr2.png" alt="parent-child-tree.png"><br>这种方法可以很快的找到某个节点的孩子节点，但找到兄弟节点比较困难。</p><h2 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h2><p>孩子兄弟表示法完全采用链表实现，在链表的每一个节点中，有三个域，分别为孩子指针域、数据域、兄弟指针域，逻辑结构如下：<br><img src="https://i.loli.net/2020/10/19/Pti8RWGKyngJFDO.png" alt="child-brother-tree.png"><br>这种表示方法可以很轻松的查找兄弟很孩子节点，但查找父节点比较麻烦。</p><h1 id="树的相关推论"><a href="#树的相关推论" class="headerlink" title="树的相关推论"></a>树的相关推论</h1><h2 id="结点拥有的结点数为所有结点的度数-1"><a href="#结点拥有的结点数为所有结点的度数-1" class="headerlink" title="结点拥有的结点数为所有结点的度数+1"></a>结点拥有的结点数为所有结点的度数+1</h2><h3 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h3><p><code>由结点的度和孩子结点的概念可得，结点的度数=该结点孩子结点的个数</code></p><p><code>∵ 除根结点外其余结点都可以作为孩子结点</code></p><p><code>∴ 树的结点总数=孩子结点总数+根结点数=所有结点的度数+根结点数=所有结点的度数+1</code></p><h2 id="一棵有-n-个结点的树有-n-1-条边（结点之间的连线）"><a href="#一棵有-n-个结点的树有-n-1-条边（结点之间的连线）" class="headerlink" title="一棵有 n 个结点的树有 n-1 条边（结点之间的连线）"></a>一棵有 n 个结点的树有 n-1 条边（结点之间的连线）</h2><h3 id="证明：-1"><a href="#证明：-1" class="headerlink" title="证明："></a>证明：</h3><p><code>∵ 树中除根结点外每个结点都有一个父结点，即这些结点都有一条线与父结点连接</code></p><p><code>∴ 边的数目为结点数减去根结点数 1</code></p><h2 id="度为-m-的树中第-i-层最多有-mi-1个结点（i≥1）"><a href="#度为-m-的树中第-i-层最多有-mi-1个结点（i≥1）" class="headerlink" title="度为 m 的树中第 i 层最多有 mi-1个结点（i≥1）"></a>度为 m 的树中第 i 层最多有 m<sup>i-1</sup>个结点（i≥1）</h2><h3 id="证明：-2"><a href="#证明：-2" class="headerlink" title="证明："></a>证明：</h3><p><code>若考虑最多的情况，则每一个结点的度都为 m，即每一个结点都有 m 个孩子结点，即第 i 层的每一个结点在第 i+1 层都会产生 m 个孩子结点。</code></p><p><code>设</code>N(i)<code>为第 i 层的结点数，第 i+1 层结点数可表示为</code> N(i)×m</p><p><code>∵</code>N(i)<code>的个数为</code>N(i-1)×m，<code>可得</code> N(i+1)=N(i-1)×m×m</p><p><code>依次进行如上的转化，可得到</code>N(i+1)=N(i-n)×m<sup>n+1</sup></p><p><code>即</code> N(i)=N(i-n)×m<sup>n</sup></p><p><code>这是一个通式，知道任意一层结点的个数即可推出其他层结点的个数，最好考虑的是第一层</code></p><p><code>∵</code> N(1)=1</p><p><code>∴ 将上面的 i-n 化为 1</code></p><p><code>可得</code>N(i)=N(1)×m<sup>i-1</sup></p><p><code>∴ 度为 m 的树中第 i 层最多有</code>m<sup>i-1</sup><code>个结点</code></p><h3 id="代码验证："><a href="#代码验证：" class="headerlink" title="代码验证："></a>代码验证：</h3><figure class="highlight go"><figcaption><span>Golang</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">degree：树的度</span></span><br><span class="line"><span class="comment">level：层序数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getNodeNum</span><span class="params">(degree, level <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> level != <span class="number">1</span> &#123;</span><br><span class="line">        level--</span><br><span class="line">        <span class="keyword">return</span> getNodeNum(degree, level)*degree</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> degree, level <span class="keyword">int</span></span><br><span class="line">    fmt.Printf(<span class="string">"请输入树的度\n"</span>)</span><br><span class="line">    fmt.Scan(&amp;degree)</span><br><span class="line">    fmt.Printf(<span class="string">"请输入层序数\n"</span>)</span><br><span class="line">    fmt.Scan(&amp;level)</span><br><span class="line">    nodeNum := getNodeNum(degree, level)</span><br><span class="line">    fmt.Printf(<span class="string">"度为%d的树中第%d层最多有%d个结点\n"</span>, degree, level, nodeNum)</span><br><span class="line">    main()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的数学证明过程中你应该就想到了用递归的方式实现，代码也是这样做的，让我们检验一下:</p><figure class="highlight powershell"><figcaption><span>点击展开 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">请输入树的度</span><br><span class="line"><span class="number">2</span></span><br><span class="line">请输入层序数</span><br><span class="line"><span class="number">9</span></span><br><span class="line">度为 <span class="number">2</span> 的树中第 <span class="number">9</span> 层最多有 <span class="number">256</span> 个结点</span><br><span class="line">请输入树的度</span><br><span class="line"><span class="number">3</span></span><br><span class="line">请输入层序数</span><br><span class="line"><span class="number">4</span></span><br><span class="line">度为 <span class="number">3</span> 的树中第 <span class="number">4</span> 层最多有 <span class="number">27</span> 个结点</span><br></pre></td></tr></table></figure><p>根据检验，2<sup>9-1</sup>=256，3<sup>4-1</sup>=27，再次证明度为 m 的树中第 i 层最多有 m<sup>i-1</sup>个结点。</p><p>顺便提一句，当度为 2 时，讨论极限条件，这棵树是满二叉树，根据这个结论可以得出它的性质：第 i 层有 2<sup>i-1</sup>个结点，这在以后的文章中便不做推导了。</p><h2 id="高度为-h-的-m-叉树至多有-mh-1-÷-m-1-个结点"><a href="#高度为-h-的-m-叉树至多有-mh-1-÷-m-1-个结点" class="headerlink" title="高度为 h 的 m 叉树至多有 (mh-1)÷(m-1)个结点"></a>高度为 h 的 m 叉树至多有 (m<sup>h</sup>-1)÷(m-1)个结点</h2><p>这个推论接着上一条结论继续往下推，高度为 h 实际上是告诉了我们这棵树的层数，考虑至多的极限情况，m 就是上一条结论中的度，实际上证明这个推论只需要将每一层的结点数求和，首先将每一层的结点数构造成等比数列，再按等比求和公式求和：</p><h3 id="证明：-3"><a href="#证明：-3" class="headerlink" title="证明："></a>证明：</h3><p><code>考虑最多情况，m 叉树的每一个结点都会在下一层产生 m 个结点</code></p><p><code>设</code>N(h)<code>为第 h 层的结点数，第 h+1 层结点数可表示为</code> N(h)×m</p><p><code>设数列</code>{a<sub>h</sub>}，a<sub>1</sub>=N(1)，a<sub>2</sub>=N(2)，a<sub>h</sub>=N(h)，a<sub>h+1</sub>=N(h+1) (h≥1)</p><p><code>由条件可知</code>a<sub>1</sub>=N(1)=1</p><p><code>∵</code>a<sub>h+1</sub>÷a<sub>h</sub>=N(h+1)÷N(h)=m，<code>h≥2</code></p><p><code>根据定义，数列</code>{a<sub>h</sub>}<code>是以首项为1，公比为m(m&gt;0)的等比数列</code></p><p><code>设数列</code>{a<sub>h</sub>}<code>的前n项和为</code>S<sub>h</sub></p><p><code>由求和公式</code></p><p>$$<br>S_n=\frac{a_1\times(1-q^n)}{1-q}, (q\neq1)<br>$$</p><p>a<sub>1</sub>=1，q=m，m≠1，n=h</p><p><code>可得</code></p><p>$$<br>S_n=\frac{(1-m^h)}{1-m}<br>$$</p><h2 id="具有-n-个结点的满-m-叉树的最小高度为-logm-n-m-1-1"><a href="#具有-n-个结点的满-m-叉树的最小高度为-logm-n-m-1-1" class="headerlink" title="具有 n 个结点的满 m 叉树的最小高度为 logm(n(m-1)+1)"></a>具有 n 个结点的满 m 叉树的最小高度为 log<sub>m</sub>(n(m-1)+1)</h2><h3 id="证明：-4"><a href="#证明：-4" class="headerlink" title="证明："></a>证明：</h3><p>考虑极限条件，要求得最小高度，就需要将每一层填满，之前我们已经证明了 m 叉树每一层的最大结点数，这其实是上一个结论的逆向问题，同样的先将每一层的结点数构造成数列，转换为数学问题就是已知通项公式，前 h 项和，求 h 的值，这个证明这个结论需要做的就是得出通项公式和前 h 项和，通项公式在证明上一个结论时已经得出，进而可以得出前 h 项的和为</p><p>$$<br>S_h=\frac{(1-m^h)}{1-m}<br>$$</p><p>令 S<sub>h</sub>=n 反解出 h</p><p>$$<br>h=\log_m{(n(m-1)+1)}<br>$$</p><article class="message message-immersive is-warning"><div class="message-body"><p>本文作者：KylinLee</p><p>本文链接：<a href="https://kylin.dev/2020/07/12/数据结构：树">https://kylin.dev/2020/07/12/数据结构：树</a></p><p>版权声明：本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p></div></article>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;树（Tree）是一种抽象数据类型或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。这篇文章主要介绍树的相关概念、性质及数学推论。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Code" scheme="https://kylin.dev/categories/Code/"/>
    
    
      <category term="Concept" scheme="https://kylin.dev/tags/Concept/"/>
    
      <category term="DataStructure" scheme="https://kylin.dev/tags/DataStructure/"/>
    
  </entry>
  
  <entry>
    <title>在Vue中使用GraphQL</title>
    <link href="https://kylin.dev/2020/07/10/%E5%9C%A8Vue%E4%B8%AD%E4%BD%BF%E7%94%A8GraphQL/"/>
    <id>https://kylin.dev/2020/07/10/%E5%9C%A8Vue%E4%B8%AD%E4%BD%BF%E7%94%A8GraphQL/</id>
    <published>2020-07-10T03:51:15.000Z</published>
    <updated>2020-07-12T11:13:51.493Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本文帮助你在 Vue 中使用 GraphQL，也许你尝试使用过<a href="https://github.com/axios/axios">axios</a>，不得不说 axios 并不适合用来发送 GraphQL API 请求，本文介绍一种更简单的方式并且带你上手。如果你对 GraphQL 后端感兴趣可以阅读我的上一篇文章《<a href="/2020/07/07/Apollo-GraphQL%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E6%9C%8D%E5%8A%A1%E7%AB%AF/" title="Apollo-GraphQL快速上手-服务端">Apollo-GraphQL快速上手-服务端</a>》。</p><a id="more"></a><p>官方维护的 Apollo Client 是 React 编写的，我使用的是 Vue，虽然说是由社区维护，但 API 基本是按照 React 版本的来写的，用起来障碍也不大。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>社区维护的 Vue 版本的 Apollo Client 叫<a href="https://apollo.vuejs.org/">vue-apollo</a>，安装也相当简单，首先使用 Vue Cli 创建一个项目，然后在项目文件夹运行命令：<code>vue add apollo</code>。</p><p>由于有<a href="https://apollo.vuejs.org/">中文文档</a>，我就取其精要，带大家简单上手，更高级的操作，大家可以去网站上看一看。<strong>本文的逻辑和文档大不相同，如果你理解本文的思路，你将可以更灵活的操作 GraphQL 请求</strong></p><h1 id="apollo-对象"><a href="#apollo-对象" class="headerlink" title="apollo 对象"></a>apollo 对象</h1><p><strong><code>apollo</code>对象是 apollo-vue 的核心，无论是查询还是变更，只要向可接受<code>apollo</code>对象的地方传入它就可以完成 GraphQL 的查询与变更。</strong>常用的属性和方法有四个：<code>query</code>、<code>variables</code>、<code>mutation</code>、<code>update()</code>，看起来应该是这样的：</p><figure class="highlight javascript"><figcaption><span>template.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apolloObj: &#123;</span><br><span class="line">    query: gql<span class="string">`</span></span><br><span class="line"><span class="string">        query&#123;&#125;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">    mutation: gql<span class="string">`</span></span><br><span class="line"><span class="string">        mutation&#123;&#125;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">    variables: &#123;</span><br><span class="line">        var1: <span class="keyword">this</span>.data.name</span><br><span class="line">    &#125;,</span><br><span class="line">    update()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>query</code>：GraphQL 查询代码</li><li><code>mutation</code>：GraphQL 变更代码</li><li><code>variables</code>：GraphQL 代码中不能使用 js 的变量，<code>variables</code>相当于转换器，将 js 代码转换为 GraphQL 代码并使用，在 GraphQL 中，使用<code>$标识符</code>引用变量。</li><li><code>update()</code>：一个回调函数，当 GraphQL 请求有了返回值之后的下一步操作</li></ul><h1 id="请求发送时机"><a href="#请求发送时机" class="headerlink" title="请求发送时机"></a>请求发送时机</h1><p>前面说了只要向可接受<code>apollo</code>对象的地方传入它就可以完成 GraphQL 的查询与变更，所以我们讨论以下两种请求发送的时机。</p><h2 id="组件实例化时"><a href="#组件实例化时" class="headerlink" title="组件实例化时"></a>组件实例化时</h2><p>这个方案是将<code>apollo</code>对象传入组件中名为<code>apollo</code>的对象中，然后在组件实例化的过程中自动完成 GraphQL 请求，这种方案常用于 query，而且示例也是这样做的，其实你也可以进行 mutation，下面这个例子中有两个<code>apollo</code>对象：<code>books</code>和<code>delBooks</code>，分别进行了 query 和 mutation：</p><figure class="highlight javascript"><figcaption><span>template.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gql <span class="keyword">from</span> <span class="string">"graphql-tag"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            books: [],</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    apollo: &#123;</span><br><span class="line">        books: gql<span class="string">`</span></span><br><span class="line"><span class="string">            query &#123;</span></span><br><span class="line"><span class="string">                books &#123;</span></span><br><span class="line"><span class="string">                    title</span></span><br><span class="line"><span class="string">                    author</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        `</span>,</span><br><span class="line">        delBooks: &#123;</span><br><span class="line">            mutation: gql<span class="string">`</span></span><br><span class="line"><span class="string">                mutation &#123;</span></span><br><span class="line"><span class="string">                    id: 1</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            `</span>,</span><br><span class="line">            update(res) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(res);</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>apollo</code>对象中创建一个与<code>data</code>对象属性同名的属性，<code>apollo</code>会自动将获得的数据挂载到<code>data</code>对象。如上面这段代码<code>apollo</code>对象中的<code>books</code>属性，只需要在<code>data</code>中注册就能自动拿到请求的结果。</p><p><em>如果你的<code>apollo</code>对象中只有<code>query</code>或者只需要<code>mutation</code>，就可以像上面<code>books</code>对象中那样写，只需要将 gql 构造出的代码作为属性的值就行了。</em></p><p><em>TIPS：除了在 js 使用 gql 构造 GraphQL 查询代码，也可以将 GraphQL 查询代码写入<code>.gql</code>文件，在 js 中引用。</em></p><h2 id="手动发送请求"><a href="#手动发送请求" class="headerlink" title="手动发送请求"></a>手动发送请求</h2><p>你可以使用<code>this.$apollo.mutate()</code>方法来发送 GraphQL 请求，它不会自动调用，所以更加灵活，你可以将它放在方法甚至是生命周期中，完全由你控制，它接受 apollo 对象作为参数，使用起来大概是这样的：</p><figure class="highlight javascript"><figcaption><span>template.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gql <span class="keyword">from</span> <span class="string">"graphql-tag"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">        check() &#123;</span><br><span class="line">            <span class="keyword">this</span>.$apollo.mutate(&#123;</span><br><span class="line">                query: gql<span class="string">`</span></span><br><span class="line"><span class="string">                    query &#123;</span></span><br><span class="line"><span class="string">                        books &#123;</span></span><br><span class="line"><span class="string">                            title</span></span><br><span class="line"><span class="string">                        &#125;</span></span><br><span class="line"><span class="string">                    &#125;</span></span><br><span class="line"><span class="string">                `</span>,</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上就是我对 vue-apollo 的使用小结，使用和文档完全不同的思路完全是我的个人理解，如果有不同的见解希望大家留言评论。</p><article class="message message-immersive is-warning"><div class="message-body"><p>本文作者：KylinLee</p><p>本文链接：<a href="https://kylin.dev/2020/07/10/在Vue中使用GraphQL">https://kylin.dev/2020/07/10/在Vue中使用GraphQL</a></p><p>版权声明：本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p></div></article>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文帮助你在 Vue 中使用 GraphQL，也许你尝试使用过&lt;a href=&quot;https://github.com/axios/axios&quot;&gt;axios&lt;/a&gt;，不得不说 axios 并不适合用来发送 GraphQL API 请求，本文介绍一种更简单的方式并且带你上手。如果你对 GraphQL 后端感兴趣可以阅读我的上一篇文章《&lt;a href=&quot;/2020/07/07/Apollo-GraphQL%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E6%9C%8D%E5%8A%A1%E7%AB%AF/&quot; title=&quot;Apollo-GraphQL快速上手-服务端&quot;&gt;Apollo-GraphQL快速上手-服务端&lt;/a&gt;》。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Code" scheme="https://kylin.dev/categories/Code/"/>
    
      <category term="Frontend" scheme="https://kylin.dev/categories/Code/Frontend/"/>
    
    
      <category term="JavaScript" scheme="https://kylin.dev/tags/JavaScript/"/>
    
      <category term="GraphQL" scheme="https://kylin.dev/tags/GraphQL/"/>
    
  </entry>
  
  <entry>
    <title>Apollo-GraphQL快速上手-服务端</title>
    <link href="https://kylin.dev/2020/07/07/Apollo-GraphQL%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    <id>https://kylin.dev/2020/07/07/Apollo-GraphQL%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E6%9C%8D%E5%8A%A1%E7%AB%AF/</id>
    <published>2020-07-07T10:06:26.000Z</published>
    <updated>2020-07-13T06:00:16.790Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>上次课程设计做完之后就放松了一阵子，过了这么久才来更新博客其实内心是不好受的，感觉生活缺少了什么。GraphQL 出现了很多年，一直不温不火，想尝试 GraphQL 服务器开发的朋友们可以参考一下本文，你将理解到一种 GraphQL 服务器的通用逻辑。</p><div class="message message-immersive is-warning"><div class="message-body"><p>本文假设你对GraphQL有一定的了解。</p></div></div><a id="more"></a><p><a href="https://www.apollographql.com/docs/apollo-server/">Apollo Server</a> 是以 Node 为后端的 GraphQL 实现，我选择 Apollo 是因为它是一套完整的服务框架，它包括前端和后端，可拓展性强，并且 Node 也是后端开发最快的方式。</p><p>我不喜欢贴代码，我会从 0 开始搭建一个普通的 web 服务器，从创建一个 GraphQL 的 mock Server 来说明 Apollo Server 的运行逻辑，其实 GraphQL 服务器的运行逻辑也大致如此，最后接入数据库，更接近实战。</p><h1 id="基本服务器监听"><a href="#基本服务器监听" class="headerlink" title="基本服务器监听"></a>基本服务器监听</h1><p><em>本节为搭建基础服务器而不是 GraphQL 服务器，熟练的朋友可跳过。</em></p><p>Apollo Server 可作为一个独立的服务器，我们可以安装 Apollo 后直接启动服务器监听，但功能它的只限于对数据的增删改查，一个服务器可能还需要如下功能：</p><ul><li>模板渲染或 SSR</li><li>身份验证</li><li>文件上传</li><li>…</li></ul><p>为了便于拓展业务功能，我将 Apollo Server 作为 Node 服务器的中间件，你可以选择你喜欢的 Node 服务器框架，或者自己搭建 Node 服务器，我选择的是 <a href="https://www.koajs.com.cn/">Koa</a>，接下来开始搭建整体架构：</p><h2 id="安装-Koa-和-Apollo-Server"><a href="#安装-Koa-和-Apollo-Server" class="headerlink" title="安装 Koa 和 Apollo Server"></a>安装 Koa 和 Apollo Server</h2><figure class="highlight powershell"><figcaption><span>PowerShell</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i koa<span class="literal">-generator</span> <span class="literal">-g</span></span><br><span class="line">koa2 项目名</span><br></pre></td></tr></table></figure><p>生成的目录如下，长的很像 MVC 架构：<br><img src="https://i.loli.net/2020/07/07/6jbzi9kqFVEJWB3.png" alt="origin-dir.png"><br><code>app.js</code> 里引入了必备的库并初始化和定义路由，最终由 <code>bin/www</code> 引用并真正将他们使用起来。</p><p>接下来安装依赖，除了 koa-generator 生成的依赖，还需要安装<code>apollo-server-koa</code>和<code>graphql</code>，这样将 Apollo Server 作为中间件，如果你使用其他 Node 服务器，可以在<a href="https://www.apollographql.com/docs/apollo-server/integrations/middleware/">这里</a>找到适合的中间件。</p><h2 id="开发建议"><a href="#开发建议" class="headerlink" title="开发建议"></a>开发建议</h2><p>每次编辑代码之后查看更改必须要重新启动服务器，koa-generator 自动为我们安装<code>nodemon</code>，它能监听工作区的文件更改，进行热更新。这样的话，你需要将<code>bin/www</code>文件改为<code>bin/www.js</code>，因为<code>nodemon</code>不会监听没有后缀名文件的更改。</p><p>安装依赖后最后使用<code>npm run dev</code>就能启动服务器了，默认端口为 3000，你可以通过<code>localhost:3000</code>访问。</p><h1 id="简单的-GraphQL-服务"><a href="#简单的-GraphQL-服务" class="headerlink" title="简单的 GraphQL 服务"></a>简单的 GraphQL 服务</h1><p><strong>为了方便大家理解本节内容，写这篇博客的时候我也亲自做了一遍，你可以 clone<a href="https://github.com/KylinLee/koa-apollo-template/tree/mock">我的仓库</a>，切换到 mock 分支查看。</strong></p><figure class="highlight bash"><figcaption><span>GitBash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/KylinLee/koa-apollo-template.git</span><br><span class="line">git checkout mock</span><br></pre></td></tr></table></figure><p>Apollo GraphQL 由以下部分组成：</p><ul><li>Schema：图、结构</li><li>Data：数据源</li><li>Resolver：解析器</li></ul><p>为了便于理解，先模拟一个查询书籍相关信息的 GraphQL 服务器：</p><h2 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h2><p>Schema 相当于接口（指 API 接口），定义了客户端可以执行的操作类型，数据结构体，数据字段及类型。在 MVC 架构中，相当于模型，我的理解 Schema 是数据的入口和出口，一个请求传过来首先通过 Schema 校验，响应内容最终也会以 Schema 定义的格式返回，相当于一个模具，固定数据进出的格式。<br>所以新建一个<code>model/schema</code>目录，在目录中建立 Schema 并将其导出备用：</p><figure class="highlight javascript"><figcaption><span>model/schema/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; gql &#125; = <span class="built_in">require</span>(<span class="string">"apollo-server-koa"</span>);</span><br><span class="line"><span class="keyword">const</span> typeDefs = gql<span class="string">`</span></span><br><span class="line"><span class="string">    type Book &#123;</span></span><br><span class="line"><span class="string">        title: String</span></span><br><span class="line"><span class="string">        author: String</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    type Query &#123;</span></span><br><span class="line"><span class="string">        books: [Book]</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = typeDefs;</span><br></pre></td></tr></table></figure><p>GraphQL 中文文档中将类似于上面 <code>Book</code> 的结构叫做“<strong>类型</strong>”，但我认为对于编程人员将它们叫做“<strong>结构体</strong>”更容易理解。</p><h2 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h2><p>数据比较容易理解，客户端需要的内容，服务器可返回的内容就是数据。为了简化流程，便于理解，我们选择使用模拟数据，可以新建<code>data</code>目录，将模拟数据放在这里并导出备用：</p><figure class="highlight javascript"><figcaption><span>data/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> books = [</span><br><span class="line">    &#123;</span><br><span class="line">        title: <span class="string">"Harry Potter and the Chamber of Secrets"</span>,</span><br><span class="line">        author: <span class="string">"J.K. Rowling"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        title: <span class="string">"Jurassic Park"</span>,</span><br><span class="line">        author: <span class="string">"Michael Crichton"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="built_in">module</span>.exports = books;</span><br></pre></td></tr></table></figure><h2 id="Resolver"><a href="#Resolver" class="headerlink" title="Resolver"></a>Resolver</h2><p>解析器的作用是将 Schema 和 Data 联系在一起，即根据客户端传来的查询语句在一大堆 Data 里边找到指定的数据，如果说放在 MVC 里边，可以作为控制器，也可以作为模型，看个人如何理解，其实 MVC 没有很严格的界定，如果你的 Resolver 除了查询数据还具有其他复杂的功能，将其定义为控制器比较合适，如果你的 Resolver 专门用于数据的查询，将其作为模型看待。我将 Resolver 放在<code>model/resolver</code>目录下。</p><p>现在我们可以分析一下，查询<code>Books</code>，需要返回一个数组，数组的每一项需要符合<code>Book</code>的结构，即每一项需要包含<code>title</code>和<code>author</code>字段，巧的是我们模拟的数据<code>book</code>正好符合<code>Books</code>的结构。</p><p><strong>在开发中，这个分析很重要，请不要忽略！！！</strong></p><p>所以我们的 Resolver 这样写：</p><figure class="highlight javascript"><figcaption><span>model/resolver/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> books = <span class="built_in">require</span>(<span class="string">"../../data/index.js"</span>);</span><br><span class="line"><span class="keyword">const</span> resolvers = &#123;</span><br><span class="line">    Query: &#123;</span><br><span class="line">        books: <span class="function"><span class="params">()</span> =&gt;</span> books,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = resolvers;</span><br></pre></td></tr></table></figure><p>为 Schema 中对应的结构体编写同名的函数，并将这些函数作为<code>resolvers</code>对象的键和值，导出<code>resolvers</code>备用。</p><h3 id="Resolver-进阶"><a href="#Resolver-进阶" class="headerlink" title="Resolver 进阶"></a>Resolver 进阶</h3><p>其实你只编写了 Query 中 books 的解析器，books 是以 Book 为单元的数组，但我们并没有编写 Book 结构体的解析器，它还是返回了我们预期的结果。实际上 Apollo 并不是<code>data</code>是什么就返回什么，将<code>data</code>中的<code>author</code>改为<code>authors</code>，只会返回<code>title</code>字段内容。默认情况下，如果你没有编写某个结构体的解析器，Apollo 将会使用默认解析器，它会根据 books 的结果去验证里边的某一项是否符合 Book 解析器，最终返回符合 Book 的结果，起到了过滤的效果，了解默认解析器可以帮助你少编写代码。</p><h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><p>将三部分准备其了，接下来将这三部分接入服务器，供服务器调用，首先在<code>www.js</code>这个执行文件中引入这三部分，然后将他们作为选项传入 Apollo Server，最后将 Apollo Server 作为 Koa 中间件，<strong>关键代码</strong>如下：</p><figure class="highlight javascript"><figcaption><span>bin/www.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">"../app.js"</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; ApolloServer &#125; = <span class="built_in">require</span>(<span class="string">"apollo-server-koa"</span>);</span><br><span class="line"><span class="keyword">const</span> typeDefs = <span class="built_in">require</span>(<span class="string">"../model/schema/index.js"</span>);</span><br><span class="line"><span class="keyword">const</span> resolvers = <span class="built_in">require</span>(<span class="string">"../model/resolver/index.js"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造Apollo Server;</span></span><br><span class="line"><span class="keyword">const</span> server = <span class="keyword">new</span> ApolloServer(&#123;</span><br><span class="line">    typeDefs,</span><br><span class="line">    resolvers,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将server作为中间件</span></span><br><span class="line">server.applyMiddleware(&#123; app &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动监听，注意将原来的server改为app</span></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">    cosneole.log(<span class="string">"please open localhost:3000/graphql"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>打开<code>localhost:3000/graphql</code>，进行 GraphQL 查询，GraphQL 基础这里就不讲了，既然决定用 Apollo Server 相信大家都会，测试如下：<br><img src="https://i.loli.net/2020/07/09/TLayrYwQmhIBKp6.png" alt="test-graphql.png"></p><h1 id="使用-MySQL-作为数据源"><a href="#使用-MySQL-作为数据源" class="headerlink" title="使用 MySQL 作为数据源"></a>使用 MySQL 作为数据源</h1><p><strong>便于大家理解本节，你可以 clone<a href="https://github.com/KylinLee/koa-apollo-template/tree/mysql">我的仓库</a>，切换到 mysql 分支查看。</strong></p><figure class="highlight bash"><figcaption><span>GitBash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/KylinLee/koa-apollo-template.git</span><br><span class="line">git checkout mysql</span><br></pre></td></tr></table></figure><p>通过上面的讲解你已经理解 Apollo Server 的开发流程了吧，上面这个例子中使用的是模拟的数据，是固定不变的，接下来是重头戏——接入数据库。</p><p>我是用的是 MySQL，按照官方文档，可以使用的数据源有数据库和 RESTful API，支持 RESTful API 的原因是帮助使用 RESTful API 的服务迁移到 GraphQL，我使用关系型数据库 MySQL 作为数据源。</p><p>上面的例子中我们向 <code>ApolloServer</code> 构造函数传递了一个配置对象，这个配置对象包含了两个内容<code>typeDefs</code>和<code>resolvers</code>。其中数据源是在 resolver 中引入的，我们也可以将数据源传入 <code>ApolloServer</code> 构造函数，在 <code>ApolloServer</code> 实例化的时候就初始化连接数据库，我们使用 Apollo 社区维护的数据源工具<a href="https://github.com/cvburgess/SQLDataSource">datasource-sql</a>，它是基于<a href="http://knexjs.org/">knex</a>的，<code>knex</code>是一个查询构造器，通过<code>knex</code>我们可以用熟悉的 JavaScript 语法去执行 SQL 查询，<code>datasource-sql</code>的工作是将<code>knex</code>包装成<code>ApolloServer</code>构造函数可接受的对象，让我们先安装它：</p><figure class="highlight powershell"><figcaption><span>PowerShell</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i datasource<span class="literal">-sql</span> mysql -<span class="literal">-save</span></span><br></pre></td></tr></table></figure><p>然后我们需要做三部分的更改：</p><ol><li>配置数据库并实例化数据源工具</li><li>将数据源实例传入<code>ApolloServer</code></li><li>在 resolver 中使用数据源</li></ol><h2 id="配置数据库并实例化数据源工具"><a href="#配置数据库并实例化数据源工具" class="headerlink" title="配置数据库并实例化数据源工具"></a>配置数据库并实例化数据源工具</h2><p>首先配置数据库，在<code>data</code>文件夹创建<code>data/mysql.config.js</code>：</p><figure class="highlight javascript"><figcaption><span>mysql.config.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> knexConfig = &#123;</span><br><span class="line">    client: <span class="string">"mysql"</span>,</span><br><span class="line">    connection: &#123;</span><br><span class="line">        host: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">        port: <span class="number">3306</span>,</span><br><span class="line">        user: <span class="string">"root"</span>,</span><br><span class="line">        password: <span class="string">""</span>,</span><br><span class="line">        database: <span class="string">"Book"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后创建<code>data/methods.js</code>，这里边定义了数据库的操作方法供 resolver 调用，这些方法包含了你需要对数据库进行的所有操作，比如下面这段代码就是获取<code>books</code>表中的所有字段，相当于 SQL 语句:</p><figure class="highlight sql"><figcaption><span>SQL</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> books;</span><br></pre></td></tr></table></figure><p><strong>注意：使用 knex 查询器返回的是 Promise。</strong></p><figure class="highlight javascript"><figcaption><span>data/methods.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SQLDataSource &#125; = <span class="built_in">require</span>(<span class="string">"datasource-sql"</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FetchMethods</span> <span class="keyword">extends</span> <span class="title">SQLDataSource</span> </span>&#123;</span><br><span class="line">    getAllBooks() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.knex(<span class="string">"books"</span>)</span><br><span class="line">            .select(<span class="string">"*"</span>)</span><br><span class="line">            .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.table(res);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;)</span><br><span class="line">            .catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="number">0</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = FetchMethods;</span><br></pre></td></tr></table></figure><p>最终实例化数据库工具的逻辑是：将数据库配置对象传入包含数据库操作方法的类，如下：</p><figure class="highlight javascript"><figcaption><span>data/mysql.config.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyDatabase = <span class="built_in">require</span>(<span class="string">"./methods"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> knexConfig = &#123;</span><br><span class="line">    client: <span class="string">"mysql"</span>,</span><br><span class="line">    connection: &#123;</span><br><span class="line">        host: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">        port: <span class="number">3306</span>,</span><br><span class="line">        user: <span class="string">"root"</span>,</span><br><span class="line">        password: <span class="string">""</span>,</span><br><span class="line">        database: <span class="string">"Book"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db = <span class="keyword">new</span> MyDatabase(knexConfig);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = db;</span><br></pre></td></tr></table></figure><h2 id="将数据源实例传入ApolloServer"><a href="#将数据源实例传入ApolloServer" class="headerlink" title="将数据源实例传入ApolloServer"></a>将数据源实例传入<code>ApolloServer</code></h2><p>通过上面的实例化之后成为了<code>ApolloServer</code>构造函数可接受的数据源对象，对 ApolloServer 配置做如下更改：</p><figure class="highlight javascript"><figcaption><span>bin/www.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">"../app.js"</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; ApolloServer &#125; = <span class="built_in">require</span>(<span class="string">"apollo-server-koa"</span>);</span><br><span class="line"><span class="keyword">const</span> typeDefs = <span class="built_in">require</span>(<span class="string">"../model/schema/index.js"</span>);</span><br><span class="line"><span class="keyword">const</span> resolvers = <span class="built_in">require</span>(<span class="string">"../model/resolver/index.js"</span>);</span><br><span class="line"><span class="comment">// 引入数据源</span></span><br><span class="line"><span class="keyword">const</span> db = <span class="built_in">require</span>(<span class="string">"../data/mysql.config.js"</span>);</span><br><span class="line"><span class="comment">// 实例化 ApolloServer</span></span><br><span class="line"><span class="keyword">const</span> server = <span class="keyword">new</span> ApolloServer(&#123;</span><br><span class="line">    typeDefs,</span><br><span class="line">    resolvers,</span><br><span class="line">    dataSources: <span class="function"><span class="params">()</span> =&gt;</span> (&#123; db &#125;),</span><br><span class="line">    context: <span class="function">(<span class="params">app</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> method = app.ctx.method;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            method,</span><br><span class="line">            uid: <span class="string">"20202020"</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    tracing: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>关键代码是第 6 行和第 11 行。</p><h3 id="context-对象"><a href="#context-对象" class="headerlink" title="context 对象"></a>context 对象</h3><p>另外我往里边传了<code>context</code>对象，这是非必要的，有<code>context</code>对象之后我们可以在 resolver 中使用他们，如上面这段代码中返回了当前请求的方法和一个<code>uid</code>，我们在 resolver 里边就能使用这两个变量，具体怎么使用将在下一小节中阐述。<code>context</code>对象是很有用的，比如通过 JWT 验证请求者身份之后，可以将记录这个身份的信息传给 resolver，接着 resolver 将这个信息作为数据库查询参数。</p><h2 id="在-resolver-中使用数据源"><a href="#在-resolver-中使用数据源" class="headerlink" title="在 resolver 中使用数据源"></a>在 resolver 中使用数据源</h2><p>使用数据源就比较简单了，和我们之前写简单的 GraphQL 服务一样，在<code>model/resolver/index.js</code>中写 resolver 方法：</p><figure class="highlight javascript"><figcaption><span>model/resolver/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolvers = &#123;</span><br><span class="line">    Query: &#123;</span><br><span class="line">        <span class="keyword">async</span> books(_source, _args, &#123; dataSources &#125;) &#123;</span><br><span class="line">            <span class="keyword">return</span> dataSources.db.getAllBooks();</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = resolvers;</span><br></pre></td></tr></table></figure><p>通过前面的一系列构造，我们之前编写的数据库操作方法可以通过<code>dataSources.db</code>来访问，你可以使用<code>await</code>，也可以不使用，因为 resolver 的返回值可以是 Promise 对象，这主要取决于你的数据库操作方法是如何写的。</p><p>我们注意到每一个结构的<code>resolver</code>还有几个参数，resolver 可以接收四个参数，最常用的就是上面这段代码中写到的前三个参数。</p><h3 id="第一个参数parent"><a href="#第一个参数parent" class="headerlink" title="第一个参数parent"></a>第一个参数<code>parent</code></h3><p>上面的代码中是<code>_source</code>，代表上一级解析器的返回值，因为 Schema 中定义的结构体是可以嵌套的，所以出现了多级选择器的概念，GraphQL 的解析顺序是从最外层解析的，返回最外层的解析结果之后才进行下一级解析，我们可以通过这个参数获取上一级的返回值然后将这个值作为下一级的参数。</p><h3 id="第二个参数args"><a href="#第二个参数args" class="headerlink" title="第二个参数args"></a>第二个参数<code>args</code></h3><p>上面的代码中是<code>_args</code>，顾名思义是参数的意思，指 GraphQL 查询中传递的参数如：</p><figure class="highlight plain"><figcaption><span>GraphQL</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">    book(id: 10)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设这是查询 id 为 10 的书籍信息，那么 resolver 中可以这样写：</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolvers = &#123;</span><br><span class="line">    Query: &#123;</span><br><span class="line">        <span class="keyword">async</span> books(_source, _args, &#123; dataSources &#125;) &#123;</span><br><span class="line">            <span class="keyword">return</span> dataSources.db.getAllBooks(_args.id);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = resolvers;</span><br></pre></td></tr></table></figure><p>然后在数据库操作方法的函数中接收这个参数。</p><h3 id="第三个参数context"><a href="#第三个参数context" class="headerlink" title="第三个参数context"></a>第三个参数<code>context</code></h3><p>第三个参数是上下文，由此可见，构造器其实是将我们的数据源<code>db</code>放在了上下文之中，<code>dataSources.db</code>则是我们的数据源，还记得之前传入<code>ApolloServer</code>的配置文件吗，我传入了一个 context 对象，ApolloServer 将它作为<code>db</code>对象的一个属性，这一点我不清楚为什么要这么设计，访问配置文件中传入的<code>context</code>对象通过如下方式获取：</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolvers = &#123;</span><br><span class="line">    Query: &#123;</span><br><span class="line">        <span class="keyword">async</span> books(_source, _args, &#123; dataSources &#125;) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(dataSourses.db.context.uid); <span class="comment">// 20202020</span></span><br><span class="line">            <span class="keyword">return</span> dataSources.db.getAllBooks();</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果你从头看完，至此相信你已经从零入门了，以上讲述的内容已经足够你开发一个功能完善的 GraphQL 服务器了，此外，不理解的话可以去 Apollo GraphQL 的<a href="https://www.apollographql.com/">官方网站</a>看看。</p><p><em>如果你不想重复的配置项目，可以从<a href="https://github.com/KylinLee/koa-apollo-template">我的仓库</a>拉取代码初始化项目。</em></p><article class="message message-immersive is-warning"><div class="message-body"><p>本文作者：KylinLee</p><p>本文链接：<a href="https://kylin.dev/2020/07/07/Apollo-GraphQL快速上手-服务端/">https://kylin.dev/https://kylin.dev/2020/07/07/Apollo-GraphQL快速上手-服务端</a></p><p>版权声明：本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p></div></article>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上次课程设计做完之后就放松了一阵子，过了这么久才来更新博客其实内心是不好受的，感觉生活缺少了什么。GraphQL 出现了很多年，一直不温不火，想尝试 GraphQL 服务器开发的朋友们可以参考一下本文，你将理解到一种 GraphQL 服务器的通用逻辑。&lt;/p&gt;
&lt;div class=&quot;message message-immersive is-warning&quot;&gt;
&lt;div class=&quot;message-body&quot;&gt;
&lt;p&gt;本文假设你对GraphQL有一定的了解。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
    
    </summary>
    
    
      <category term="Code" scheme="https://kylin.dev/categories/Code/"/>
    
      <category term="Backend" scheme="https://kylin.dev/categories/Code/Backend/"/>
    
    
      <category term="JavaScript" scheme="https://kylin.dev/tags/JavaScript/"/>
    
      <category term="GraphQL" scheme="https://kylin.dev/tags/GraphQL/"/>
    
  </entry>
  
</feed>
