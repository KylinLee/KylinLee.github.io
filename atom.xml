<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>蝶恋花-等风也等你</title>
  
  <subtitle>等风也等你</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kylin.dev/"/>
  <updated>2020-06-02T10:07:52.042Z</updated>
  <id>https://kylin.dev/</id>
  
  <author>
    <name>Kylin Lee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅谈GraphQL的尴尬</title>
    <link href="https://kylin.dev/2020/05/30/%E6%B5%85%E8%B0%88GraphQL%E7%9A%84%E5%B0%B4%E5%B0%AC/"/>
    <id>https://kylin.dev/2020/05/30/%E6%B5%85%E8%B0%88GraphQL%E7%9A%84%E5%B0%B4%E5%B0%AC/</id>
    <published>2020-05-30T08:47:21.000Z</published>
    <updated>2020-06-02T10:07:52.042Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本人某校大二学生，最近忙于数据库课设，其中用到了 <a href="https://graphql.cn/">GraphQL</a>，碰巧在知乎上看到了<a href="https://www.zhihu.com/question/38596306">GraphQL 为何没有火起来？</a>这个问题，虽然是刚用到 GraphQL，但对于这个问题还是有一点想法，的所以这里就浅浅的聊一下 GraphQL 的尴尬吧。</p><a id="more"></a><h1 id="GraphQL-的好处"><a href="#GraphQL-的好处" class="headerlink" title="GraphQL 的好处"></a>GraphQL 的好处</h1><p>因为刚开始用上，没有很深入的去研究 GraphQL 的好处，我只能列出在使用过程中发现的一些好处：</p><h2 id="弹性-API-查询"><a href="#弹性-API-查询" class="headerlink" title="弹性 API 查询"></a>弹性 API 查询</h2><p>由前端传来的查询参数，需要哪些内容由由前端决定，可多可少，减少返回数据冗余。直接好处就是对于不同的 C 端（Web、App、小程序等），可能需要展示不同的内容，有的数据需要，有的数据不需要，使用 GraphQL 可以不用改后端代码，定制想要的数据字段。</p><h2 id="减少路由"><a href="#减少路由" class="headerlink" title="减少路由"></a>减少路由</h2><p>RESTful 往往会使用到许多路由，服务器对大量路由的解析会延长响应时间，对于 GraphQL，只需要设置一个路由而不需要大量的路由解析，并且方便 API 的管理。</p><h2 id="减少请求次数"><a href="#减少请求次数" class="headerlink" title="减少请求次数"></a>减少请求次数</h2><p>根据上面所说的，我们只需要一个路由，并且可以自定义需要的数据字段，那么对于一个页面，完全可以只发送一个请求来获取所有数据。</p><h2 id="更少的代码"><a href="#更少的代码" class="headerlink" title="更少的代码"></a>更少的代码</h2><p>这是对于服务端来说的，对于查询同一内容，不需要重新再写一遍，只需要一个 <code>resolver</code> 就行了。</p><h2 id="更好的前后端联调"><a href="#更好的前后端联调" class="headerlink" title="更好的前后端联调"></a>更好的前后端联调</h2><p>在开发前期，只要后端给出 GraphQL 接口或者说 <code>Schema</code> 确定，那么在前端就能够通过 <code>GraphQL PlayGround</code> 很轻松的模拟数据，<code>GraphQL PlayGround</code> 就相当于一份 API 文档。而且因为 GraphQL 严格的类型系统，也直接在开发阶段解决掉了类型不相同的问题。</p><h1 id="GraphQL-现状"><a href="#GraphQL-现状" class="headerlink" title="GraphQL 现状"></a>GraphQL 现状</h1><p>我认为现在 GraphQL 目前处在一种进退两难的局面之中，2015 年 GraphQL 正式发布，到现在仅仅 5 年的时间，在圈子中颇具影响力，也获得了很多的关注，可以算得上是新秀。这势头太强劲，是导致 GraphQL 现在窘境的一个原因，如果它发展的慢一点，人们可以慢慢的接受，和现在是不一样的局面吧。</p><p>首先要肯定的是 GraphQL 必定会成为未来的 API 查询语言，所以人们炒的很火，但在短期内无法改变仍然开发 RESTful 的局面，这就是发展太快带来的窘境吧。明明很强，大家也很喜欢，但用的人不多，作为 GraphQL 表示很尴尬啊。</p><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>一个很现实的问题就是，如果一个公司全部都是使用的 RESTful，现在改为使用 GraphQL，那不是要重写了？这对于一个大公司来说是伤筋动骨的事，搞不好服务崩溃，所以对于这些公司来说，继续使用 RESTful 花销会比改用 GraphQL 低得多，GraphQL 带来的好处远不如这些花销。</p><p>有些人认为需要前后端都支持是 GraphQL 没有被大量用起来的一个原因，但我对这个说法是不认可的，有需求就有技术支持，究其原因还是上面说的，有需求但没有必要。</p><h1 id="兼容方案"><a href="#兼容方案" class="headerlink" title="兼容方案"></a>兼容方案</h1><p>为了解决上面这个问题，也有一些兼容性方案。</p><p>在课设项目的开发中我使用的是<a href="https://www.apollographql.com/docs/apollo-server/">ApolloServer</a>，其中 ApolloServer 提供了两类数据源，一类是 RESTful API 数据源，一类是自定义数据源，RESTful API 数据源允许你不改变 RESTful API 来使用 GraphQL 进行查询，虽然看起来是很友好的，但当你使用 GraphQL 查询的内容令一个 RESTful API 不能完整提供的时候，会带来一些问题，举个简单的例子：</p><p>RESTful API 请求的字段都是固定的，前后端设定一致，就是说客户端直接请求 RESTful API，返回的数据中冗余很少，而 GraphQL 查询中需要的内容由前端来定，往往一个 GraphQL 查询会伴随着多个 RESTful API 请求，而最终是不需要用到所有数据的，这就出现了数据冗余，浪费了资源。</p><p>而如果 RESTful API 请求和 GraphQL 查询的内容完全吻合，那相比于直接使用 RESTful API 请求，使用 GraphQL 查询多了一次请求，这就是鸡肋的存在啊。</p><p>所以我认为这种兼容并不是完美的，反而会带来更多的资源消耗，并没有达到让大家迁移到 GraphQL 的目的。</p><p>以上就是入门级码农对 GraphQL 尴尬境地的浅显描述。如果大家有什么想法，欢迎留言评论。</p><article class="message message-immersive is-warning"><div class="message-body"><p>本文作者：KylinLee</p><p>本文链接：<a href="https://kylin.dev/2020/05/30/浅谈GraphQL的尴尬">https://kylin.dev/2020/05/30/浅谈GraphQL的尴尬</a></p><p>版权声明：本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p></div></article>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本人某校大二学生，最近忙于数据库课设，其中用到了 &lt;a href=&quot;https://graphql.cn/&quot;&gt;GraphQL&lt;/a&gt;，碰巧在知乎上看到了&lt;a href=&quot;https://www.zhihu.com/question/38596306&quot;&gt;GraphQL 为何没有火起来？&lt;/a&gt;这个问题，虽然是刚用到 GraphQL，但对于这个问题还是有一点想法，的所以这里就浅浅的聊一下 GraphQL 的尴尬吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Code" scheme="https://kylin.dev/categories/Code/"/>
    
    
      <category term="GraphQL" scheme="https://kylin.dev/tags/GraphQL/"/>
    
  </entry>
  
  <entry>
    <title>开始踩坑GoWeb</title>
    <link href="https://kylin.dev/2020/05/28/%E5%BC%80%E5%A7%8B%E8%B8%A9%E5%9D%91GoWeb/"/>
    <id>https://kylin.dev/2020/05/28/%E5%BC%80%E5%A7%8B%E8%B8%A9%E5%9D%91GoWeb/</id>
    <published>2020-05-28T15:26:18.000Z</published>
    <updated>2020-05-29T09:21:12.199Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这是我第一次使用 GoLang 进行 Web 开发，以前用的是 Koa 和 ThinkPHP 进行 Web 后端的开发，也算是有一些经验吧，这篇文章用来记录开发第一个小时遇到的问题。</p><div class="message message-immersive is-success"><div class="message-body"><p>如果你是GoLang的初学者，并且使用的第一个外部包是 <a href="https://github.com/kataras/iris" target="_blank">iris</a> ，那么这篇文章对你相当有帮助。</p></div></div><a id="more"></a><p>问：开发前一个小时我们在做什么？<br>答：打造开发环境和 initialize。</p><h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><p>开发环境倒是不用配置，这个在安装 GoLang 的时候就配置好了，只需要提一点就行了，后面会提到。</p><h2 id="关于GOPATH"><a href="#关于GOPATH" class="headerlink" title="关于GOPATH"></a>关于<code>GOPATH</code></h2><p>它指定软件包源代码所在的目录，<code>$GOPATH</code> 默认采用和 <code>$GOROOT</code>（GO 的安装目录） 一样的值，但从 Go 1.1 版本开始，你必须修改为其它路径。它可以包含多个包含 Go 语言源码文件、包文件和可执行文件的路径，而这些路径下又必须分别包含三个规定的目录：src、pkg 和 bin，这三个目录分别用于存放源码文件、包文件和可执行文件。</p><h1 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h1><p>我使用的是<a href="https://github.com/kataras/iris">iris</a>，这个 Web 框架，选择这个框架的原因主要参考了<a href="https://github.com/speedwheel/awesome-go-web-frameworks/blob/master/README.md">Awesome Web Frameworks for Gophers</a>这篇文章，毫无疑问，我认为这将是未来几年最具潜力的框架，在开源 GoWeb 框架中性能是最强的，社区也是最活跃的，学习曲线相对容易。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>按照官方文档首先使用<code>go-get</code>从 GitHub 上将外部包下载到本地，但在国内的话一般是不成功的。</p><figure class="highlight bash"><figcaption><span>PowerShell</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/kataras/iris/v12@latest</span><br></pre></td></tr></table></figure><p>所以我通过百度找到了热心网友，网友的帖子上说需要先设置<code>GO111MODULE</code>这个环境变量为<code>on</code>，然后设置代理（为了避免从 GitHub 下载源码网速慢而下载失败），根据你的操作系统执行下面两条命令：</p><figure class="highlight bash"><figcaption><span>MacOS/Linux bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Enable the go modules feature</span></span><br><span class="line"><span class="built_in">export</span> GO111MODULE=on</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the GOPROXY environment variable</span></span><br><span class="line"><span class="built_in">export</span> GOPROXY=https://goproxy.io</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>Windows PowerShell</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Enable the go modules feature</span></span><br><span class="line"><span class="variable">$env</span>:GO111MODULE=<span class="string">"on"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the GOPROXY environment variable</span></span><br><span class="line"><span class="variable">$env</span>:GOPROXY=<span class="string">"https://goproxy.io"</span></span><br></pre></td></tr></table></figure><p>现在我们写入一段示例代码来测试一下：</p><figure class="highlight go"><figcaption><span>GoProjectDir/main.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/kataras/iris"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    app := iris.New()</span><br><span class="line">    app.Handle(<span class="string">"GET"</span>, <span class="string">"/welcome"</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx iris.Context)</span></span> &#123;</span><br><span class="line">        ctx.HTML(<span class="string">"&lt;h1&gt;Welcome&lt;/h1&gt;"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    app.Run(iris.Addr(<span class="string">":8080"</span>)) <span class="comment">//8080 监听端口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候 Goland 报错了，告诉我们无法找到引用的包。</p><h1 id="问题在哪？"><a href="#问题在哪？" class="headerlink" title="问题在哪？"></a>问题在哪？</h1><p>这时候我们会很自然的去看这个包是不是真的下载到本地了，于是我们上去<code>GOPATH</code>目录去找，发现目录下只有<code>pkg</code>文件夹，而没有<code>src</code>源文件文件夹。</p><figure class="highlight bash"><figcaption><span>output</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PS F:\ProjectFiles\Go&gt; <span class="built_in">cd</span> <span class="variable">$env</span>:gopath</span><br><span class="line">PS E:\Application\GOPATH&gt; ls</span><br><span class="line"></span><br><span class="line">    Directory: E:\Application\GOPATH</span><br><span class="line"></span><br><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line">----                 -------------         ------ ----</span><br><span class="line">d----           2020/5/28    21:35                pkg</span><br></pre></td></tr></table></figure><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>正常情况下，引入一个外部包时会在<code>GOPATH</code>下的<code>src</code>目录进行包的查找，很明显没有这个文件夹是导致错误的直接原因。</p><p>为什么会这样呢？</p><p>你可能已经注意到我们之前设置了一个环境变量<code>GO111MODULE=on</code>，安装包的时候默认采用是 GOPATH 的模式（GO 最初的依赖管理系统），就是把包的源码放进<code>src</code>目录，而当我们设置了上面这个环境变量的时候就会使用 GoMod 模式，它使用 Go Module 的方式管理包，可以理解为 Module 是 Go packages 的集合。</p><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>使用了不同的依赖管理系统就要用不同的方式，如果你用过 Node 就很好理解，每个 Node 项目都会有一个<code>package.json</code>，里边描述了项目和依赖的信息。对于 GoMod 而言，每一个 Go 项目需要一个<code>go.mod</code>文件来描述这些信息。接着上面的操作，创建一个<code>go.mod</code>文件：</p><figure class="highlight bash"><figcaption><span>PowerShell</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod init `你的包名，通常是项目名称`</span><br></pre></td></tr></table></figure><p>初始化之后里面还没有依赖，在项目文件夹重新使用<code>go-get</code>安装一下包，因为<code>GOPATH</code>已经有了，所以这次直接建立了引用而不需要下载了。现在重新 run 一下，已经没有问题了。</p><p>如果你的 GoLand 仍然提示有错误，在设置中的 GOPATH 配置添加上面设置的环境变量即可。</p><h1 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h1><ol><li>不要随便复制别人的操作，比如说如果没有设置<code>GO111MODULE=on</code>，只设置代理，那么后面的问题都不会出现。</li><li>但是还是推荐使用 GoMod 这种依赖管理方式，因为你可以对项目的依赖轻松进行删除，升级，添加等操作。</li><li>之所以出现这个问题，另外一个原因是，GoMod 是在 2018 年提出使用的，我看的中文文档版本太老压根没有提到，初来乍到，没有关注行情。</li></ol><article class="message message-immersive is-warning"><div class="message-body"><p>本文作者：KylinLee</p><p>本文链接：<a href="https://kylin.dev/2020/05/28/开始踩坑GoWeb">https://kylin.dev/2020/05/28/开始踩坑GoWeb</a></p><p>版权声明：本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p></div></article>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是我第一次使用 GoLang 进行 Web 开发，以前用的是 Koa 和 ThinkPHP 进行 Web 后端的开发，也算是有一些经验吧，这篇文章用来记录开发第一个小时遇到的问题。&lt;/p&gt;
&lt;div class=&quot;message message-immersive is-success&quot;&gt;
&lt;div class=&quot;message-body&quot;&gt;
&lt;p&gt;如果你是GoLang的初学者，并且使用的第一个外部包是 &lt;a href=&quot;https://github.com/kataras/iris&quot; target=&quot;_blank&quot;&gt;iris&lt;/a&gt; ，那么这篇文章对你相当有帮助。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
    
    </summary>
    
    
      <category term="Code" scheme="https://kylin.dev/categories/Code/"/>
    
    
      <category term="GoLang" scheme="https://kylin.dev/tags/GoLang/"/>
    
  </entry>
  
  <entry>
    <title>ES6解构与剩余参数</title>
    <link href="https://kylin.dev/2020/05/19/ES6%E8%A7%A3%E6%9E%84%E4%B8%8E%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0/"/>
    <id>https://kylin.dev/2020/05/19/ES6%E8%A7%A3%E6%9E%84%E4%B8%8E%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0/</id>
    <published>2020-05-19T01:55:53.000Z</published>
    <updated>2020-05-21T06:10:54.145Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>解构赋值是 ES6 中引入的非常有用的语法，掌握解构的技巧能让你更愉悦的敲代码，延长生命的长度。这篇文章是<a href="/2020/05/09/JavaScript%E5%BF%AB%E9%80%9F%E6%8B%B7%E8%B4%9D%E6%95%B0%E7%BB%84%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/" title="JavaScript快速拷贝数组的几种方法">JavaScript快速拷贝数组的几种方法</a>的拓展，因为上一篇文章扯远了，不得不再写一篇补充。</p><a id="more"></a><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>解构赋值是对赋值运算符的扩展。他针对数组或者对象进行模式匹配，然后对其中的变量进行赋值。就是按照视觉上的一一对应关系进行赋值。</p><h1 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h1><p>赋值的顺序是数组索引的顺序</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>];</span><br><span class="line"><span class="keyword">let</span> [one = <span class="string">"one"</span>, two, three] = arr;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`one: <span class="subst">$&#123;one&#125;</span>, two: <span class="subst">$&#123;two&#125;</span>, three: <span class="subst">$&#123;three&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// 输出 “one: 1, two: 2, three: 3”</span></span><br></pre></td></tr></table></figure><h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p><strong>数组解构和对象解构都可以使用默认值</strong><br>上面这段代码中第 2 行<code>one = &quot;one&quot;</code>是将 one 赋予默认值，当且仅当赋予<code>one</code>的值为<code>undefined</code>时使用这个值。</p><h2 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h2><p><strong>数组解构和对象解构都可以使用剩余参数</strong><br>当有多余的值不想一一赋值的时候可以使用剩余参数，即将这些解构没有对应上的值全部放进一个数组：</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line"><span class="keyword">let</span> [a, ...bc];</span><br><span class="line"><span class="built_in">console</span>.log(bc); <span class="comment">// ["b","c"]</span></span><br></pre></td></tr></table></figure><h2 id="数组解构作用"><a href="#数组解构作用" class="headerlink" title="数组解构作用"></a>数组解构作用</h2><h3 id="数组解构快速换值"><a href="#数组解构快速换值" class="headerlink" title="数组解构快速换值"></a>数组解构快速换值</h3><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"a"</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">"b"</span>;</span><br><span class="line"><span class="keyword">var</span> [b, a] = [a, b];</span><br></pre></td></tr></table></figure><p>一行代码实现变量值对换，这样做是不是延长了寿命？/笑哭 😂</p><h3 id="快速拷贝数组"><a href="#快速拷贝数组" class="headerlink" title="快速拷贝数组"></a>快速拷贝数组</h3><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> exampleArr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> [...newArr] = exampleArr;</span><br></pre></td></tr></table></figure><p>具体请参考我的这篇文章<a href="/2020/05/09/JavaScript%E5%BF%AB%E9%80%9F%E6%8B%B7%E8%B4%9D%E6%95%B0%E7%BB%84%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/" title="JavaScript快速拷贝数组的几种方法">JavaScript快速拷贝数组的几种方法</a></p><h1 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h1><p>语法和数组解构类似，但需要保证赋值的变量名和属性名一致：</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> school = &#123;</span><br><span class="line">  name: <span class="string">"TUST"</span>,</span><br><span class="line">  location: <span class="string">"Tian'Jin"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">name</span>: schoolName, location &#125; = school;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;schoolName&#125;</span> is located in <span class="subst">$&#123;location&#125;</span>`</span>); <span class="comment">// TUST is located in Tian'Jin</span></span><br></pre></td></tr></table></figure><h2 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h2><p><strong>数组解构和对象解构中都可以使用重命名</strong><br>上面这段代码第 5 行，<code>name: schoolName</code>将<code>school</code>对象的<code>name</code>属性的值赋给<code>schoolName</code>，而不是<code>name</code>。</p><h2 id="对象解构的作用"><a href="#对象解构的作用" class="headerlink" title="对象解构的作用"></a>对象解构的作用</h2><h3 id="解析配置对象"><a href="#解析配置对象" class="headerlink" title="解析配置对象"></a>解析配置对象</h3><p>对象解构常用于配置对象，比如传入一个对象作为配置，并且某些配置项是可选的，比如在 Vue 中使用 ElmentUI：</p><blockquote><p>在引入 Element 时，可以传入一个全局配置对象。该对象目前支持 size 与 zIndex 字段。size 用于改变组件的默认尺寸，zIndex 设置弹框的初始 z-index（默认值：2000）。按照引入 Element 的方式，具体操作如下：</p></blockquote><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">import</span> Element <span class="keyword">from</span> <span class="string">"element-ui"</span>;</span><br><span class="line">Vue.use(Element, &#123; <span class="attr">size</span>: <span class="string">"small"</span>, <span class="attr">zIndex</span>: <span class="number">1000</span> &#125;);</span><br></pre></td></tr></table></figure><p>第三行<code>Vue.use</code>除了传入<code>Element</code>，还可以传入一个配置对象作为全局配置，这个配置参数是可选的，那我们可以这样写（不一定是真实写法）：</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Element(...args)&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    size = <span class="string">"-"</span>,</span><br><span class="line">    z-index = <span class="number">2000</span></span><br><span class="line">  &#125; = args[<span class="number">1</span>]</span><br><span class="line">  <span class="comment">// ...若干代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现-import"><a href="#实现-import" class="headerlink" title="实现 import"></a>实现 import</h3><p>在浏览器中如果我们使用<code>script</code>标签引入了一个 UMD 模块，使用模块中的变量可以用解构来减少写<code>.</code>操作符，比如：</p><figure class="highlight html"><figcaption><span>HTML</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/rxjs/6.3.3/rxjs.umd.min.js"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">async</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="keyword">of</span>, map &#125; = rxjs;</span><br></pre></td></tr></table></figure><h1 id="剩余参数和扩展运算的区别"><a href="#剩余参数和扩展运算的区别" class="headerlink" title="剩余参数和扩展运算的区别"></a>剩余参数和扩展运算的区别</h1><p>我们使用的时候一般都不会注意这个问题，通常就是很顺畅的写完了，代码一点错误都没有，即便如此，还是要搞清楚两者的区别啊，我看到很多博客文章都将二者混淆。</p><p>其实区分他们很简单，从字面意义上理解就行了，剩余参数是参数，有将参数合并成数组的作用，而拓展运算是展开数组，同样是三个点<code>...</code>，一个是存，一个是取，它们的作用似乎是相反的。</p><article class="message message-immersive is-warning"><div class="message-body"><p>本文作者：KylinLee</p><p>本文链接：<a href="https://kylin.dev/2020/05/19/ES6解构与剩余参数">https://kylin.dev/2020/05/19/ES6解构与剩余参数</a></p><p>版权声明：本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p></div></article>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;解构赋值是 ES6 中引入的非常有用的语法，掌握解构的技巧能让你更愉悦的敲代码，延长生命的长度。这篇文章是&lt;a href=&quot;/2020/05/09/JavaScript%E5%BF%AB%E9%80%9F%E6%8B%B7%E8%B4%9D%E6%95%B0%E7%BB%84%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/&quot; title=&quot;JavaScript快速拷贝数组的几种方法&quot;&gt;JavaScript快速拷贝数组的几种方法&lt;/a&gt;的拓展，因为上一篇文章扯远了，不得不再写一篇补充。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Code" scheme="https://kylin.dev/categories/Code/"/>
    
    
      <category term="JavaScript" scheme="https://kylin.dev/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>FirstStrike!</title>
    <link href="https://kylin.dev/2020/05/17/FirstStrike/"/>
    <id>https://kylin.dev/2020/05/17/FirstStrike/</id>
    <published>2020-05-17T01:50:04.000Z</published>
    <updated>2020-05-21T06:17:14.539Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="http://www.firststrike.mobi/">FirstStrike</a>，是一款以核打击为题材的单机游戏，中文名：先发制人。</p><a id="more"></a><p>这是一个我很早以前就开始玩的游戏，因为打游戏不上瘾，经常都不会玩一次，所以我的很多游戏都是还没打完就卸载了的。昨天心血来潮重新开始玩这款我认为超棒的游戏，我这样不太爱玩游戏的人都会时常回来玩两局。这款游戏以前是没有中文版的，所以国内知道的比较少，现在 Google play 上下载的最新版支持中文了，对国人更友好，索性今天写个简单的介绍，将这款游戏推荐给大家。</p><h1 id="简单的做个属性介绍："><a href="#简单的做个属性介绍：" class="headerlink" title="简单的做个属性介绍："></a>简单的做个属性介绍：</h1><blockquote><p>外文名：First Strike<br>中文名：先发制人<br>游戏标签：战争策略/单机<br>平台：Android iOS<br>厂商：<a href="http://blindflugstudios.com/">blindflugstudios</a></p></blockquote><h1 id="游戏玩法："><a href="#游戏玩法：" class="headerlink" title="游戏玩法："></a>游戏玩法：</h1><p>在游戏中，你将扮演一个拥有核打击能力国家的政府首脑，通过战略（研究武器，建立外交，核打击）等征服其他国家，成为世界上唯一的超级大国，同时你也需要保护自己的国家免受核打击。</p><h1 id="游戏截图："><a href="#游戏截图：" class="headerlink" title="游戏截图："></a>游戏截图：</h1><h2 id="中文支持"><a href="#中文支持" class="headerlink" title="中文支持"></a>中文支持</h2><p>这款游戏是非常容易上手的，官方的支持中文一并连 Guide 都支持了<br><img src="https://i.loli.net/2020/05/17/BbOYrxw752m4A8D.jpg" alt="first-strike-start.jpg"></p><h2 id="控制面板"><a href="#控制面板" class="headerlink" title="控制面板"></a>控制面板</h2><p>游戏控制的主体是一个地球，点击你的领土会弹出炫酷的 3D 控制面板<br><img src="https://i.loli.net/2020/05/17/uqSWic6fLHAj3P1.jpg" alt="first-strike-control.jpg"></p><h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><p>每次核打击都会有这样的提示<br><img src="https://i.loli.net/2020/05/17/ra3cJ79sSNyY5bx.jpg" alt="first-strike-died.jpg"></p><h2 id="核打击"><a href="#核打击" class="headerlink" title="核打击"></a>核打击</h2><p>全面核打击<br><img src="https://i.loli.net/2020/05/17/YWRhEl9H1TPCAG6.jpg" alt="first-strike-attack.jpg"></p><h2 id="武器"><a href="#武器" class="headerlink" title="武器"></a>武器</h2><p>超级核武器<br><img src="https://i.loli.net/2020/05/17/VBoTdhqu3ncjf1v.png" alt="first-strike-super-weapon.png"></p><h1 id="为什么推荐"><a href="#为什么推荐" class="headerlink" title="为什么推荐"></a>为什么推荐</h1><h2 id="它的意义"><a href="#它的意义" class="headerlink" title="它的意义"></a>它的意义</h2><p>在战略游戏中获胜往往能给我们带来成就感，尤其是你扮演着一个超级大国的时候，但在这个游戏中获胜时你不会有这种感觉。<br><img src="https://i.loli.net/2020/05/17/hbiGwFzdPjoHCla.png" alt="first-strike-win.png"></p><blockquote><p>你真的赢了吗？<br>你毁灭了多少个国家和地区？<br>你让多少人成为了受害者？<br>你释放了多少当量？</p></blockquote><p>如果你玩过<a href="https://www.ndemiccreations.com/en/22-plague-inc">PLAGUE INC.</a>(瘟疫公司)，再玩这款游戏的时候，你会和玩瘟疫公司时有同样的感慨：“这简直就是毁灭人类的节奏啊！”。</p><p>我喜欢这个游戏不仅仅是因为它好玩，而是在于它和别的游戏出发点不同，每一款游戏都是一个作品，但不是所有作品都是有灵魂的，当你玩一个游戏的时候，你仔细想想，这个游戏真正的意义在哪。在 FirstStrike 中你能很清楚的明白创造它的人想告诉我们什么。</p><h2 id="制作精良"><a href="#制作精良" class="headerlink" title="制作精良"></a>制作精良</h2><p>无论是操作，还是整体风格，都是满满的科技感，细节处理也很到位，比如一个地区受到核打击后是不能立即建立防御体系和核武器库的，在细微之处演绎核武器带来的危害。</p><h1 id="其他推荐"><a href="#其他推荐" class="headerlink" title="其他推荐"></a>其他推荐</h1><h2 id="FirstStrike-FinalHour"><a href="#FirstStrike-FinalHour" class="headerlink" title="FirstStrike:FinalHour"></a>FirstStrike:FinalHour</h2><p>目前 FirstStrike 仅支持 Android 和 iOS 平台，如果你想在电脑上玩，可以尝试<a href="http://www.firststrikefinalhour.com/">FirstStrike:FinalHour</a>，这是 FirstStrike 的制作团队的续作（和 FirstStrike 差别不大），现已登录 steam，FirstStrike:FinalHour 也支持移动版。</p><h2 id="Stellar-Commanders"><a href="#Stellar-Commanders" class="headerlink" title="Stellar Commanders"></a>Stellar Commanders</h2><p>FirstStrike 团队新近发布的<a href="https://www.stellarcommanders.com/">Stellar Commanders</a>，可以理解为 FirstStrike 的联机版本，可以和小伙伴们一起玩。</p><article class="message message-immersive is-warning"><div class="message-body"><p>本文作者：KylinLee</p><p>本文链接：<a href="https://kylin.dev/2020/05/17/FirstStrike">https://kylin.dev/2020/05/17/FirstStrike</a></p><p>版权声明：本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p></div></article>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.firststrike.mobi/&quot;&gt;FirstStrike&lt;/a&gt;，是一款以核打击为题材的单机游戏，中文名：先发制人。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Life" scheme="https://kylin.dev/categories/Life/"/>
    
      <category term="Game" scheme="https://kylin.dev/categories/Life/Game/"/>
    
    
      <category term="Other" scheme="https://kylin.dev/tags/Other/"/>
    
      <category term="Recommend" scheme="https://kylin.dev/tags/Recommend/"/>
    
      <category term="Life" scheme="https://kylin.dev/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>在Hexo上分享歌曲</title>
    <link href="https://kylin.dev/2020/05/09/%E5%9C%A8Hexo%E4%B8%8A%E5%88%86%E4%BA%AB%E6%AD%8C%E6%9B%B2/"/>
    <id>https://kylin.dev/2020/05/09/%E5%9C%A8Hexo%E4%B8%8A%E5%88%86%E4%BA%AB%E6%AD%8C%E6%9B%B2/</id>
    <published>2020-05-09T07:10:49.000Z</published>
    <updated>2020-05-21T06:19:03.141Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>一款大名鼎鼎的 JS 插件，在 Hexo 上也能听歌了！</p><a id="more"></a><p>这是一款叫做<code>aplayer.js</code>的开源插件，通过简单的配置就能在页面中插入美观的音乐播放控件，<a href="https://aplayer.js.org/">插件地址</a>。<br>一起来看一看效果吧！</p><p><img src="https://i.loli.net/2020/05/09/UVZO3zNJqx7amB6.jpg" alt="netease-28315295.jpg"></p>    <div id="aplayer-MreOxost" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="28315295" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="false" data-listmaxheight="340px" data-preload="none" data-theme="#2e5666"    ></div><article class="message message-immersive is-warning"><div class="message-body"><p>本文作者：KylinLee</p><p>本文链接：<a href="https://kylin.dev/2020/05/09/在Hexo上分享歌曲">https://kylin.dev/2020/05/09/在Hexo上分享歌曲</a></p><p>版权声明：本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p></div></article>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一款大名鼎鼎的 JS 插件，在 Hexo 上也能听歌了！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Life" scheme="https://kylin.dev/categories/Life/"/>
    
      <category term="Music" scheme="https://kylin.dev/categories/Life/Music/"/>
    
    
      <category term="Other" scheme="https://kylin.dev/tags/Other/"/>
    
      <category term="Recommend" scheme="https://kylin.dev/tags/Recommend/"/>
    
  </entry>
  
</feed>
