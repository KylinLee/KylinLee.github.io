<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>蝶恋花-等风也等你</title>
  
  <subtitle>等风也等你</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kylin.dev/"/>
  <updated>2020-07-10T03:19:57.223Z</updated>
  <id>https://kylin.dev/</id>
  
  <author>
    <name>Kylin Lee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Apollo-GraphQL 快速上手</title>
    <link href="https://kylin.dev/2020/07/07/Apollo-GraphQL%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
    <id>https://kylin.dev/2020/07/07/Apollo-GraphQL%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</id>
    <published>2020-07-07T10:06:26.000Z</published>
    <updated>2020-07-10T03:19:57.223Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>上次课程设计做完之后就放松了一阵子，过了这么久才来更新博客其实内心是不好受的，感觉生活缺少了什么。本文就从 0 开始，理一下我的开发流程及 Apollo 的基本的使用。</p><div class="message message-immersive is-success"><div class="message-body"><p>如果你不打算使用 Apollo 来开发，没关系，抛开框架本身你可以了解到 GraphQL 的运行方式。</p><p>如果你觉得看英文文档不方便，阅读这篇文章也是一个不错的选择。</p><p>本文假设你对GraphQL有一定的了解。</p></div></div><a id="more"></a><p>本文将客户端和服务端分开来讲，写作顺序按照开发顺序或者思路。</p><h1 id="Apollo-Server"><a href="#Apollo-Server" class="headerlink" title="Apollo Server"></a>Apollo Server</h1><p><a href="https://www.apollographql.com/docs/apollo-server/">Apollo Server</a> 是以 Node 为后端的 GraphQL 实现，我选择 Apollo 是因为它是一套完整的服务框架，它包括前端和后端，并且 Node 也是后端开发最快的方式。</p><h2 id="基本服务器监听"><a href="#基本服务器监听" class="headerlink" title="基本服务器监听"></a>基本服务器监听</h2><p><em>本节为搭建基础服务器而不是 GraphQL 服务器，熟练的朋友可跳过。</em></p><p>Apollo Server 可作为一个独立的服务器，我们可以安装 Apollo 后直接启动服务器监听，但功能它的只限于对数据的增删改查，一个服务器可能还需要如下功能：</p><ul><li>模板渲染或 SSR</li><li>身份验证</li><li>文件上传</li><li>…</li></ul><p>为了便于拓展业务功能，我将 Apollo Server 作为 Node 服务器的中间件，你可以选择你喜欢的 Node 服务器框架，或者自己搭建 Node 服务器，我选择的是 <a href="https://www.koajs.com.cn/">Koa</a>，接下来开始搭建整体架构：</p><h3 id="安装-Koa-和-Apollo-Server"><a href="#安装-Koa-和-Apollo-Server" class="headerlink" title="安装 Koa 和 Apollo Server"></a>安装 Koa 和 Apollo Server</h3><figure class="highlight powershell"><figcaption><span>PowerShell</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i koa<span class="literal">-generator</span> <span class="literal">-g</span></span><br><span class="line">koa2 项目名</span><br></pre></td></tr></table></figure><p>生成的目录如下，长的很像 MVC 架构：<br><img src="https://i.loli.net/2020/07/07/6jbzi9kqFVEJWB3.png" alt="origin-dir.png"><br><code>app.js</code> 里引入了必备的库并初始化和定义路由，最终由 <code>bin/www</code> 引用并真正将他们使用起来。</p><p>接下来安装依赖，除了 koa-generator 生成的依赖，还需要安装<code>apollo-server-koa</code>和<code>graphql</code>，这样将 Apollo Server 作为中间件，如果你使用其他 Node 服务器，可以在<a href="https://www.apollographql.com/docs/apollo-server/integrations/middleware/">这里</a>找到适合的中间件。</p><h3 id="开发建议"><a href="#开发建议" class="headerlink" title="开发建议"></a>开发建议</h3><p>每次编辑代码之后查看更改必须要重新启动服务器，koa-generator 自动为我们安装<code>nodemon</code>，它能监听工作区的文件更改，进行热更新。这样的话，你需要将<code>bin/www</code>文件改为<code>bin/www.js</code>，因为<code>nodemon</code>不会监听没有后缀名文件的更改。</p><p>安装依赖后最后使用<code>npm run dev</code>就能启动服务器了，默认端口为 3000，你可以通过<code>localhost:3000</code>访问。</p><h2 id="简单的-GraphQL-服务"><a href="#简单的-GraphQL-服务" class="headerlink" title="简单的 GraphQL 服务"></a>简单的 GraphQL 服务</h2><p>Apollo GraphQL 由以下部分组成：</p><ul><li>Schema：图、结构</li><li>Data：数据</li><li>Resolver：解析器</li></ul><p>为了便于理解，先模拟一个查询书籍相关信息的 GraphQL 服务器</p><h3 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h3><p>Schema 相当于接口（指 API 接口），定义了客户端可以执行的操作类型，数据结构体，数据字段及类型。在 MVC 架构中，相当于模型，我的理解 Schema 是数据的入口和出口，一个请求传过来首先通过 Schema 校验，响应内容最终也会以 Schema 定义的格式返回，相当于一个模具，固定数据进出的格式。<br>所以新建一个<code>model/schema</code>目录，在目录中建立 Schema 并将其导出备用：</p><figure class="highlight javascript"><figcaption><span>model/schema/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; gql &#125; = <span class="built_in">require</span>(<span class="string">"apollo-server-koa"</span>);</span><br><span class="line"><span class="keyword">const</span> typeDefs = gql<span class="string">`</span></span><br><span class="line"><span class="string">    type Book &#123;</span></span><br><span class="line"><span class="string">        title: String</span></span><br><span class="line"><span class="string">        author: String</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    type Query &#123;</span></span><br><span class="line"><span class="string">        books: [Book]</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = typeDefs;</span><br></pre></td></tr></table></figure><p>GraphQL 中文文档中将类似于上面 <code>Book</code> 的结构叫做“<strong>类型</strong>”，但我认为对于编程人员将它们叫做“<strong>结构体</strong>”更容易理解。</p><h3 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h3><p>数据比较容易理解，客户端需要的内容，服务器可返回的内容就是数据。为了简化流程，便于理解，我们选择使用模拟数据，可以新建<code>data</code>目录，将模拟数据放在这里并导出备用：</p><figure class="highlight javascript"><figcaption><span>data/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> books = [</span><br><span class="line">    &#123;</span><br><span class="line">        title: <span class="string">"Harry Potter and the Chamber of Secrets"</span>,</span><br><span class="line">        author: <span class="string">"J.K. Rowling"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        title: <span class="string">"Jurassic Park"</span>,</span><br><span class="line">        author: <span class="string">"Michael Crichton"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="built_in">module</span>.export = books;</span><br></pre></td></tr></table></figure><h3 id="Resolver"><a href="#Resolver" class="headerlink" title="Resolver"></a>Resolver</h3><p>解析器的作用是将 Schema 和 Data 联系在一起，即根据客户端传来的查询语句在一大堆 Data 里边找到指定的数据，如果说放在 MVC 里边，可以作为控制器，也可以作为模型，看个人如何理解，其实 MVC 没有很严格的界定，如果你的 Resolver 除了查询数据还具有其他复杂的功能，将其定义为控制器比较合适，如果你的 Resolver 专门用于数据的查询，将其作为模型看待。我将 Resolver 放在<code>model/resolver</code>目录下。</p><p>现在我们可以分析一下，查询<code>Books</code>，需要返回一个数组，数组的每一项需要符合<code>Book</code>的结构，即每一项需要包含<code>title</code>和<code>author</code>字段，巧的是我们模拟的数据<code>book</code>正好符合<code>Books</code>的结构。</p><p><strong>在开发中，这个分析很重要，请不要忽略！！！</strong></p><p>所以我们的 Resolver 这样写：</p><figure class="highlight javascript"><figcaption><span>model/resolver/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> books = <span class="built_in">require</span>(<span class="string">"../../data/index.js"</span>);</span><br><span class="line"><span class="keyword">const</span> resolvers = &#123;</span><br><span class="line">    Query: &#123;</span><br><span class="line">        books: <span class="function"><span class="params">()</span> =&gt;</span> books,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = resolvers;</span><br></pre></td></tr></table></figure><p>为 Schema 中对应的结构体编写同名的函数，并将这些函数作为<code>resolvers</code>对象的键和值，导出<code>resolvers</code>备用。</p><h4 id="Resolver-进阶"><a href="#Resolver-进阶" class="headerlink" title="Resolver 进阶"></a>Resolver 进阶</h4><p>其实你只编写了 Query 中 books 的解析器，books 是以 Book 为单元的数组，但我们并没有编写 Book 结构体的解析器，它还是返回了我们预期的结果。实际上 Apollo 并不是<code>data</code>是什么就返回什么，将<code>data</code>中的<code>author</code>改为<code>authors</code>，只会返回<code>title</code>字段内容。默认情况下，如果你没有编写某个结构体的解析器，Apollo 将会使用默认解析器，它会根据 books 的结果去验证里边的某一项是否符合 Book 解析器，最终返回符合 Book 的结果，起到了过滤的效果，了解默认解析器可以帮助你少编写代码。</p><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>将三部分准备其了，接下来将这三部分接入服务器，供服务器调用，首先在<code>www.js</code>这个执行文件中引入这三部分，然后将他们作为选项传入 Apollo Server，最后将 Apollo Server 作为 Koa 中间件，<strong>关键代码</strong>如下：</p><figure class="highlight javascript"><figcaption><span>bin/www.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">"../app.js"</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; ApolloServer &#125; = <span class="built_in">require</span>(<span class="string">"apollo-server-koa"</span>);</span><br><span class="line"><span class="keyword">const</span> typeDefs = <span class="built_in">require</span>(<span class="string">"../model/schema/index.js"</span>);</span><br><span class="line"><span class="keyword">const</span> resolvers = <span class="built_in">require</span>(<span class="string">"../model/resolver/index.js"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造Apollo Server;</span></span><br><span class="line"><span class="keyword">const</span> server = <span class="keyword">new</span> ApolloServer(&#123;</span><br><span class="line">    typeDefs,</span><br><span class="line">    resolvers,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将server作为中间件</span></span><br><span class="line">server.applyMiddleware(&#123; app &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动监听，注意将原来的server改为app</span></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">    cosneole.log(<span class="string">"please open localhost:3000/graphql"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p>打开<code>localhost:3000/graphql</code>，进行 GraphQL 查询，GraphQL 基础这里就不讲了，既然决定用 Apollo Server 相信大家都会，测试如下：<br><img src="https://i.loli.net/2020/07/09/TLayrYwQmhIBKp6.png" alt="test-graphql.png"></p><h2 id="使用-MySQL-作为数据源"><a href="#使用-MySQL-作为数据源" class="headerlink" title="使用 MySQL 作为数据源"></a>使用 MySQL 作为数据源</h2><p>通过上面的讲解你已经理解 Apollo Server 的开发流程了吧，上面这个例子中使用的是模拟的数据，是固定不变的，接下来是重头戏——接入数据库。</p><p>我是用的是 MySQL，按照官方文档，可以使用的数据源有数据库和 RESTful API，支持 RESTful API 的原因是帮助使用 RESTful API 的服务迁移到 GraphQL，我使用关系型数据库 MySQL 作为数据源。</p><p>上面的例子中我们向 <code>ApolloServer</code> 构造函数传递了一个配置对象，这个配置对象包含了两个内容<code>typeDefs</code>和<code>resolvers</code>。其中数据源是在 resolver 中引入的，我们也可以将数据源传入 <code>ApolloServer</code> 构造函数，在 <code>ApolloServer</code> 实例化的时候就初始化连接数据库，我们使用 Apollo 社区维护的数据源工具<a href="https://github.com/cvburgess/SQLDataSource">datasource-sql</a>，它是基于<a href="http://knexjs.org/">knex</a>的，<code>knex</code>是一个查询构造器，通过<code>knex</code>我们可以用熟悉的 JavaScript 语法去执行 SQL 查询，<code>datasource-sql</code>的工作是将<code>knex</code>包装成<code>ApolloServer</code>构造函数可接受的对象，让我们先安装它：</p><figure class="highlight powershell"><figcaption><span>PowerShell</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i datasource<span class="literal">-sql</span> -<span class="literal">-save</span></span><br></pre></td></tr></table></figure><p>然后我们需要做三部分的更改：</p><ol><li>配置数据库并实例化数据源工具</li><li>将数据源实例传入<code>ApolloServer</code></li><li>在 resolver 中使用数据源</li></ol><h3 id="配置数据库并实例化数据源工具"><a href="#配置数据库并实例化数据源工具" class="headerlink" title="配置数据库并实例化数据源工具"></a>配置数据库并实例化数据源工具</h3><p>首先配置数据库，在<code>data</code>文件夹创建<code>data/mysql.config.js</code>：</p><figure class="highlight javascript"><figcaption><span>mysql.config.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> knexConfig = &#123;</span><br><span class="line">    client: <span class="string">"mysql"</span>,</span><br><span class="line">    connection: &#123;</span><br><span class="line">        host: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">        port: <span class="number">3306</span>,</span><br><span class="line">        user: <span class="string">"root"</span>,</span><br><span class="line">        password: <span class="string">""</span>,</span><br><span class="line">        database: <span class="string">"course_choose_system"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后创建<code>data/methods.js</code>，这里边定义了数据库的操作方法供 resolver 调用，这些方法包含了你需要对数据库进行的所有操作，比如下面这段代码就是获取<code>books</code>表中的所有字段，相当于 SQL 语句:</p><figure class="highlight plain"><figcaption><span>SQL</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from books;</span><br></pre></td></tr></table></figure><p><strong>注意：使用 knex 查询器返回的是 Promise。</strong></p><figure class="highlight javascript"><figcaption><span>data/methods.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SQLDataSource &#125; = <span class="built_in">require</span>(<span class="string">"datasource-sql"</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FetchMethods</span> <span class="keyword">extends</span> <span class="title">SQLDataSource</span> </span>&#123;</span><br><span class="line">    getAllBooks() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.knex(<span class="string">"books"</span>)</span><br><span class="line">            .select(<span class="string">"*"</span>)</span><br><span class="line">            .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.table(res);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;)</span><br><span class="line">            .catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="number">0</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = FetchMethods;</span><br></pre></td></tr></table></figure><p>最终实例化数据库工具的逻辑是：将数据库配置对象传入包含数据库操作方法的类，如下：</p><figure class="highlight javascript"><figcaption><span>data/mysql.config.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyDatabase = <span class="built_in">require</span>(<span class="string">"./methods"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> knexConfig = &#123;</span><br><span class="line">    client: <span class="string">"mysql"</span>,</span><br><span class="line">    connection: &#123;</span><br><span class="line">        host: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">        port: <span class="number">3306</span>,</span><br><span class="line">        user: <span class="string">"root"</span>,</span><br><span class="line">        password: <span class="string">""</span>,</span><br><span class="line">        database: <span class="string">"Book"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db = <span class="keyword">new</span> MyDatabase(knexConfig);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = db;</span><br></pre></td></tr></table></figure><h3 id="将数据源实例传入ApolloServer"><a href="#将数据源实例传入ApolloServer" class="headerlink" title="将数据源实例传入ApolloServer"></a>将数据源实例传入<code>ApolloServer</code></h3><p>通过上面的实例化之后成为了<code>ApolloServer</code>构造函数可接受的数据源对象，对 ApolloServer 配置做如下更改：</p><figure class="highlight javascript"><figcaption><span>bin/www.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">"../app.js"</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; ApolloServer &#125; = <span class="built_in">require</span>(<span class="string">"apollo-server-koa"</span>);</span><br><span class="line"><span class="keyword">const</span> typeDefs = <span class="built_in">require</span>(<span class="string">"../model/schema/index.js"</span>);</span><br><span class="line"><span class="keyword">const</span> resolvers = <span class="built_in">require</span>(<span class="string">"../model/resolver/index.js"</span>);</span><br><span class="line"><span class="comment">// 引入数据源</span></span><br><span class="line"><span class="keyword">const</span> db = <span class="built_in">require</span>(<span class="string">"../data/mysql.config.js"</span>);</span><br><span class="line"><span class="comment">// 实例化 ApolloServer</span></span><br><span class="line"><span class="keyword">const</span> server = <span class="keyword">new</span> ApolloServer(&#123;</span><br><span class="line">    typeDefs,</span><br><span class="line">    resolvers,</span><br><span class="line">    dataSources: <span class="function"><span class="params">()</span> =&gt;</span> (&#123; db &#125;),</span><br><span class="line">    context: <span class="function">(<span class="params">app</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> method = app.ctx.method;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            method,</span><br><span class="line">            uid: <span class="string">"20202020"</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    tracing: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>关键代码是第 6 行和第 11 行，</p><h4 id="context-对象"><a href="#context-对象" class="headerlink" title="context 对象"></a>context 对象</h4><p>另外我往里边传了<code>context</code>对象，这是非必要的，有<code>context</code>对象之后我们可以在 resolver 中使用他们，如上面这段代码中返回了当前请求的方法和一个<code>uid</code>，我们在 resolver 里边就能使用这两个变量，具体怎么使用将在下一小节中阐述。<code>context</code>对象是很有用的，比如通过 JWT 验证请求者身份之后，可以将记录这个身份的信息传给 resolver，接着 resolver 将这个信息作为数据库查询参数。</p><h3 id="在-resolver-中使用数据源"><a href="#在-resolver-中使用数据源" class="headerlink" title="在 resolver 中使用数据源"></a>在 resolver 中使用数据源</h3><p>使用数据源就比较简单了，和我们之前写简单的 GraphQL 服务一样，在<code>model/resolver/index.js</code>中写 resolver 方法：</p><figure class="highlight javascript"><figcaption><span>model/resolver/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolvers = &#123;</span><br><span class="line">    Query: &#123;</span><br><span class="line">        <span class="keyword">async</span> books(_source, _args, &#123; dataSources &#125;) &#123;</span><br><span class="line">            <span class="keyword">return</span> dataSources.db.getAllBooks();</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = resolvers;</span><br></pre></td></tr></table></figure><p>通过前面的一系列构造，我们之前编写的数据库操作方法可以通过<code>dataSources.db</code>来访问，你可以使用<code>await</code>，也可以不使用，因为 resolver 的返回值可以是 Promise 对象，这主要取决于你的数据库操作方法是如何写的。</p><p>我们注意到每一个结构的<code>resolver</code>还有几个参数，resolver 可以接收四个参数，最常用的就是上面这段代码中写到的前三个参数。</p><h4 id="第一个参数parent"><a href="#第一个参数parent" class="headerlink" title="第一个参数parent"></a>第一个参数<code>parent</code></h4><p>上面的代码中是<code>_source</code>，代表上一级解析器的返回值，因为 Schema 中定义的结构体是可以嵌套的，所以出现了多级选择器的概念，GraphQL 的解析顺序是从最外层解析的，返回最外层的解析结果之后才进行下一级解析，我们可以通过这个参数获取上一级的返回值然后将这个值作为下一级的参数</p><h4 id="第二个参数args"><a href="#第二个参数args" class="headerlink" title="第二个参数args"></a>第二个参数<code>args</code></h4><p>上面的代码中是<code>_args</code>，顾名思义是参数的意思，指 GraphQL 查询中传递的参数如：</p><figure class="highlight plain"><figcaption><span>GraphQL</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">    book(id: 10)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设这是查询 id 为 10 的书籍信息，那么 resolver 中可以这样写：</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolvers = &#123;</span><br><span class="line">    Query: &#123;</span><br><span class="line">        <span class="keyword">async</span> books(_source, _args, &#123; dataSources &#125;) &#123;</span><br><span class="line">            <span class="keyword">return</span> dataSources.db.getAllBooks(_args.id);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = resolvers;</span><br></pre></td></tr></table></figure><p>然后在数据库操作方法的函数中接收这个参数。</p><h4 id="第三个参数context"><a href="#第三个参数context" class="headerlink" title="第三个参数context"></a>第三个参数<code>context</code></h4><p>第三个参数是上下文，由此可见，构造器其实是将我们的数据源<code>db</code>放在了上下文之中，<code>dataSources.db</code>则是我们的数据源，还记得之前传入<code>ApolloServer</code>的配置文件吗，我传入了一个 context 对象，ApolloServer 将它作为<code>db</code>对象的一个属性，这一点我不清楚为什么要这么设计，访问配置文件中传入的<code>context</code>对象通过如下方式获取：</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolvers = &#123;</span><br><span class="line">    Query: &#123;</span><br><span class="line">        <span class="keyword">async</span> books(_source, _args, &#123; dataSources &#125;) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(dataSourses.db.context.uid); <span class="comment">// 20202020</span></span><br><span class="line">            <span class="keyword">return</span> dataSources.db.getAllBooks();</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果你从头看完，至此相信你已经从零入门了，以上讲述的内容已经足够你开发一个功能完善的 GraphQL 服务器了，此外，不理解的话可以去 Apollo GraphQL 的<a href="https://www.apollographql.com/">官方网站</a>看看。</p><h1 id="Apollo-Vue"><a href="#Apollo-Vue" class="headerlink" title="Apollo Vue"></a>Apollo Vue</h1><article class="message message-immersive is-warning"><div class="message-body"><p>本文作者：KylinLee</p><p>本文链接：<a href="https://kylin.dev/2020/07/07/Apollo-GraphQL快速上手/">https://kylin.dev/https://kylin.dev/2020/07/07/Apollo-GraphQL快速上手</a></p><p>版权声明：本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p></div></article>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上次课程设计做完之后就放松了一阵子，过了这么久才来更新博客其实内心是不好受的，感觉生活缺少了什么。本文就从 0 开始，理一下我的开发流程及 Apollo 的基本的使用。&lt;/p&gt;
&lt;div class=&quot;message message-immersive is-success&quot;&gt;
&lt;div class=&quot;message-body&quot;&gt;
&lt;p&gt;如果你不打算使用 Apollo 来开发，没关系，抛开框架本身你可以了解到 GraphQL 的运行方式。&lt;/p&gt;
&lt;p&gt;如果你觉得看英文文档不方便，阅读这篇文章也是一个不错的选择。&lt;/p&gt;
&lt;p&gt;本文假设你对GraphQL有一定的了解。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
    
    </summary>
    
    
      <category term="Code" scheme="https://kylin.dev/categories/Code/"/>
    
    
      <category term="JavaScript" scheme="https://kylin.dev/tags/JavaScript/"/>
    
      <category term="GraphQL" scheme="https://kylin.dev/tags/GraphQL/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的协程</title>
    <link href="https://kylin.dev/2020/06/13/JavaScript%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B/"/>
    <id>https://kylin.dev/2020/06/13/JavaScript%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B/</id>
    <published>2020-06-13T15:24:56.000Z</published>
    <updated>2020-06-15T07:51:24.173Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本篇是《<a href="/2020/06/13/%E5%B0%9D%E8%AF%95%E7%94%A8%E9%80%9A%E4%BF%97%E7%9A%84%E6%96%B9%E5%BC%8F%E8%A7%A3%E9%87%8A%E5%8D%8F%E7%A8%8B/" title="尝试用通俗的方式解释协程">尝试用通俗的方式解释协程</a>》的续集，上一篇梳理了一遍协程的概念，现在我们用 JavaScript 为例更深入的了解协程。</p><a id="more"></a><h1 id="协程长啥样"><a href="#协程长啥样" class="headerlink" title="协程长啥样"></a>协程长啥样</h1><p>直接上代码看看 JavaScript 中协程是怎样的：</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">idMaker</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) <span class="keyword">yield</span> index++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> gen = idMaker(); <span class="comment">// "Generator &#123; &#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>没错，就是一个生成器，生成器本身是一个函数，也就是说在 JavaScript 中协程是由一个生成器函数实现的。</p><h1 id="协程如何切换"><a href="#协程如何切换" class="headerlink" title="协程如何切换"></a>协程如何切换</h1><p>协程本身是个函数，协程之间的切换本质是函数执行权的转移。</p><p>生成器函数的<code>yield</code>关键字有可以交出函数的执行权，挂起自身，然后 JavaScript 引擎，去执行这个函数后面的语句，在上面这个例子中，第 8 行调用<code>gen.next()</code>开始执行生成器函数的内容，第一次<code>while</code>循环里<code>yield</code>交出了执行权，JavaScript 引擎转而执行第 9 行，再次调用<code>gen.next()</code>，这时候 JavaScript 接着上次挂起的地方执行，不会重新执行<code>let index = 0</code>语句，然后执行函数内的语句，对于这个例子，使用<code>yield</code>和<code>next()</code>方法就能不断的交出和恢复函数的执行权，怎么样，是不是有点感觉了？站在一个线程的角度看，线程的切换就是这样不断让 CPU 暂停和继续对自己执行。</p><p>上面这个例子是把生成器函数的执行权交给普通函数（你也可以把非协程看做是一个协程整体），也可以在一个协程中调用另一个协程，实现协程之间的切换，比如这个例子：</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">anotherGenerator</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> i + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> i + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generator</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> i;</span><br><span class="line">    <span class="keyword">yield</span>* anotherGenerator(i); <span class="comment">// 移交执行权</span></span><br><span class="line">    <span class="keyword">yield</span> i + <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = generator(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 13</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>第 9 行使用<code>yield*</code>将执行权交给另一个生成器函数，接下来要等到这个生成器函数<code>anotherGenertor()</code>执行完毕执行权才会回到<code>generator</code>函数。这和普通函数表现一致，都是后进先出，如果感兴趣可以去看看 JavaScript 事件循环机制（Event Loop），本篇就不再多说了。</p><h1 id="协程如何实现异步"><a href="#协程如何实现异步" class="headerlink" title="协程如何实现异步"></a>协程如何实现异步</h1><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>搞清楚什么是同步，什么是异步，问题才能很好的讨论下去。先说同步：</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">res = <span class="function"><span class="keyword">function</span> <span class="title">fetchFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 请求资源</span></span><br><span class="line">    <span class="comment">// res = ....</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br></pre></td></tr></table></figure><p>计算机按照程序顺序执行代码，比如这几行代码一定第三行先给<code>res</code>赋值，然后才是打印<code>res</code>，而非同步（即异步）可以先执行后面的<code>console.log(res)</code>，然后再给<code>res</code>赋值。</p><p>为什么需要这么做呢，当一个请求需要耗费大量的时间，程序执行一直停留在这一行，就会引发阻塞，最容易受影响的是<code>eventListener</code>，事件监听没了，在请求数据的时候点击事件都是无效的。</p><p>所以实现异步的关键就是把会阻塞线程函数的执行权交出去，让这个函数等待恢复执行，等待的时间内请求（或者其他异步任务）也该执行完了，这时候再来继续执行这个函数。通过前面对协程的运行方式的讲解我们很容易就能想到用协程来解决这个问题，利用<code>yield</code>挂起这个阻塞线程函数，然后继续执行后面的语句，等这个函数不再阻塞了，再回到这个函数继续执行。那么问题来了，应该什么时候继续执行这个挂起的函数呢？你可能想到大概估计一下阻塞时间，设定时间再回来执行，这个方案。。。有点牵强。</p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>这时候 Promise 就派上用场了，Promise 本质是一个状态机，用于表示一个异步操作的最终完成 (或失败), 及其结果值。它有三个状态：</p><ul><li>pending: 初始状态，既不是成功，也不是失败状态。</li><li>fulfilled: 意味着操作成功完成。</li><li>rejected: 意味着操作失败。</li></ul><p>最终 Promise 会有两种状态，一种成功，一种失败，当 pending 变化的时候，Promise 对象会根据最终的状态调用不同的处理函数。</p><p>根据 Promise 的特点，他是一个状态机，在<code>yield</code>之后可以用 Promise 来表示异步任务是否执行完毕（是否是 pending 状态），并且还能够自动判别异步任务成功与否（fulfilled 还是 rejected）并执行处理函数。如此看来用协程+Promise 可以完美实现异步。</p><p>好的，让我们来根据上面的理论实现一下吧：</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟阻塞事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveAfter2Seconds</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(val);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现生成器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">coroutineFunc</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> resolveAfter2Seconds(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> doIt = coroutineFunc(<span class="string">"OK"</span>);</span><br><span class="line"><span class="keyword">let</span> value = doIt.next().value;</span><br><span class="line"><span class="comment">// value是Promise对象</span></span><br><span class="line">value.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 模拟后面被阻塞的语句</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的输出顺序是 0=&gt;1=&gt;2=&gt;…=&gt;9，两秒之后输出’OK’，从输出顺序来看我们已经实现了异步。其执行过程和之前说的一样，挂起会阻塞运行的函数，继续执行后面的语句，等待 Promise 改变状态并自动执行处理函数。</p><h2 id="使用-Generator、Promise-组合和直接使用-Promise-的区别"><a href="#使用-Generator、Promise-组合和直接使用-Promise-的区别" class="headerlink" title="使用 Generator、Promise 组合和直接使用 Promise 的区别"></a>使用 Generator、Promise 组合和直接使用 Promise 的区别</h2><p>实际上下面这段代码运行顺序的结果和上面一模一样：</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveAfter2Seconds</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(val);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resolveAfter2Seconds(<span class="string">"OK"</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>为什么要使用上面那种复杂的写法呢？为了简化问题，便于理解，我已经简化了代码，在前一个例子中，生成器函数内，11 行以后完全可以写更多的代码，这些代码一定是在异步获取到数据之后才执行的。如果直接使用 Promise 需要把这些代码放在 then 代码块里边才能保证在异步获取到值之后执行，那么当有多个异步事件的时候问题就来了——可怕的嵌套！</p><h1 id="Async、Await"><a href="#Async、Await" class="headerlink" title="Async、Await"></a>Async、Await</h1><p>ECMAscript2017 中提供了更高级的协程控制语法，其被看做是对 Generator 和 Promise 组合的封装，使异步函数看起来更像同步函数，减轻开发者的痛苦。上面的例子改写：</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveAfter2Seconds</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(x);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="keyword">await</span> resolveAfter2Seconds(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(x); <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 Async、Await 实现了 Generator 的自动迭代，不需要手动使用<code>next()</code>方法来继续执行。正因为 Async、Await 是对 Generator 和 Promise 组合的封装，所以 Async 和 Await 基本上就只能用来实现异步和并发了，而不具有协程的其他作用。</p><article class="message message-immersive is-warning"><div class="message-body"><p>本文作者：KylinLee</p><p>本文链接：<a href="https://kylin.dev/2020/06/13/JavaScript中的协程">https://kylin.dev/2020/06/13/JavaScript中的协程</a></p><p>版权声明：本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p></div></article>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇是《&lt;a href=&quot;/2020/06/13/%E5%B0%9D%E8%AF%95%E7%94%A8%E9%80%9A%E4%BF%97%E7%9A%84%E6%96%B9%E5%BC%8F%E8%A7%A3%E9%87%8A%E5%8D%8F%E7%A8%8B/&quot; title=&quot;尝试用通俗的方式解释协程&quot;&gt;尝试用通俗的方式解释协程&lt;/a&gt;》的续集，上一篇梳理了一遍协程的概念，现在我们用 JavaScript 为例更深入的了解协程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Code" scheme="https://kylin.dev/categories/Code/"/>
    
    
      <category term="JavaScript" scheme="https://kylin.dev/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>尝试用通俗的方式解释协程</title>
    <link href="https://kylin.dev/2020/06/13/%E5%B0%9D%E8%AF%95%E7%94%A8%E9%80%9A%E4%BF%97%E7%9A%84%E6%96%B9%E5%BC%8F%E8%A7%A3%E9%87%8A%E5%8D%8F%E7%A8%8B/"/>
    <id>https://kylin.dev/2020/06/13/%E5%B0%9D%E8%AF%95%E7%94%A8%E9%80%9A%E4%BF%97%E7%9A%84%E6%96%B9%E5%BC%8F%E8%A7%A3%E9%87%8A%E5%8D%8F%E7%A8%8B/</id>
    <published>2020-06-13T09:22:44.000Z</published>
    <updated>2020-07-07T10:09:45.468Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>协程（英文：Coroutine）这个概念其实并不复杂，但我却花了很多时间理解，后来仔细一想，大概是因为这个概念穿插了很多别的概念，所以这篇文章将这些概念全部疏通一遍再来理解协程。</p><div class="message message-immersive is-warning"><div class="message-body"><p>除了协程，通过本文你将对进程、线程、并发有一定的了解</p></div></div><a id="more"></a><p><a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E7%A8%8B">维基百科</a>是这么定义的：</p><blockquote><p>协程是计算机程序的一类组件，推广了协作式多任务的子程序，允许执行被挂起与被恢复。相对子例程而言，协程更为一般和灵活，但在实践中使用没有子例程那样广泛。</p></blockquote><p>字我都认识，可连起来是什么意思？这就是本文写作的目的。</p><h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><p>协程和线程对比起来更容易理解，因为他俩实在太像了。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程（英语：thread）是操作系统能够进行运算调度的最小单位。大部分情况下，它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p><p>那么什么是进程呢？</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是程序运行的一个实例（字面拆解为正在进行的程序），一个程序是静态的二进制文件，是没有灵魂的，当我们启动程序时就会开启一个进程，这个时候系统开始读取程序的二进制文件，并且向系统申请一些资源。</p><p>总结起来进程就是一个程序运行的时候系统环境变量和用到的资源以及本身代码的集合，其特点是每个 CPU 核心任何时间内仅能运行一项进程，即同一时刻执行的进程数不会超过核心数，这对支持更高并发是个阻碍，并且为了解决进程阻塞的问题，操作系统遍引入了更轻量的线程。</p><p>进程资源分配的最小单位，线程是操作系统能够进行运算调度的最小单位。可以这么理解：在进程这个大圈子中，存在着各种资源，在没有线程时，这些资源全部由一个可执行代码调配，这有点像单线程进程。当引入线程之后，一个进程下可以有很多线程，相当于一个可执行代码被分成了很多段，这些片段可以单独执行，并且使用所在进程内的资源。</p><p>当然，要使一个应用程序完整运行起来就必须要把这些细分的线程全都执行起来，于是便需要时间片轮转。操作系统为每一个线程分配 CPU 执行时间（通常为几百毫秒），当运行这个线程的时间超过分配的执行时间时，系统会强制 CPU 去执行下一个等待的线程（补充一下，线程和进程都是有状态的，这里这个正在”等待“的线程应该是”中断“状态），如此快速的不断切换线程便实现了并发。同时程序运行的时候也只会出现线程阻塞，而不是整个进程阻塞，如此便解决了上面的问题。</p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>不知不觉提到了并发，根据上面的描述不难看出，并发是指一段时间内（程序开始运行到结束的这段时间）执行多个程序（线程算是一个进程的子程序）。</p><h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p>上面提到，线程是为了解决阻塞和并发的并发问题（在一段时间内执行更多的程序），类似的，协程也是为了在一段时间运行更多的“程序”（应该说是函数）并且可以避免线程阻塞。有了之前的铺垫，类比起来讲协程就很容易了。</p><p>线程和协程解决的并发问题不是一个问题，线程是为了让操作系统并发运行程序，以达到”同时“运行更多程序的目的，而协程是为了让一个线程内的程序并发服务更多内容，这里我不太好解释，一个直观的例子就是一个单线程的服务器程序同时服务多个用户，如何做到服务更多用户？想想线程是怎么来的，我们只需要把这个线程中的程序继续细分，然后像时间片轮转一样不断的去执行这些细分的“子程序”。即使一个这样的“子程序”执行发生阻塞，也不会导致整个线程阻塞，在这个“子程序”阻塞的时候切换到其他“子程序”继续服务，既解决了阻塞的问题，也实现了并发。大概理解了吧，协程就是线程中可以交替运行的代码片段。</p><p>下面说说真实的协程，线程切换是由操作系统的时间片控制的，而协程是程序自己实现的，让协程不断轮流执行才是实现并发，所以实现协程还必须要有一个类似于时间片的结构，不同于线程的切换，协程的切换不是按照时间来算的，而是按照代码既定分配，就是说代码运行到这一行才启动协程，协程是可以由我们程序员自己操控的。</p><p>所以尝试控制这些协程是很有趣的事，一起期待下一篇《<a href="/2020/06/13/JavaScript%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B/" title="JavaScript中的协程">JavaScript中的协程</a>》吧！</p><article class="message message-immersive is-warning"><div class="message-body"><p>本文作者：KylinLee</p><p>本文链接：<a href="https://kylin.dev/2020/06/13/尝试用通俗的方式解释协程">https://kylin.dev/2020/06/13/尝试用通俗的方式解释协程</a></p><p>版权声明：本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p></div></article>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;协程（英文：Coroutine）这个概念其实并不复杂，但我却花了很多时间理解，后来仔细一想，大概是因为这个概念穿插了很多别的概念，所以这篇文章将这些概念全部疏通一遍再来理解协程。&lt;/p&gt;
&lt;div class=&quot;message message-immersive is-warning&quot;&gt;
&lt;div class=&quot;message-body&quot;&gt;
&lt;p&gt;除了协程，通过本文你将对进程、线程、并发有一定的了解&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
    
    </summary>
    
    
      <category term="Code" scheme="https://kylin.dev/categories/Code/"/>
    
    
      <category term="Other" scheme="https://kylin.dev/tags/Other/"/>
    
      <category term="Concept" scheme="https://kylin.dev/tags/Concept/"/>
    
  </entry>
  
  <entry>
    <title>浅谈GraphQL的尴尬</title>
    <link href="https://kylin.dev/2020/05/30/%E6%B5%85%E8%B0%88GraphQL%E7%9A%84%E5%B0%B4%E5%B0%AC/"/>
    <id>https://kylin.dev/2020/05/30/%E6%B5%85%E8%B0%88GraphQL%E7%9A%84%E5%B0%B4%E5%B0%AC/</id>
    <published>2020-05-30T08:47:21.000Z</published>
    <updated>2020-06-02T10:07:52.042Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本人某校大二学生，最近忙于数据库课设，其中用到了 <a href="https://graphql.cn/">GraphQL</a>，碰巧在知乎上看到了<a href="https://www.zhihu.com/question/38596306">GraphQL 为何没有火起来？</a>这个问题，虽然是刚用到 GraphQL，但对于这个问题还是有一点想法，的所以这里就浅浅的聊一下 GraphQL 的尴尬吧。</p><a id="more"></a><h1 id="GraphQL-的好处"><a href="#GraphQL-的好处" class="headerlink" title="GraphQL 的好处"></a>GraphQL 的好处</h1><p>因为刚开始用上，没有很深入的去研究 GraphQL 的好处，我只能列出在使用过程中发现的一些好处：</p><h2 id="弹性-API-查询"><a href="#弹性-API-查询" class="headerlink" title="弹性 API 查询"></a>弹性 API 查询</h2><p>由前端传来的查询参数，需要哪些内容由由前端决定，可多可少，减少返回数据冗余。直接好处就是对于不同的 C 端（Web、App、小程序等），可能需要展示不同的内容，有的数据需要，有的数据不需要，使用 GraphQL 可以不用改后端代码，定制想要的数据字段。</p><h2 id="减少路由"><a href="#减少路由" class="headerlink" title="减少路由"></a>减少路由</h2><p>RESTful 往往会使用到许多路由，服务器对大量路由的解析会延长响应时间，对于 GraphQL，只需要设置一个路由而不需要大量的路由解析，并且方便 API 的管理。</p><h2 id="减少请求次数"><a href="#减少请求次数" class="headerlink" title="减少请求次数"></a>减少请求次数</h2><p>根据上面所说的，我们只需要一个路由，并且可以自定义需要的数据字段，那么对于一个页面，完全可以只发送一个请求来获取所有数据。</p><h2 id="更少的代码"><a href="#更少的代码" class="headerlink" title="更少的代码"></a>更少的代码</h2><p>这是对于服务端来说的，对于查询同一内容，不需要重新再写一遍，只需要一个 <code>resolver</code> 就行了。</p><h2 id="更好的前后端联调"><a href="#更好的前后端联调" class="headerlink" title="更好的前后端联调"></a>更好的前后端联调</h2><p>在开发前期，只要后端给出 GraphQL 接口或者说 <code>Schema</code> 确定，那么在前端就能够通过 <code>GraphQL PlayGround</code> 很轻松的模拟数据，<code>GraphQL PlayGround</code> 就相当于一份 API 文档。而且因为 GraphQL 严格的类型系统，也直接在开发阶段解决掉了类型不相同的问题。</p><h1 id="GraphQL-现状"><a href="#GraphQL-现状" class="headerlink" title="GraphQL 现状"></a>GraphQL 现状</h1><p>我认为现在 GraphQL 目前处在一种进退两难的局面之中，2015 年 GraphQL 正式发布，到现在仅仅 5 年的时间，在圈子中颇具影响力，也获得了很多的关注，可以算得上是新秀。这势头太强劲，是导致 GraphQL 现在窘境的一个原因，如果它发展的慢一点，人们可以慢慢的接受，和现在是不一样的局面吧。</p><p>首先要肯定的是 GraphQL 必定会成为未来的 API 查询语言，所以人们炒的很火，但在短期内无法改变仍然开发 RESTful 的局面，这就是发展太快带来的窘境吧。明明很强，大家也很喜欢，但用的人不多，作为 GraphQL 表示很尴尬啊。</p><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>一个很现实的问题就是，如果一个公司全部都是使用的 RESTful，现在改为使用 GraphQL，那不是要重写了？这对于一个大公司来说是伤筋动骨的事，搞不好服务崩溃，所以对于这些公司来说，继续使用 RESTful 花销会比改用 GraphQL 低得多，GraphQL 带来的好处远不如这些花销。</p><p>有些人认为需要前后端都支持是 GraphQL 没有被大量用起来的一个原因，但我对这个说法是不认可的，有需求就有技术支持，究其原因还是上面说的，有需求但没有必要。</p><h1 id="兼容方案"><a href="#兼容方案" class="headerlink" title="兼容方案"></a>兼容方案</h1><p>为了解决上面这个问题，也有一些兼容性方案。</p><p>在课设项目的开发中我使用的是<a href="https://www.apollographql.com/docs/apollo-server/">ApolloServer</a>，其中 ApolloServer 提供了两类数据源，一类是 RESTful API 数据源，一类是自定义数据源，RESTful API 数据源允许你不改变 RESTful API 来使用 GraphQL 进行查询，虽然看起来是很友好的，但当你使用 GraphQL 查询的内容令一个 RESTful API 不能完整提供的时候，会带来一些问题，举个简单的例子：</p><p>RESTful API 请求的字段都是固定的，前后端设定一致，就是说客户端直接请求 RESTful API，返回的数据中冗余很少，而 GraphQL 查询中需要的内容由前端来定，往往一个 GraphQL 查询会伴随着多个 RESTful API 请求，而最终是不需要用到所有数据的，这就出现了数据冗余，浪费了资源。</p><p>而如果 RESTful API 请求和 GraphQL 查询的内容完全吻合，那相比于直接使用 RESTful API 请求，使用 GraphQL 查询多了一次请求，这就是鸡肋的存在啊。</p><p>所以我认为这种兼容并不是完美的，反而会带来更多的资源消耗，并没有达到让大家迁移到 GraphQL 的目的。</p><p>以上就是入门级码农对 GraphQL 尴尬境地的浅显描述。如果大家有什么想法，欢迎留言评论。</p><article class="message message-immersive is-warning"><div class="message-body"><p>本文作者：KylinLee</p><p>本文链接：<a href="https://kylin.dev/2020/05/30/浅谈GraphQL的尴尬">https://kylin.dev/2020/05/30/浅谈GraphQL的尴尬</a></p><p>版权声明：本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p></div></article>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本人某校大二学生，最近忙于数据库课设，其中用到了 &lt;a href=&quot;https://graphql.cn/&quot;&gt;GraphQL&lt;/a&gt;，碰巧在知乎上看到了&lt;a href=&quot;https://www.zhihu.com/question/38596306&quot;&gt;GraphQL 为何没有火起来？&lt;/a&gt;这个问题，虽然是刚用到 GraphQL，但对于这个问题还是有一点想法，的所以这里就浅浅的聊一下 GraphQL 的尴尬吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Code" scheme="https://kylin.dev/categories/Code/"/>
    
    
      <category term="GraphQL" scheme="https://kylin.dev/tags/GraphQL/"/>
    
  </entry>
  
  <entry>
    <title>开始踩坑GoWeb</title>
    <link href="https://kylin.dev/2020/05/28/%E5%BC%80%E5%A7%8B%E8%B8%A9%E5%9D%91GoWeb/"/>
    <id>https://kylin.dev/2020/05/28/%E5%BC%80%E5%A7%8B%E8%B8%A9%E5%9D%91GoWeb/</id>
    <published>2020-05-28T15:26:18.000Z</published>
    <updated>2020-05-29T09:21:12.199Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这是我第一次使用 GoLang 进行 Web 开发，以前用的是 Koa 和 ThinkPHP 进行 Web 后端的开发，也算是有一些经验吧，这篇文章用来记录开发第一个小时遇到的问题。</p><div class="message message-immersive is-success"><div class="message-body"><p>如果你是GoLang的初学者，并且使用的第一个外部包是 <a href="https://github.com/kataras/iris" target="_blank">iris</a> ，那么这篇文章对你相当有帮助。</p></div></div><a id="more"></a><p>问：开发前一个小时我们在做什么？<br>答：打造开发环境和 initialize。</p><h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><p>开发环境倒是不用配置，这个在安装 GoLang 的时候就配置好了，只需要提一点就行了，后面会提到。</p><h2 id="关于GOPATH"><a href="#关于GOPATH" class="headerlink" title="关于GOPATH"></a>关于<code>GOPATH</code></h2><p>它指定软件包源代码所在的目录，<code>$GOPATH</code> 默认采用和 <code>$GOROOT</code>（GO 的安装目录） 一样的值，但从 Go 1.1 版本开始，你必须修改为其它路径。它可以包含多个包含 Go 语言源码文件、包文件和可执行文件的路径，而这些路径下又必须分别包含三个规定的目录：src、pkg 和 bin，这三个目录分别用于存放源码文件、包文件和可执行文件。</p><h1 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h1><p>我使用的是<a href="https://github.com/kataras/iris">iris</a>，这个 Web 框架，选择这个框架的原因主要参考了<a href="https://github.com/speedwheel/awesome-go-web-frameworks/blob/master/README.md">Awesome Web Frameworks for Gophers</a>这篇文章，毫无疑问，我认为这将是未来几年最具潜力的框架，在开源 GoWeb 框架中性能是最强的，社区也是最活跃的，学习曲线相对容易。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>按照官方文档首先使用<code>go-get</code>从 GitHub 上将外部包下载到本地，但在国内的话一般是不成功的。</p><figure class="highlight bash"><figcaption><span>PowerShell</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/kataras/iris/v12@latest</span><br></pre></td></tr></table></figure><p>所以我通过百度找到了热心网友，网友的帖子上说需要先设置<code>GO111MODULE</code>这个环境变量为<code>on</code>，然后设置代理（为了避免从 GitHub 下载源码网速慢而下载失败），根据你的操作系统执行下面两条命令：</p><figure class="highlight bash"><figcaption><span>MacOS/Linux bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Enable the go modules feature</span></span><br><span class="line"><span class="built_in">export</span> GO111MODULE=on</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the GOPROXY environment variable</span></span><br><span class="line"><span class="built_in">export</span> GOPROXY=https://goproxy.io</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>Windows PowerShell</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Enable the go modules feature</span></span><br><span class="line"><span class="variable">$env</span>:GO111MODULE=<span class="string">"on"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the GOPROXY environment variable</span></span><br><span class="line"><span class="variable">$env</span>:GOPROXY=<span class="string">"https://goproxy.io"</span></span><br></pre></td></tr></table></figure><p>现在我们写入一段示例代码来测试一下：</p><figure class="highlight go"><figcaption><span>GoProjectDir/main.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/kataras/iris"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    app := iris.New()</span><br><span class="line">    app.Handle(<span class="string">"GET"</span>, <span class="string">"/welcome"</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx iris.Context)</span></span> &#123;</span><br><span class="line">        ctx.HTML(<span class="string">"&lt;h1&gt;Welcome&lt;/h1&gt;"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    app.Run(iris.Addr(<span class="string">":8080"</span>)) <span class="comment">//8080 监听端口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候 Goland 报错了，告诉我们无法找到引用的包。</p><h1 id="问题在哪？"><a href="#问题在哪？" class="headerlink" title="问题在哪？"></a>问题在哪？</h1><p>这时候我们会很自然的去看这个包是不是真的下载到本地了，于是我们上去<code>GOPATH</code>目录去找，发现目录下只有<code>pkg</code>文件夹，而没有<code>src</code>源文件文件夹。</p><figure class="highlight bash"><figcaption><span>output</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PS F:\ProjectFiles\Go&gt; <span class="built_in">cd</span> <span class="variable">$env</span>:gopath</span><br><span class="line">PS E:\Application\GOPATH&gt; ls</span><br><span class="line"></span><br><span class="line">    Directory: E:\Application\GOPATH</span><br><span class="line"></span><br><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line">----                 -------------         ------ ----</span><br><span class="line">d----           2020/5/28    21:35                pkg</span><br></pre></td></tr></table></figure><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>正常情况下，引入一个外部包时会在<code>GOPATH</code>下的<code>src</code>目录进行包的查找，很明显没有这个文件夹是导致错误的直接原因。</p><p>为什么会这样呢？</p><p>你可能已经注意到我们之前设置了一个环境变量<code>GO111MODULE=on</code>，安装包的时候默认采用是 GOPATH 的模式（GO 最初的依赖管理系统），就是把包的源码放进<code>src</code>目录，而当我们设置了上面这个环境变量的时候就会使用 GoMod 模式，它使用 Go Module 的方式管理包，可以理解为 Module 是 Go packages 的集合。</p><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>使用了不同的依赖管理系统就要用不同的方式，如果你用过 Node 就很好理解，每个 Node 项目都会有一个<code>package.json</code>，里边描述了项目和依赖的信息。对于 GoMod 而言，每一个 Go 项目需要一个<code>go.mod</code>文件来描述这些信息。接着上面的操作，创建一个<code>go.mod</code>文件：</p><figure class="highlight bash"><figcaption><span>PowerShell</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod init `你的包名，通常是项目名称`</span><br></pre></td></tr></table></figure><p>初始化之后里面还没有依赖，在项目文件夹重新使用<code>go-get</code>安装一下包，因为<code>GOPATH</code>已经有了，所以这次直接建立了引用而不需要下载了。现在重新 run 一下，已经没有问题了。</p><p>如果你的 GoLand 仍然提示有错误，在设置中的 GOPATH 配置添加上面设置的环境变量即可。</p><h1 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h1><ol><li>不要随便复制别人的操作，比如说如果没有设置<code>GO111MODULE=on</code>，只设置代理，那么后面的问题都不会出现。</li><li>但是还是推荐使用 GoMod 这种依赖管理方式，因为你可以对项目的依赖轻松进行删除，升级，添加等操作。</li><li>之所以出现这个问题，另外一个原因是，GoMod 是在 2018 年提出使用的，我看的中文文档版本太老压根没有提到，初来乍到，没有关注行情。</li></ol><article class="message message-immersive is-warning"><div class="message-body"><p>本文作者：KylinLee</p><p>本文链接：<a href="https://kylin.dev/2020/05/28/开始踩坑GoWeb">https://kylin.dev/2020/05/28/开始踩坑GoWeb</a></p><p>版权声明：本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p></div></article>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是我第一次使用 GoLang 进行 Web 开发，以前用的是 Koa 和 ThinkPHP 进行 Web 后端的开发，也算是有一些经验吧，这篇文章用来记录开发第一个小时遇到的问题。&lt;/p&gt;
&lt;div class=&quot;message message-immersive is-success&quot;&gt;
&lt;div class=&quot;message-body&quot;&gt;
&lt;p&gt;如果你是GoLang的初学者，并且使用的第一个外部包是 &lt;a href=&quot;https://github.com/kataras/iris&quot; target=&quot;_blank&quot;&gt;iris&lt;/a&gt; ，那么这篇文章对你相当有帮助。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
    
    </summary>
    
    
      <category term="Code" scheme="https://kylin.dev/categories/Code/"/>
    
    
      <category term="GoLang" scheme="https://kylin.dev/tags/GoLang/"/>
    
  </entry>
  
</feed>
