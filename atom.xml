<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>蝶恋花-等风也等你</title>
  
  <subtitle>等风也等你</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kylin.dev/"/>
  <updated>2020-06-15T07:51:24.173Z</updated>
  <id>https://kylin.dev/</id>
  
  <author>
    <name>Kylin Lee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript中的协程</title>
    <link href="https://kylin.dev/2020/06/13/JavaScript%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B/"/>
    <id>https://kylin.dev/2020/06/13/JavaScript%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B/</id>
    <published>2020-06-13T15:24:56.000Z</published>
    <updated>2020-06-15T07:51:24.173Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本篇是《<a href="/2020/06/13/%E5%B0%9D%E8%AF%95%E7%94%A8%E9%80%9A%E4%BF%97%E7%9A%84%E6%96%B9%E5%BC%8F%E8%A7%A3%E9%87%8A%E5%8D%8F%E7%A8%8B/" title="尝试用通俗的方式解释协程">尝试用通俗的方式解释协程</a>》的续集，上一篇梳理了一遍协程的概念，现在我们用 JavaScript 为例更深入的了解协程。</p><a id="more"></a><h1 id="协程长啥样"><a href="#协程长啥样" class="headerlink" title="协程长啥样"></a>协程长啥样</h1><p>直接上代码看看 JavaScript 中协程是怎样的：</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">idMaker</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) <span class="keyword">yield</span> index++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> gen = idMaker(); <span class="comment">// "Generator &#123; &#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>没错，就是一个生成器，生成器本身是一个函数，也就是说在 JavaScript 中协程是由一个生成器函数实现的。</p><h1 id="协程如何切换"><a href="#协程如何切换" class="headerlink" title="协程如何切换"></a>协程如何切换</h1><p>协程本身是个函数，协程之间的切换本质是函数执行权的转移。</p><p>生成器函数的<code>yield</code>关键字有可以交出函数的执行权，挂起自身，然后 JavaScript 引擎，去执行这个函数后面的语句，在上面这个例子中，第 8 行调用<code>gen.next()</code>开始执行生成器函数的内容，第一次<code>while</code>循环里<code>yield</code>交出了执行权，JavaScript 引擎转而执行第 9 行，再次调用<code>gen.next()</code>，这时候 JavaScript 接着上次挂起的地方执行，不会重新执行<code>let index = 0</code>语句，然后执行函数内的语句，对于这个例子，使用<code>yield</code>和<code>next()</code>方法就能不断的交出和恢复函数的执行权，怎么样，是不是有点感觉了？站在一个线程的角度看，线程的切换就是这样不断让 CPU 暂停和继续对自己执行。</p><p>上面这个例子是把生成器函数的执行权交给普通函数（你也可以把非协程看做是一个协程整体），也可以在一个协程中调用另一个协程，实现协程之间的切换，比如这个例子：</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">anotherGenerator</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> i + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> i + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generator</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> i;</span><br><span class="line">    <span class="keyword">yield</span>* anotherGenerator(i); <span class="comment">// 移交执行权</span></span><br><span class="line">    <span class="keyword">yield</span> i + <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = generator(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 13</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>第 9 行使用<code>yield*</code>将执行权交给另一个生成器函数，接下来要等到这个生成器函数<code>anotherGenertor()</code>执行完毕执行权才会回到<code>generator</code>函数。这和普通函数表现一致，都是后进先出，如果感兴趣可以去看看 JavaScript 事件循环机制（Event Loop），本篇就不再多说了。</p><h1 id="协程如何实现异步"><a href="#协程如何实现异步" class="headerlink" title="协程如何实现异步"></a>协程如何实现异步</h1><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>搞清楚什么是同步，什么是异步，问题才能很好的讨论下去。先说同步：</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">res = <span class="function"><span class="keyword">function</span> <span class="title">fetchFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 请求资源</span></span><br><span class="line">    <span class="comment">// res = ....</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br></pre></td></tr></table></figure><p>计算机按照程序顺序执行代码，比如这几行代码一定第三行先给<code>res</code>赋值，然后才是打印<code>res</code>，而非同步（即异步）可以先执行后面的<code>console.log(res)</code>，然后再给<code>res</code>赋值。</p><p>为什么需要这么做呢，当一个请求需要耗费大量的时间，程序执行一直停留在这一行，就会引发阻塞，最容易受影响的是<code>eventListener</code>，事件监听没了，在请求数据的时候点击事件都是无效的。</p><p>所以实现异步的关键就是把会阻塞线程函数的执行权交出去，让这个函数等待恢复执行，等待的时间内请求（或者其他异步任务）也该执行完了，这时候再来继续执行这个函数。通过前面对协程的运行方式的讲解我们很容易就能想到用协程来解决这个问题，利用<code>yield</code>挂起这个阻塞线程函数，然后继续执行后面的语句，等这个函数不再阻塞了，再回到这个函数继续执行。那么问题来了，应该什么时候继续执行这个挂起的函数呢？你可能想到大概估计一下阻塞时间，设定时间再回来执行，这个方案。。。有点牵强。</p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>这时候 Promise 就派上用场了，Promise 本质是一个状态机，用于表示一个异步操作的最终完成 (或失败), 及其结果值。它有三个状态：</p><ul><li>pending: 初始状态，既不是成功，也不是失败状态。</li><li>fulfilled: 意味着操作成功完成。</li><li>rejected: 意味着操作失败。</li></ul><p>最终 Promise 会有两种状态，一种成功，一种失败，当 pending 变化的时候，Promise 对象会根据最终的状态调用不同的处理函数。</p><p>根据 Promise 的特点，他是一个状态机，在<code>yield</code>之后可以用 Promise 来表示异步任务是否执行完毕（是否是 pending 状态），并且还能够自动判别异步任务成功与否（fulfilled 还是 rejected）并执行处理函数。如此看来用协程+Promise 可以完美实现异步。</p><p>好的，让我们来根据上面的理论实现一下吧：</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟阻塞事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveAfter2Seconds</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(val);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现生成器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">coroutineFunc</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> resolveAfter2Seconds(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> doIt = coroutineFunc(<span class="string">"OK"</span>);</span><br><span class="line"><span class="keyword">let</span> value = doIt.next().value;</span><br><span class="line"><span class="comment">// value是Promise对象</span></span><br><span class="line">value.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 模拟后面被阻塞的语句</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的输出顺序是 0=&gt;1=&gt;2=&gt;…=&gt;9，两秒之后输出’OK’，从输出顺序来看我们已经实现了异步。其执行过程和之前说的一样，挂起会阻塞运行的函数，继续执行后面的语句，等待 Promise 改变状态并自动执行处理函数。</p><h2 id="使用-Generator、Promise-组合和直接使用-Promise-的区别"><a href="#使用-Generator、Promise-组合和直接使用-Promise-的区别" class="headerlink" title="使用 Generator、Promise 组合和直接使用 Promise 的区别"></a>使用 Generator、Promise 组合和直接使用 Promise 的区别</h2><p>实际上下面这段代码运行顺序的结果和上面一模一样：</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveAfter2Seconds</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(val);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resolveAfter2Seconds(<span class="string">"OK"</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>为什么要使用上面那种复杂的写法呢？为了简化问题，便于理解，我已经简化了代码，在前一个例子中，生成器函数内，11 行以后完全可以写更多的代码，这些代码一定是在异步获取到数据之后才执行的。如果直接使用 Promise 需要把这些代码放在 then 代码块里边才能保证在异步获取到值之后执行，那么当有多个异步事件的时候问题就来了——可怕的嵌套！</p><h1 id="Async、Await"><a href="#Async、Await" class="headerlink" title="Async、Await"></a>Async、Await</h1><p>ECMAscript2017 中提供了更高级的协程控制语法，其被看做是对 Generator 和 Promise 组合的封装，使异步函数看起来更像同步函数，减轻开发者的痛苦。上面的例子改写：</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveAfter2Seconds</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(x);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="keyword">await</span> resolveAfter2Seconds(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(x); <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 Async、Await 实现了 Generator 的自动迭代，不需要手动使用<code>next()</code>方法来继续执行。正因为 Async、Await 是对 Generator 和 Promise 组合的封装，所以 Async 和 Await 基本上就只能用来实现异步和并发了，而不具有协程的其他作用。</p><article class="message message-immersive is-warning"><div class="message-body"><p>本文作者：KylinLee</p><p>本文链接：<a href="https://kylin.dev/2020/06/13/JavaScript中的协程">https://kylin.dev/2020/06/13/JavaScript中的协程</a></p><p>版权声明：本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p></div></article>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇是《&lt;a href=&quot;/2020/06/13/%E5%B0%9D%E8%AF%95%E7%94%A8%E9%80%9A%E4%BF%97%E7%9A%84%E6%96%B9%E5%BC%8F%E8%A7%A3%E9%87%8A%E5%8D%8F%E7%A8%8B/&quot; title=&quot;尝试用通俗的方式解释协程&quot;&gt;尝试用通俗的方式解释协程&lt;/a&gt;》的续集，上一篇梳理了一遍协程的概念，现在我们用 JavaScript 为例更深入的了解协程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Code" scheme="https://kylin.dev/categories/Code/"/>
    
    
      <category term="JavaScript" scheme="https://kylin.dev/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>尝试用通俗的方式解释协程</title>
    <link href="https://kylin.dev/2020/06/13/%E5%B0%9D%E8%AF%95%E7%94%A8%E9%80%9A%E4%BF%97%E7%9A%84%E6%96%B9%E5%BC%8F%E8%A7%A3%E9%87%8A%E5%8D%8F%E7%A8%8B/"/>
    <id>https://kylin.dev/2020/06/13/%E5%B0%9D%E8%AF%95%E7%94%A8%E9%80%9A%E4%BF%97%E7%9A%84%E6%96%B9%E5%BC%8F%E8%A7%A3%E9%87%8A%E5%8D%8F%E7%A8%8B/</id>
    <published>2020-06-13T09:22:44.000Z</published>
    <updated>2020-06-15T04:30:07.728Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>协程（英文：Coroutine）这个概念其实并不复杂，但我却花了很多时间理解，后来仔细一想，大概是因为这个概念穿插了很多别的概念，所以这篇文章将这些概念全部疏通一遍再来理解协程。</p><div class="message message-immersive is-warning"><div class="message-body"><p>除了协程，通过本文你将对进程、线程、并发有一定的了解</p></div></div><a id="more"></a><p><a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E7%A8%8B">维基百科</a>是这么定义的：</p><blockquote><p>协程是计算机程序的一类组件，推广了协作式多任务的子程序，允许执行被挂起与被恢复。相对子例程而言，协程更为一般和灵活，但在实践中使用没有子例程那样广泛。</p></blockquote><p>字我都认识，可连起来是什么意思？这就是本文写作的目的。</p><h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><p>协程和线程对比起来更容易理解，因为他俩实在太像了。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程（英语：thread）是操作系统能够进行运算调度的最小单位。大部分情况下，它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p><p>那么什么是进程呢？</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是程序运行的一个实例（字面拆解为正在进行的程序），一个程序是静态的二进制文件，是没有灵魂的，当我们启动程序时就会开启一个进程，这个时候系统开始读取程序的二进制文件，并且向系统申请一些资源。</p><p>总结起来进程就是一个程序运行的时候系统环境变量和用到的资源以及本身代码的集合，其特点是每个 CPU 核心任何时间内仅能运行一项进程，即同一时刻执行的进程数不会超过核心数，这对支持更高并发是个阻碍，并且为了解决进程阻塞的问题，操作系统遍引入了更轻量的线程。</p><p>进程资源分配的最小单位，线程是操作系统能够进行运算调度的最小单位。可以这么理解：在进程这个大圈子中，存在着各种资源，在没有线程时，这些资源全部由一个可执行代码调配，这有点像单线程进程。当引入线程之后，一个进程下可以有很多线程，相当于一个可执行代码被分成了很多段，这些片段可以单独执行，并且使用所在进程内的资源。</p><p>当然，要使一个应用程序完整运行起来就必须要把这些细分的线程全都执行起来，于是便需要时间片轮转。操作系统为每一个线程分配 CPU 执行时间（通常为几百毫秒），当运行这个线程的时间超过分配的执行时间时，系统会强制 CPU 去执行下一个等待的线程（补充一下，线程和进程都是有状态的，这里这个正在”等待“的线程应该是”中断“状态），如此快速的不断切换线程便实现了并发。同时程序运行的时候也只会出现线程阻塞，而不是整个进程阻塞，如此便解决了上面的问题。</p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>不知不觉提到了并发，根据上面的描述不难看出，并发是指一段时间内（程序开始运行到结束的这段时间）执行多个程序（线程算是一个进程的子程序）。</p><h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p>上面提到，线程是为了解决阻塞和并发的并发问题（在一段时间内执行更多的程序），类似的，协程也是为了在一段时间运行更多的“程序”（应该说是函数）并且可以避免线程阻塞。有了之前的铺垫，类比起来讲协程就很容易了。</p><p>线程和协程解决的并发问题不是一个问题，线程是为了让操作系统并发运行程序，以达到”同时“运行更多程序的目的，而协程是为了让一个线程内的程序并发服务更多内容，这里我不太好解释，一个直观的例子就是一个单线程的服务器程序同时服务多个用户，如何做到服务更多用户？想想线程是怎么来的，我们只需要把这个线程中的程序继续细分，然后像时间片轮转一样不断的去执行这些细分的“子程序”。即使一个这样的“子程序”执行发生阻塞，也不会导致整个线程阻塞，在这个“子程序”阻塞的时候切换到其他“子程序”继续服务，既解决了阻塞的问题，也实现了并发。大概理解了吧，协程就是线程中可以交替运行的代码片段。</p><p>下面说说真实的协程，线程切换是由操作系统的时间片控制的，而协程是程序自己实现的，让协程不断轮流执行才是实现并发，所以实现协程还必须要有一个类似于时间片的结构，不同于线程的切换，协程的切换不是按照时间来算的，而是按照代码既定分配，就是说代码运行到这一行才启动协程，协程是可以由我们程序员自己操控的。</p><p>所以尝试控制这些协程是很有趣的事，一起期待下一篇《<a href="/2020/06/13/JavaScript%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B/" title="JavaScript中的协程">JavaScript中的协程</a>》吧！</p><article class="message message-immersive is-warning"><div class="message-body"><p>本文作者：KylinLee</p><p>本文链接：<a href="https://kylin.dev/2020/06/13/尝试用通俗的方式解释协程">https://kylin.dev/2020/06/13/尝试用通俗的方式解释协程</a></p><p>版权声明：本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p></div></article>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;协程（英文：Coroutine）这个概念其实并不复杂，但我却花了很多时间理解，后来仔细一想，大概是因为这个概念穿插了很多别的概念，所以这篇文章将这些概念全部疏通一遍再来理解协程。&lt;/p&gt;
&lt;div class=&quot;message message-immersive is-warning&quot;&gt;
&lt;div class=&quot;message-body&quot;&gt;
&lt;p&gt;除了协程，通过本文你将对进程、线程、并发有一定的了解&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
    
    </summary>
    
    
      <category term="Code" scheme="https://kylin.dev/categories/Code/"/>
    
    
      <category term="Other Concept" scheme="https://kylin.dev/tags/Other-Concept/"/>
    
  </entry>
  
  <entry>
    <title>浅谈GraphQL的尴尬</title>
    <link href="https://kylin.dev/2020/05/30/%E6%B5%85%E8%B0%88GraphQL%E7%9A%84%E5%B0%B4%E5%B0%AC/"/>
    <id>https://kylin.dev/2020/05/30/%E6%B5%85%E8%B0%88GraphQL%E7%9A%84%E5%B0%B4%E5%B0%AC/</id>
    <published>2020-05-30T08:47:21.000Z</published>
    <updated>2020-06-02T10:07:52.042Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本人某校大二学生，最近忙于数据库课设，其中用到了 <a href="https://graphql.cn/">GraphQL</a>，碰巧在知乎上看到了<a href="https://www.zhihu.com/question/38596306">GraphQL 为何没有火起来？</a>这个问题，虽然是刚用到 GraphQL，但对于这个问题还是有一点想法，的所以这里就浅浅的聊一下 GraphQL 的尴尬吧。</p><a id="more"></a><h1 id="GraphQL-的好处"><a href="#GraphQL-的好处" class="headerlink" title="GraphQL 的好处"></a>GraphQL 的好处</h1><p>因为刚开始用上，没有很深入的去研究 GraphQL 的好处，我只能列出在使用过程中发现的一些好处：</p><h2 id="弹性-API-查询"><a href="#弹性-API-查询" class="headerlink" title="弹性 API 查询"></a>弹性 API 查询</h2><p>由前端传来的查询参数，需要哪些内容由由前端决定，可多可少，减少返回数据冗余。直接好处就是对于不同的 C 端（Web、App、小程序等），可能需要展示不同的内容，有的数据需要，有的数据不需要，使用 GraphQL 可以不用改后端代码，定制想要的数据字段。</p><h2 id="减少路由"><a href="#减少路由" class="headerlink" title="减少路由"></a>减少路由</h2><p>RESTful 往往会使用到许多路由，服务器对大量路由的解析会延长响应时间，对于 GraphQL，只需要设置一个路由而不需要大量的路由解析，并且方便 API 的管理。</p><h2 id="减少请求次数"><a href="#减少请求次数" class="headerlink" title="减少请求次数"></a>减少请求次数</h2><p>根据上面所说的，我们只需要一个路由，并且可以自定义需要的数据字段，那么对于一个页面，完全可以只发送一个请求来获取所有数据。</p><h2 id="更少的代码"><a href="#更少的代码" class="headerlink" title="更少的代码"></a>更少的代码</h2><p>这是对于服务端来说的，对于查询同一内容，不需要重新再写一遍，只需要一个 <code>resolver</code> 就行了。</p><h2 id="更好的前后端联调"><a href="#更好的前后端联调" class="headerlink" title="更好的前后端联调"></a>更好的前后端联调</h2><p>在开发前期，只要后端给出 GraphQL 接口或者说 <code>Schema</code> 确定，那么在前端就能够通过 <code>GraphQL PlayGround</code> 很轻松的模拟数据，<code>GraphQL PlayGround</code> 就相当于一份 API 文档。而且因为 GraphQL 严格的类型系统，也直接在开发阶段解决掉了类型不相同的问题。</p><h1 id="GraphQL-现状"><a href="#GraphQL-现状" class="headerlink" title="GraphQL 现状"></a>GraphQL 现状</h1><p>我认为现在 GraphQL 目前处在一种进退两难的局面之中，2015 年 GraphQL 正式发布，到现在仅仅 5 年的时间，在圈子中颇具影响力，也获得了很多的关注，可以算得上是新秀。这势头太强劲，是导致 GraphQL 现在窘境的一个原因，如果它发展的慢一点，人们可以慢慢的接受，和现在是不一样的局面吧。</p><p>首先要肯定的是 GraphQL 必定会成为未来的 API 查询语言，所以人们炒的很火，但在短期内无法改变仍然开发 RESTful 的局面，这就是发展太快带来的窘境吧。明明很强，大家也很喜欢，但用的人不多，作为 GraphQL 表示很尴尬啊。</p><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>一个很现实的问题就是，如果一个公司全部都是使用的 RESTful，现在改为使用 GraphQL，那不是要重写了？这对于一个大公司来说是伤筋动骨的事，搞不好服务崩溃，所以对于这些公司来说，继续使用 RESTful 花销会比改用 GraphQL 低得多，GraphQL 带来的好处远不如这些花销。</p><p>有些人认为需要前后端都支持是 GraphQL 没有被大量用起来的一个原因，但我对这个说法是不认可的，有需求就有技术支持，究其原因还是上面说的，有需求但没有必要。</p><h1 id="兼容方案"><a href="#兼容方案" class="headerlink" title="兼容方案"></a>兼容方案</h1><p>为了解决上面这个问题，也有一些兼容性方案。</p><p>在课设项目的开发中我使用的是<a href="https://www.apollographql.com/docs/apollo-server/">ApolloServer</a>，其中 ApolloServer 提供了两类数据源，一类是 RESTful API 数据源，一类是自定义数据源，RESTful API 数据源允许你不改变 RESTful API 来使用 GraphQL 进行查询，虽然看起来是很友好的，但当你使用 GraphQL 查询的内容令一个 RESTful API 不能完整提供的时候，会带来一些问题，举个简单的例子：</p><p>RESTful API 请求的字段都是固定的，前后端设定一致，就是说客户端直接请求 RESTful API，返回的数据中冗余很少，而 GraphQL 查询中需要的内容由前端来定，往往一个 GraphQL 查询会伴随着多个 RESTful API 请求，而最终是不需要用到所有数据的，这就出现了数据冗余，浪费了资源。</p><p>而如果 RESTful API 请求和 GraphQL 查询的内容完全吻合，那相比于直接使用 RESTful API 请求，使用 GraphQL 查询多了一次请求，这就是鸡肋的存在啊。</p><p>所以我认为这种兼容并不是完美的，反而会带来更多的资源消耗，并没有达到让大家迁移到 GraphQL 的目的。</p><p>以上就是入门级码农对 GraphQL 尴尬境地的浅显描述。如果大家有什么想法，欢迎留言评论。</p><article class="message message-immersive is-warning"><div class="message-body"><p>本文作者：KylinLee</p><p>本文链接：<a href="https://kylin.dev/2020/05/30/浅谈GraphQL的尴尬">https://kylin.dev/2020/05/30/浅谈GraphQL的尴尬</a></p><p>版权声明：本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p></div></article>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本人某校大二学生，最近忙于数据库课设，其中用到了 &lt;a href=&quot;https://graphql.cn/&quot;&gt;GraphQL&lt;/a&gt;，碰巧在知乎上看到了&lt;a href=&quot;https://www.zhihu.com/question/38596306&quot;&gt;GraphQL 为何没有火起来？&lt;/a&gt;这个问题，虽然是刚用到 GraphQL，但对于这个问题还是有一点想法，的所以这里就浅浅的聊一下 GraphQL 的尴尬吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Code" scheme="https://kylin.dev/categories/Code/"/>
    
    
      <category term="GraphQL" scheme="https://kylin.dev/tags/GraphQL/"/>
    
  </entry>
  
  <entry>
    <title>开始踩坑GoWeb</title>
    <link href="https://kylin.dev/2020/05/28/%E5%BC%80%E5%A7%8B%E8%B8%A9%E5%9D%91GoWeb/"/>
    <id>https://kylin.dev/2020/05/28/%E5%BC%80%E5%A7%8B%E8%B8%A9%E5%9D%91GoWeb/</id>
    <published>2020-05-28T15:26:18.000Z</published>
    <updated>2020-05-29T09:21:12.199Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这是我第一次使用 GoLang 进行 Web 开发，以前用的是 Koa 和 ThinkPHP 进行 Web 后端的开发，也算是有一些经验吧，这篇文章用来记录开发第一个小时遇到的问题。</p><div class="message message-immersive is-success"><div class="message-body"><p>如果你是GoLang的初学者，并且使用的第一个外部包是 <a href="https://github.com/kataras/iris" target="_blank">iris</a> ，那么这篇文章对你相当有帮助。</p></div></div><a id="more"></a><p>问：开发前一个小时我们在做什么？<br>答：打造开发环境和 initialize。</p><h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><p>开发环境倒是不用配置，这个在安装 GoLang 的时候就配置好了，只需要提一点就行了，后面会提到。</p><h2 id="关于GOPATH"><a href="#关于GOPATH" class="headerlink" title="关于GOPATH"></a>关于<code>GOPATH</code></h2><p>它指定软件包源代码所在的目录，<code>$GOPATH</code> 默认采用和 <code>$GOROOT</code>（GO 的安装目录） 一样的值，但从 Go 1.1 版本开始，你必须修改为其它路径。它可以包含多个包含 Go 语言源码文件、包文件和可执行文件的路径，而这些路径下又必须分别包含三个规定的目录：src、pkg 和 bin，这三个目录分别用于存放源码文件、包文件和可执行文件。</p><h1 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h1><p>我使用的是<a href="https://github.com/kataras/iris">iris</a>，这个 Web 框架，选择这个框架的原因主要参考了<a href="https://github.com/speedwheel/awesome-go-web-frameworks/blob/master/README.md">Awesome Web Frameworks for Gophers</a>这篇文章，毫无疑问，我认为这将是未来几年最具潜力的框架，在开源 GoWeb 框架中性能是最强的，社区也是最活跃的，学习曲线相对容易。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>按照官方文档首先使用<code>go-get</code>从 GitHub 上将外部包下载到本地，但在国内的话一般是不成功的。</p><figure class="highlight bash"><figcaption><span>PowerShell</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/kataras/iris/v12@latest</span><br></pre></td></tr></table></figure><p>所以我通过百度找到了热心网友，网友的帖子上说需要先设置<code>GO111MODULE</code>这个环境变量为<code>on</code>，然后设置代理（为了避免从 GitHub 下载源码网速慢而下载失败），根据你的操作系统执行下面两条命令：</p><figure class="highlight bash"><figcaption><span>MacOS/Linux bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Enable the go modules feature</span></span><br><span class="line"><span class="built_in">export</span> GO111MODULE=on</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the GOPROXY environment variable</span></span><br><span class="line"><span class="built_in">export</span> GOPROXY=https://goproxy.io</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>Windows PowerShell</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Enable the go modules feature</span></span><br><span class="line"><span class="variable">$env</span>:GO111MODULE=<span class="string">"on"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the GOPROXY environment variable</span></span><br><span class="line"><span class="variable">$env</span>:GOPROXY=<span class="string">"https://goproxy.io"</span></span><br></pre></td></tr></table></figure><p>现在我们写入一段示例代码来测试一下：</p><figure class="highlight go"><figcaption><span>GoProjectDir/main.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/kataras/iris"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    app := iris.New()</span><br><span class="line">    app.Handle(<span class="string">"GET"</span>, <span class="string">"/welcome"</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx iris.Context)</span></span> &#123;</span><br><span class="line">        ctx.HTML(<span class="string">"&lt;h1&gt;Welcome&lt;/h1&gt;"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    app.Run(iris.Addr(<span class="string">":8080"</span>)) <span class="comment">//8080 监听端口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候 Goland 报错了，告诉我们无法找到引用的包。</p><h1 id="问题在哪？"><a href="#问题在哪？" class="headerlink" title="问题在哪？"></a>问题在哪？</h1><p>这时候我们会很自然的去看这个包是不是真的下载到本地了，于是我们上去<code>GOPATH</code>目录去找，发现目录下只有<code>pkg</code>文件夹，而没有<code>src</code>源文件文件夹。</p><figure class="highlight bash"><figcaption><span>output</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PS F:\ProjectFiles\Go&gt; <span class="built_in">cd</span> <span class="variable">$env</span>:gopath</span><br><span class="line">PS E:\Application\GOPATH&gt; ls</span><br><span class="line"></span><br><span class="line">    Directory: E:\Application\GOPATH</span><br><span class="line"></span><br><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line">----                 -------------         ------ ----</span><br><span class="line">d----           2020/5/28    21:35                pkg</span><br></pre></td></tr></table></figure><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>正常情况下，引入一个外部包时会在<code>GOPATH</code>下的<code>src</code>目录进行包的查找，很明显没有这个文件夹是导致错误的直接原因。</p><p>为什么会这样呢？</p><p>你可能已经注意到我们之前设置了一个环境变量<code>GO111MODULE=on</code>，安装包的时候默认采用是 GOPATH 的模式（GO 最初的依赖管理系统），就是把包的源码放进<code>src</code>目录，而当我们设置了上面这个环境变量的时候就会使用 GoMod 模式，它使用 Go Module 的方式管理包，可以理解为 Module 是 Go packages 的集合。</p><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>使用了不同的依赖管理系统就要用不同的方式，如果你用过 Node 就很好理解，每个 Node 项目都会有一个<code>package.json</code>，里边描述了项目和依赖的信息。对于 GoMod 而言，每一个 Go 项目需要一个<code>go.mod</code>文件来描述这些信息。接着上面的操作，创建一个<code>go.mod</code>文件：</p><figure class="highlight bash"><figcaption><span>PowerShell</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod init `你的包名，通常是项目名称`</span><br></pre></td></tr></table></figure><p>初始化之后里面还没有依赖，在项目文件夹重新使用<code>go-get</code>安装一下包，因为<code>GOPATH</code>已经有了，所以这次直接建立了引用而不需要下载了。现在重新 run 一下，已经没有问题了。</p><p>如果你的 GoLand 仍然提示有错误，在设置中的 GOPATH 配置添加上面设置的环境变量即可。</p><h1 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h1><ol><li>不要随便复制别人的操作，比如说如果没有设置<code>GO111MODULE=on</code>，只设置代理，那么后面的问题都不会出现。</li><li>但是还是推荐使用 GoMod 这种依赖管理方式，因为你可以对项目的依赖轻松进行删除，升级，添加等操作。</li><li>之所以出现这个问题，另外一个原因是，GoMod 是在 2018 年提出使用的，我看的中文文档版本太老压根没有提到，初来乍到，没有关注行情。</li></ol><article class="message message-immersive is-warning"><div class="message-body"><p>本文作者：KylinLee</p><p>本文链接：<a href="https://kylin.dev/2020/05/28/开始踩坑GoWeb">https://kylin.dev/2020/05/28/开始踩坑GoWeb</a></p><p>版权声明：本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p></div></article>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是我第一次使用 GoLang 进行 Web 开发，以前用的是 Koa 和 ThinkPHP 进行 Web 后端的开发，也算是有一些经验吧，这篇文章用来记录开发第一个小时遇到的问题。&lt;/p&gt;
&lt;div class=&quot;message message-immersive is-success&quot;&gt;
&lt;div class=&quot;message-body&quot;&gt;
&lt;p&gt;如果你是GoLang的初学者，并且使用的第一个外部包是 &lt;a href=&quot;https://github.com/kataras/iris&quot; target=&quot;_blank&quot;&gt;iris&lt;/a&gt; ，那么这篇文章对你相当有帮助。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
    
    </summary>
    
    
      <category term="Code" scheme="https://kylin.dev/categories/Code/"/>
    
    
      <category term="GoLang" scheme="https://kylin.dev/tags/GoLang/"/>
    
  </entry>
  
  <entry>
    <title>ES6解构与剩余参数</title>
    <link href="https://kylin.dev/2020/05/19/ES6%E8%A7%A3%E6%9E%84%E4%B8%8E%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0/"/>
    <id>https://kylin.dev/2020/05/19/ES6%E8%A7%A3%E6%9E%84%E4%B8%8E%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0/</id>
    <published>2020-05-19T01:55:53.000Z</published>
    <updated>2020-06-15T07:50:18.831Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>解构赋值是 ES6 中引入的非常有用的语法，掌握解构的技巧能让你更愉悦的敲代码，延长生命的长度。这篇文章是<a href="/2020/05/09/JavaScript%E5%BF%AB%E9%80%9F%E6%8B%B7%E8%B4%9D%E6%95%B0%E7%BB%84%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/" title="JavaScript快速拷贝数组的几种方法">JavaScript快速拷贝数组的几种方法</a>的拓展，因为上一篇文章扯远了，不得不再写一篇补充。</p><a id="more"></a><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>解构赋值是对赋值运算符的扩展。他针对数组或者对象进行模式匹配，然后对其中的变量进行赋值。就是按照视觉上的一一对应关系进行赋值。</p><h1 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h1><p>赋值的顺序是数组索引的顺序</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>];</span><br><span class="line"><span class="keyword">let</span> [one = <span class="string">"one"</span>, two, three] = arr;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`one: <span class="subst">$&#123;one&#125;</span>, two: <span class="subst">$&#123;two&#125;</span>, three: <span class="subst">$&#123;three&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// 输出 “one: 1, two: 2, three: 3”</span></span><br></pre></td></tr></table></figure><h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p><strong>数组解构和对象解构都可以使用默认值</strong><br>上面这段代码中第 2 行<code>one = &quot;one&quot;</code>是将 one 赋予默认值，当且仅当赋予<code>one</code>的值为<code>undefined</code>时使用这个值。</p><h2 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h2><p><strong>数组解构和对象解构都可以使用剩余参数</strong><br>当有多余的值不想一一赋值的时候可以使用剩余参数，即将这些解构没有对应上的值全部放进一个数组：</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line"><span class="keyword">let</span> [a, ...bc];</span><br><span class="line"><span class="built_in">console</span>.log(bc); <span class="comment">// ["b","c"]</span></span><br></pre></td></tr></table></figure><h2 id="数组解构作用"><a href="#数组解构作用" class="headerlink" title="数组解构作用"></a>数组解构作用</h2><h3 id="数组解构快速换值"><a href="#数组解构快速换值" class="headerlink" title="数组解构快速换值"></a>数组解构快速换值</h3><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"a"</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">"b"</span>;</span><br><span class="line"><span class="keyword">var</span> [b, a] = [a, b];</span><br></pre></td></tr></table></figure><p>一行代码实现变量值对换，这样做是不是延长了寿命？/笑哭 😂</p><h3 id="快速拷贝数组"><a href="#快速拷贝数组" class="headerlink" title="快速拷贝数组"></a>快速拷贝数组</h3><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> exampleArr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> [...newArr] = exampleArr;</span><br></pre></td></tr></table></figure><p>具体请参考我的这篇文章<a href="/2020/05/09/JavaScript%E5%BF%AB%E9%80%9F%E6%8B%B7%E8%B4%9D%E6%95%B0%E7%BB%84%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/" title="JavaScript快速拷贝数组的几种方法">JavaScript快速拷贝数组的几种方法</a></p><h1 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h1><p>语法和数组解构类似，但需要保证赋值的变量名和属性名一致：</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> school = &#123;</span><br><span class="line">    name: <span class="string">"TUST"</span>,</span><br><span class="line">    location: <span class="string">"Tian'Jin"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">name</span>: schoolName, location &#125; = school;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;schoolName&#125;</span> is located in <span class="subst">$&#123;location&#125;</span>`</span>); <span class="comment">// TUST is located in Tian'Jin</span></span><br></pre></td></tr></table></figure><h2 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h2><p><strong>数组解构和对象解构中都可以使用重命名</strong><br>上面这段代码第 5 行，<code>name: schoolName</code>将<code>school</code>对象的<code>name</code>属性的值赋给<code>schoolName</code>，而不是<code>name</code>。</p><h2 id="对象解构的作用"><a href="#对象解构的作用" class="headerlink" title="对象解构的作用"></a>对象解构的作用</h2><h3 id="解析配置对象"><a href="#解析配置对象" class="headerlink" title="解析配置对象"></a>解析配置对象</h3><p>对象解构常用于配置对象，比如传入一个对象作为配置，并且某些配置项是可选的，比如在 Vue 中使用 ElmentUI：</p><blockquote><p>在引入 Element 时，可以传入一个全局配置对象。该对象目前支持 size 与 zIndex 字段。size 用于改变组件的默认尺寸，zIndex 设置弹框的初始 z-index（默认值：2000）。按照引入 Element 的方式，具体操作如下：</p></blockquote><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">import</span> Element <span class="keyword">from</span> <span class="string">"element-ui"</span>;</span><br><span class="line">Vue.use(Element, &#123; <span class="attr">size</span>: <span class="string">"small"</span>, <span class="attr">zIndex</span>: <span class="number">1000</span> &#125;);</span><br></pre></td></tr></table></figure><p>第三行<code>Vue.use</code>除了传入<code>Element</code>，还可以传入一个配置对象作为全局配置，这个配置参数是可选的，那我们可以这样写（不一定是真实写法）：</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Element(...args)&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    size = <span class="string">"-"</span>,</span><br><span class="line">    z-index = <span class="number">2000</span></span><br><span class="line">  &#125; = args[<span class="number">1</span>]</span><br><span class="line">  <span class="comment">// ...若干代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现-import"><a href="#实现-import" class="headerlink" title="实现 import"></a>实现 import</h3><p>在浏览器中如果我们使用<code>script</code>标签引入了一个 UMD 模块，使用模块中的变量可以用解构来减少写<code>.</code>操作符，比如：</p><figure class="highlight html"><figcaption><span>HTML</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag">    <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/rxjs/6.3.3/rxjs.umd.min.js"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">async</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="keyword">of</span>, map &#125; = rxjs;</span><br></pre></td></tr></table></figure><h1 id="剩余参数和扩展运算的区别"><a href="#剩余参数和扩展运算的区别" class="headerlink" title="剩余参数和扩展运算的区别"></a>剩余参数和扩展运算的区别</h1><p>我们使用的时候一般都不会注意这个问题，通常就是很顺畅的写完了，代码一点错误都没有，即便如此，还是要搞清楚两者的区别啊，我看到很多博客文章都将二者混淆。</p><p>其实区分他们很简单，从字面意义上理解就行了，剩余参数是参数，有将参数合并成数组的作用，而拓展运算是展开数组，同样是三个点<code>...</code>，一个是存，一个是取，它们的作用似乎是相反的。</p><article class="message message-immersive is-warning"><div class="message-body"><p>本文作者：KylinLee</p><p>本文链接：<a href="https://kylin.dev/2020/05/19/ES6解构与剩余参数">https://kylin.dev/2020/05/19/ES6解构与剩余参数</a></p><p>版权声明：本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p></div></article>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;解构赋值是 ES6 中引入的非常有用的语法，掌握解构的技巧能让你更愉悦的敲代码，延长生命的长度。这篇文章是&lt;a href=&quot;/2020/05/09/JavaScript%E5%BF%AB%E9%80%9F%E6%8B%B7%E8%B4%9D%E6%95%B0%E7%BB%84%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/&quot; title=&quot;JavaScript快速拷贝数组的几种方法&quot;&gt;JavaScript快速拷贝数组的几种方法&lt;/a&gt;的拓展，因为上一篇文章扯远了，不得不再写一篇补充。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Code" scheme="https://kylin.dev/categories/Code/"/>
    
    
      <category term="JavaScript" scheme="https://kylin.dev/tags/JavaScript/"/>
    
  </entry>
  
</feed>
