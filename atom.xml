<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>蝶恋花-等风也等你</title>
  
  <subtitle>等风也等你</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kylin.dev/"/>
  <updated>2020-12-27T09:12:47.460Z</updated>
  <id>https://kylin.dev/</id>
  
  <author>
    <name>Kylin Lee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>读了一遍NPM文档</title>
    <link href="https://kylin.dev/2020/11/27/%E8%AF%BB%E4%BA%86%E4%B8%80%E9%81%8DNPM%E6%96%87%E6%A1%A3/"/>
    <id>https://kylin.dev/2020/11/27/%E8%AF%BB%E4%BA%86%E4%B8%80%E9%81%8DNPM%E6%96%87%E6%A1%A3/</id>
    <published>2020-11-27T09:53:52.000Z</published>
    <updated>2020-12-27T09:12:47.460Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>只能说自己的基本功还不够扎实，有的时候想自己看一下源码，发现啥都看不懂，不得不抽点时间来补习一下了。</p><article class="message message-immersive is-danger"><div class="message-body"><p>本文尚未完成</p></div></article><a id="more"></a><p>写这篇文章源于想看以下一个 JavaScript 库的源码，最近一个项目中引了<a href="https://github.com/leizongmin/js-xss/blob/master/README.zh.md">XSS 过滤库</a>，虽然不是第一次 XSS 过滤了，但最近项目复盘的时候突然想起假期在知乎上看到的一个问题——<a href="https://www.zhihu.com/question/417623754">如何证明（或直观解释）为何正则表达式无法可靠地解析 XML？</a>，虽然 XSS 过滤和解析 XML 看起来没啥关系，我想看看 XSS 库是如何对一个 HTML 文件进行标签的过滤的，究竟是是用的正则表达式？但是看到源码的<code>package.json</code>部分有很多字段不太理解，所以读了一 NPM 文档。</p><p>整个 NPM 文档说明的比较全面，感兴趣的朋友们可以自己去阅读一下，内容也不多。在这里我就主要介绍一下我认为关于 NPM 的一些通识知识，前端开发者应该知道的内容。既然都说了是看别人的源码中有问题才来看文档的，所以接下来我将总结几个问题，按照文档的内容来给出回答。</p><h1 id="npm-中的一些小细节"><a href="#npm-中的一些小细节" class="headerlink" title="npm 中的一些小细节"></a>npm 中的一些小细节</h1><h2 id="scope-和-unscope-包1"><a href="#scope-和-unscope-包1" class="headerlink" title="scope 和 unscope 包1"></a>scope 和 unscope 包<sup><a href="https://docs.npmjs.com/about-scopes" target="_blank" ref="nofollow">1</a></sup></h2><p>npm 包其实也是分作用域的，同一个作用域下不允许相同的包名，但它的主要作用是用来划分权限，对该作用域没有相关权限的用户是不能进行一些操作的，比如有的公司自己有 npm 作用域，不在该作用域下的账户是无法访问到 npm 包的，有的时候<code>npm install</code>提示找不到包，可以查看是否安装的是 scope 包，并且确定有没有可读的权限。</p><p><strong>unscope 包</strong>：unscope 包对所用 npm 用户都是可见的，在包名前面没有<code>@*/</code>的标识，用户可以任意安装这些包。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;antd&quot;</span>: <span class="string">&quot;^4.8.0&quot;</span></span><br></pre></td></tr></table></figure><p><strong>scope 包</strong>：scope 包前面有<code>@*/</code>的标识，表示组织的域。此外 scope 包并不是所有不在作用域下的账户都不能访问，如下这个<code>@ant-design/icons</code>包对于所有人都是可见的，只是对该包的归属做一个标记，或者包名已经被别人注册，要使用相同的名字就要限制一下作用域。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;@ant-design/icons&quot;</span>: <span class="string">&quot;^4.0.0&quot;</span></span><br></pre></td></tr></table></figure><p><strong>注意：有一种特殊的形式<code>@types/*</code></strong><br>由于<code>TypeScript</code>的不断发张，很多很早之前发布的包并没有使用<code>TypeScript</code>编写，导致包中不存在声明文件，如果引用这个包的项目使用<code>TypeScript</code>编写，则在编译的时候会失败。所以很多包会补写对应的声明文件，单独发布，这些声明文件就会用<code>@types/*</code>进行标识。</p><h2 id="dependencies-和-devDependencies"><a href="#dependencies-和-devDependencies" class="headerlink" title="dependencies 和 devDependencies"></a>dependencies 和 devDependencies</h2><p>这个比较好理解了，仔细看<code>package.json</code>文件就会发现这两个字段，dependencies 里边存放了当前包引用的依赖包的包名和版本号。devDependencies 存放的是开发这个包的过程中使用的依赖包的包名和依赖。二者的区别在于前者表示项目的运行时依赖，如包中引用到额函数库等，后者的内容表示开发过程中，使用这些包能方便开发，缺少不影响包的功能，比如一些 CLI，构建工具等等。</p><p>在开发过程中建议遵守这些约定，以免引起不必要的麻烦。</p><p><strong>TIPS</strong></p><p>在执行安装命令时使用<code>--save-dev</code>或<code>-D</code>标记会自动将所安装的包的包名的版本号存入<code>package.json</code>的<code>devDependencies</code>中。</p><p>使用<code>npm i(nstall)</code>的时候会默认带上<code>--save-prod</code>标记，这个标记会将所安装包的包名和版本存入<code>package.json</code>的<code>dependencies</code>中。</p><h2 id="local-和-global-安装"><a href="#local-和-global-安装" class="headerlink" title="local 和 global 安装"></a>local 和 global 安装</h2><p><strong>global 安装</strong>：除了安装在某一个文件夹内，也可以安装在全局，在安装的时候加上<code>-g</code>这个标记即可，这种安装通常是将作为命令行工具使用。安装之后即可在全局使用命令，如<code>@vue/cli</code>这个包，是 Vue 的脚手架工具，全局安装之后可以执行<code>vue --version</code>，<code>vue ui</code>等指令。</p><p><strong>local 安装</strong>：npm 安装不同于 maven，pip，npm 有全局和局部两种安装方式，使用安装命令安装时默认会将包安装到当前文件夹的<code>node_modules</code>目录，只有当前目录下层的包或文件才能使用安装的包。</p><p>在任一目录下使用<code>require()</code>会检查当前目录的<code>node_modules</code>目录有没有这个包，没有则继续检查上级目录，重复上述操作，直到顶级目录，如果到现在还没找到，则会查找全局是否有这个包，如果都没有找到就会报<code>Uncaught Error: Cannot find module &quot;xxx&quot;</code>。</p><p>如果你想像安装在全局的那些包一样使用命令，可以在命令前加<code>npx</code>，如<code>npx webpack</code>，关于 NPX，稍后会详细的讲解。</p><h2 id="、-与"><a href="#、-与" class="headerlink" title="^、~与*"></a><code>^</code>、<code>~</code>与<code>*</code></h2><p>如果现在你正在基于别人开发的包开发自己的产品，细心的你应该会注意到在<code>package.json</code>文件中<code>devDependencies</code>和<code>depenencies</code>字段中每个包的版本号几乎都有<code>^|~|*</code>前缀，这些前缀代表了不用的含义，简单的总结起来就是他们三个表示了不同的版本粒度，控制允许安装包的版本范围。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;webpack&quot;</span>: <span class="string">&quot;~5.10.3&quot;</span> <span class="comment">/* 同5.10和5.10.x，允许更新的版本范围为5.10.0~1.10.3之间 */</span>,</span><br><span class="line">    <span class="attr">&quot;webpack-cli&quot;</span>: <span class="string">&quot;^4.3.0&quot;</span> <span class="comment">/* 同4.x和4，允许更新的版本范围为4.0.0~4.3.0之间 */</span>,</span><br><span class="line">    <span class="attr">&quot;webpack-merge&quot;</span>: <span class="string">&quot;*&quot;</span> <span class="comment">/* 同x，只允许主要的版本，即1.0.0~x.0.0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>npm i</code>安装的时候默认会找满足范围条件内最新的版本，当有<code>~</code>时，版本号前两部分保持不变，按照第三部分在 0 到指定版本之间中安装最大的版本。当有<code>^</code>时，版本号第一部分保持不变，按照第二部分在 0 到指定版本号之间安装最大的。当为<code>*</code>时，仅安装像<code>1.0.0</code>，<code>2.0.0</code>，<code>3.0.0</code>这种大版本更新的最大的版本。</p><h1 id="高阶使用"><a href="#高阶使用" class="headerlink" title="高阶使用"></a>高阶使用</h1><h2 id="更改-global-安装的位置1"><a href="#更改-global-安装的位置1" class="headerlink" title="更改 global 安装的位置1"></a>更改 global 安装的位置<sup><a href="#link">1</a></sup></h2><p>如果你不想将 npm 安装的全局包放在默认的位置，可以更改它。<br>核心步骤：</p><ol><li>先在你想放的地方创建一个文件夹</li><li>使用 <code>npm config set prefix $新建的文件夹路径</code>设置新路径</li><li>添加新创建的文件夹到环境变量</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;只能说自己的基本功还不够扎实，有的时候想自己看一下源码，发现啥都看不懂，不得不抽点时间来补习一下了。&lt;/p&gt;
&lt;article class=&quot;message message-immersive is-danger&quot;&gt;
&lt;div class=&quot;message-body&quot;&gt;
&lt;p&gt;本文尚未完成&lt;/p&gt;
&lt;/div&gt;
&lt;/article&gt;
    
    </summary>
    
    
      <category term="Code" scheme="https://kylin.dev/categories/Code/"/>
    
    
      <category term="Node" scheme="https://kylin.dev/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>数据无损压缩</title>
    <link href="https://kylin.dev/2020/10/22/%E6%95%B0%E6%8D%AE%E6%97%A0%E6%8D%9F%E5%8E%8B%E7%BC%A9/"/>
    <id>https://kylin.dev/2020/10/22/%E6%95%B0%E6%8D%AE%E6%97%A0%E6%8D%9F%E5%8E%8B%E7%BC%A9/</id>
    <published>2020-10-22T13:33:02.000Z</published>
    <updated>2020-11-12T11:22:09.048Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本文将介绍<del>四种</del>两种数据无损压缩的方式（算法），上这节课已经有两个周了，除了作业就没有接触过这方面的内容，自己对数据压缩也挺感兴趣的，所以就复习总结一下，希望更多的人了解这方面的内容。</p><a id="more"></a><h1 id="无损压缩"><a href="#无损压缩" class="headerlink" title="无损压缩"></a>无损压缩</h1><p>无损压缩这个概念顾名思义，但是惯按照例，说什么内容的时候必须要清楚自己说的是什么，通俗地说就是压缩能获得更小的体积，但是读取时能还原出和压缩前相同的数据。</p><h1 id="两种数据无损压缩算法"><a href="#两种数据无损压缩算法" class="headerlink" title="两种数据无损压缩算法"></a>两种数据无损压缩算法</h1><p>无损压缩是将已有的数据格式进行压缩，为了减小数据量，往往需要改变编码格式，这个过程是通过算法实现的。这里将为大家讲解<del>四种</del>数据压缩算法（因为篇幅和精力有限，所以只介绍两种）：</p><ol><li>哈夫曼编码</li><li>算术编码<br><del>3. LZW 编码</del><br><del>4. 位平面编码</del></li></ol><p>当然压缩算法不止这四种，感兴趣的朋友们可以自己去了解，并且欢迎在评论区补充。</p><h1 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h1><p>如果你学过哈夫曼树，那么对哈夫曼编码一定不陌生，哈夫曼编码借助哈夫曼树实现。哈夫曼编码是一种游程长度编码，每一个字符使用的二进制编码长度是不一样的，相对于定长编码的，它能有效压缩数据关键在于<strong>哈夫曼编码中出现概率大的符号用长度较短的码，出现概率小的符号用较长的码，码字长度与概率严格逆序排列</strong>。</p><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>先来了解一下哈夫曼树的基础知识和重要特性，哈夫曼树又被称最优二叉树，是指对于一组带有确定权值的叶子结点所构造的具有带权路径长度最短的二叉树。听起来很难懂？让我们一个词一个词的来解释：</p><ol><li>二叉树：每个节点最多只有两个孩子节点的树，如果你还不懂什么是树，可以看看前边的内容《<a href="/2020/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91/" title="数据结构：树">数据结构：树</a>》</li><li>带权叶子节点：权即为权重，通常用作标记一个东西的重要程度，这里可以理解为叶子节点的一个属性，拥有权重这个属性的叶子节点即为带权叶子节点。</li><li>带权路径长度：路径长度在《<a href="/2020/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91/" title="数据结构：树">数据结构：树</a>》中已经提到过了，指父节点到子孙节点所经历的边的条数，带权的路径长度的话就需要乘以子节点的权重，注意，路径上每一个节点的权重可能不同，所以应该每经历一条边计算一下这条边的带权路径长度，最后将经历的边的带权路径长度累加。</li></ol><h2 id="哈夫曼树的构造过程"><a href="#哈夫曼树的构造过程" class="headerlink" title="哈夫曼树的构造过程"></a>哈夫曼树的构造过程</h2><p>最开始时，每个节点可以看作是只有一个根节点的二叉树，他们的集合叫做森林。</p><ol><li>从森林中选出根节点权值最小的两棵树，创建一个新节点作为根节点，两个节点中权值较小的作为新节点的左孩子，权值较大的作为新节点的右孩子，并且向新节点赋予权值，权值的大小为两个子节点的和。这样便生成了一棵拥有三个节点的二叉树。</li><li>从森林中删除刚才选择的两个权值较小的节点，然后将新生成的二叉树插放入森林中。</li><li>重复 1-2 两个步骤，直到只有一棵树。</li></ol><p>下面用动画演示哈夫曼树的构造过程：</p><p><strong>链接稍后奉上</strong></p><p>得到哈夫曼树之后我们可以根据权值计算带权叶子节点与根节点之间的带权路径，这个方法构造的带权路径的和是最小的。</p><h2 id="从哈夫曼树到哈夫曼编码"><a href="#从哈夫曼树到哈夫曼编码" class="headerlink" title="从哈夫曼树到哈夫曼编码"></a>从哈夫曼树到哈夫曼编码</h2><p>我们已经学会了如何构造哈夫曼树，接下来可以进行哈夫曼编码了，哈夫曼编码基于哈夫曼树，所以关键就在于如何将需要编码的字符和哈夫曼树建立联系。</p><p>我们可以把字符当成节点，将字符出现的频率作为权值，所以最开始说，哈夫曼编码其实是与字符出现的频率相关的。<br>对文本进行哈夫曼编码的步骤如下：</p><ol><li>统计文本中，各个字符出现的次数，并进行归一处理，所谓归一就是将字符出现的次数除以字符总数，得到字符在整个文本中出现的频率。</li><li>将这些出现过的字符转化成二叉树节点，并赋予权值，值为各自在出现的频率。</li><li>构造哈夫曼树。</li><li>给哈夫曼的树的所有结点赋予权值，左孩子节点的权值为 0，右孩子结点的权值为 1。</li><li>找出叶子节点对应的带权路径，从叶子节点开始，依次计算每条边的带权路径长度，并将所得的值进行拼接，就能得到该叶子节点对应的字符的哈夫曼编码。</li><li>按照 5 的步骤，计算所有叶子节点的哈夫曼编码，得出码表。</li><li>最后将每个字符用码表中的编码逐一替代即可。</li></ol><h2 id="哈夫曼编码的解码"><a href="#哈夫曼编码的解码" class="headerlink" title="哈夫曼编码的解码"></a>哈夫曼编码的解码</h2><p>哈夫曼编码进行解码是需要码表的，根据哈夫曼编码的特点，哈夫曼编码是前缀编码，即任一个字符的编码都不是另一个字符的编码的前缀，所以根据码表，逐个比对编码表，第一个匹配的编码就是对应的字符。</p><h2 id="用-JavaScript-实现的哈夫曼编码和解码器"><a href="#用-JavaScript-实现的哈夫曼编码和解码器" class="headerlink" title="用 JavaScript 实现的哈夫曼编码和解码器"></a>用 JavaScript 实现的哈夫曼编码和解码器</h2><p>按照上述内容，需要先统计<code>str</code>中每个字符出现的频次。</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> charTable = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> char <span class="keyword">of</span> str) &#123;</span><br><span class="line">    <span class="keyword">if</span> (charTable.has(char)) &#123;</span><br><span class="line">        charTable.set(char, charTable.get(char) + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        charTable.set(char, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将频次转化为频率，并且转化为节点，将频率大小赋值给节点的权重。</p><p>这一步首先确定树中每个节点的结构，因最后生成的是一棵二叉树，我们需要的到叶子节点的编码，在得到编码这个过程中有两种方式：</p><ol><li>节点的编码和深度优先遍历时经过的节点序列相关，在遍历查找叶子节点时记录遍历的顺序，最后将结果倒序就能得到该节点的编码。</li><li>通过任意方式，找到叶子节点后，向上寻找根节点，寻找的顺序即为编码序列。</li></ol><p>如果采用第一种方式，为了便于从根节点找到子孙节点，应该采用孩子表示法或者孩子兄弟表示法。如果采用第二种方式，既要方便从子孙节点找到根节点，又要方便从根节点找到孩子节点，二叉树的几种存储结构中都不能同时满足这两个你要求，所以只能增加每个节点的数据量，同时储存父节点和子节点的信息。显然这样来回两次通过相同的路径，并且耗费更高的内存，这样是不可取的。</p><p>在这里采用的是孩子表示法。</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TreeNode</span>(<span class="params">weight, value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 依次是节点的权值、节点的值、左孩子节点、右孩子节点</span></span><br><span class="line">    <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">    <span class="built_in">this</span>.child = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="built_in">this</span>.brother = <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确定好节点的结构之后就可以生成节点了，上面只统计了频次，我们在插入节点的时候使用一次循环同时将频次转换为频率。</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> totle = str.length;</span><br><span class="line"><span class="keyword">if</span> (totle === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;invalid parameter!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 节点数组</span></span><br><span class="line"><span class="keyword">const</span> nodeList = [];</span><br><span class="line">charTable.forEach(<span class="function">(<span class="params">val, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 插入节点值和出现频率</span></span><br><span class="line">    nodeList.push(<span class="keyword">new</span> TreeNode((val / totle).toFixed(<span class="number">2</span>)), key);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>现在已经完成了数据的处理，可以开始生成哈夫曼树了。在这个过程中需要不断的对对节点列表中的节点进行排序、生成新树、移除原节点，直到节点列表中只剩一棵树。</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateHuffmanTree</span>(<span class="params">nodeList</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nodeList.length !== <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 按照频率从小到大排列节点</span></span><br><span class="line">        nodeList.sort(<span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x.weight - y.weight;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 生成新节点，并作为原来节点的根</span></span><br><span class="line">        <span class="keyword">const</span> node = <span class="keyword">new</span> TreeNode(nodeList[<span class="number">0</span>].weight + nodeList[<span class="number">1</span>].weight);</span><br><span class="line">        <span class="comment">// 确定新节点左右孩子</span></span><br><span class="line">        node.leftChild = nodeList[<span class="number">0</span>];</span><br><span class="line">        node.rightChild = nodeList[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 从nodeList中删除原节点</span></span><br><span class="line">        nodeList.shift();</span><br><span class="line">        nodeList[<span class="number">0</span>] = node;</span><br><span class="line">        <span class="comment">// 递归执行上述过程</span></span><br><span class="line">        generateHuffmanTree(nodeList);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上面的函数之后，<code>nodeList</code>已经是一棵哈夫曼树了，接下来需要得到码表，通过先序、中序、后序、层次遍历二叉树都能够获得码表，虽然采取层次遍历能够找到叶子节点，然后向上查找根节点，计算路径，但根据存储结构，向上查找是比较困难的，所以不建议采用层次遍历。我们遍历希望得到一条路径，优点像深度优先搜索，所以可以采用先序遍历。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历节点，深度优先遍历（先序遍历），并得出码表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepFirstTraversal</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> flag = [root];</span><br><span class="line">    <span class="keyword">const</span> code = [];</span><br><span class="line">    <span class="keyword">const</span> codeMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">while</span> (flag.length !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 以某个节点为根，不断访问左子树、左子树的左子树...直到叶子节点</span></span><br><span class="line">        <span class="keyword">while</span> (flag[flag.length - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">const</span> node = flag[flag.length - <span class="number">1</span>].leftChild;</span><br><span class="line">            flag.push(node);</span><br><span class="line">            code.push(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 访问右子树</span></span><br><span class="line">        flag.pop();</span><br><span class="line">        code.shift();</span><br><span class="line">        <span class="comment">// 转到右孩子节点</span></span><br><span class="line">        <span class="keyword">if</span> (flag[flag.length - <span class="number">1</span>].rightChild) &#123;</span><br><span class="line">            code.push(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            flag.push(flag[flag.length - <span class="number">1</span>].rightChild);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 该节点为叶子节点</span></span><br><span class="line">            flag.pop();</span><br><span class="line">            codeMap.set(flag[flag.length - <span class="number">1</span>].value, code.join());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> codeMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="算术编码"><a href="#算术编码" class="headerlink" title="算术编码"></a>算术编码</h1><p>算数编码的编码方式较为特别，大多数编码方式通过缩短编码长度或减少编码的次数来达到压缩目的，算术编码采用浮点数来表示需要压缩的内容，从某种程度上看来，储存一个浮点数确实比储存一个字符串数据占用更少的空间。</p><h2 id="编码原理与过程"><a href="#编码原理与过程" class="headerlink" title="编码原理与过程"></a>编码原理与过程</h2><p>算数编码同样需要统计字符出现的频率，为每个字符划分概率区间，类似于古典概型，字符 A 的出现概率是 0.5，那么出现 AA 的概率是 0.5 × 0.5 = 0.25，不过算数计算的并不是仅概率，还要按照一定的顺序将概率放进不同长度的区间表示，最终计算的是区间。</p><p>如字符串对<code>pass</code>进行压缩，可以按照分以下几步进行：</p><ol><li><p>先计算各字符出现的概率</p><p> <img src="https://i.loli.net/2020/11/12/o4egnWcNuYPR3y8.png" alt="string-probability.png"></p></li><li><p>将字符分配到[0, 1)区间，各字符的区间长度为对应的概率</p><p> <img src="https://i.loli.net/2020/11/12/oDMdhJQrbN5vUmq.png" alt="line-area.png"></p><p> 如图，因<code>s</code>出现的概率为 0.5，所以区间占 0.5 长度，字符区间并没有明确的顺序，此处按照概率由大到小排列。</p></li><li><p>按照字符串顺序从左往右计算，一次次增加编码字符长度，在前一次字符串的编码区间基础上上计算增加一个字符后的编码区间。</p><p> 这是一个动态迭代计算的过程，简单的解释为，迭代一次计算<code>p</code>字符串位于的区间，迭代第二次得出<code>pa</code>字符串位于的区间，迭代第三次得出<code>pas</code>字符串位于的区间，迭代完所有字符即可得出该字符串应该落在哪个区间，最后即可通过该区间内的任意一个数表示字符串。</p><p> 要得到包含 n 个字符的字符串的编码区间，必须先知道包含前 n-1 个字符的字符串的编码区间，这一点和递归思想类似。所以要计算<code>pa</code>字符串的编码区间，一定是先计算了<code>p</code>的编码区间，所以每次计算的区间总长度是在上一次的编码区间上计算的区间长度。</p><p> 第一个字符在区间[0, 1)的基础上开始计算，计算<code>p</code>字符所在的区间，为[0.5, 0.75)，现在计算前两个字符组成字符串所在的区间，将[0.5, 0.75)区间按照上图的顺序和概率划分区间，如图所示，<code>pa</code>所在区间为[0.6875, 0.75)。</p><p> <img src="https://i.loli.net/2020/11/12/lVnRWECKipsS9mj.png" alt="sec-encode.png"></p><p> 第三次将编码前三个字符的字符串<code>pas</code>，将<code>pa</code>的区间[0.6875, 0.75)，按照上述顺序和概率分配区间，得出<code>pas</code>的区间编码为[0.6875, 0.71875)，继续上述步骤，最终得出<code>pass</code>的编码区间为[0.6875, 0.703125)。</p></li><li><p>现在可以用[0.6875, 0.703125)中的任意一个数代表<code>pass</code>，如用 0.6875 代表<code>pass</code>四个字符。</p></li></ol><h2 id="算术编码的解码"><a href="#算术编码的解码" class="headerlink" title="算术编码的解码"></a>算术编码的解码</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍&lt;del&gt;四种&lt;/del&gt;两种数据无损压缩的方式（算法），上这节课已经有两个周了，除了作业就没有接触过这方面的内容，自己对数据压缩也挺感兴趣的，所以就复习总结一下，希望更多的人了解这方面的内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Code" scheme="https://kylin.dev/categories/Code/"/>
    
      <category term="Other" scheme="https://kylin.dev/categories/Code/Other/"/>
    
    
      <category term="Concept" scheme="https://kylin.dev/tags/Concept/"/>
    
      <category term="Algorithm" scheme="https://kylin.dev/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>一次性搞懂Flux，Redux和Vuex（Flux架构篇）</title>
    <link href="https://kylin.dev/2020/09/24/%E4%B8%80%E6%AC%A1%E6%80%A7%E6%90%9E%E6%87%82Flux%EF%BC%8CRedux%E5%92%8CVuex/"/>
    <id>https://kylin.dev/2020/09/24/%E4%B8%80%E6%AC%A1%E6%80%A7%E6%90%9E%E6%87%82Flux%EF%BC%8CRedux%E5%92%8CVuex/</id>
    <published>2020-09-24T10:30:21.000Z</published>
    <updated>2020-10-21T09:26:23.572Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这次的野心有点大，想要一次性讲清楚三个状态管理工具，但是毫不夸张，这篇文章将带你快速理解并掌握这三个工具，本篇将介绍最重要的<code>Flux</code>架构。</p><a id="more"></a><h1 id="为什么需要状态管理"><a href="#为什么需要状态管理" class="headerlink" title="为什么需要状态管理"></a>为什么需要状态管理</h1><p>我们要使用一个工具，是因为我们用它能帮助我们更高效地完成某项工作，在使用状态管理工具之前同样也要明白，为什么需要状态管理工具。</p><p>首先明白什么是状态，在程序的世界中，状态即时某一时刻或者某一时间段的数据集合，可以粗略的理解为数据值，我们可以把这些值放在内存中，也可以储存在数据库中，在前端领域，状态通常被放在内存中，以 JavaScript 对象或者变量的形式存在。</p><p>对这些值进行管理，管理什么呢？值是可变的，我们要管理它的存、放、更改。零散的变量似乎不太好管理，既然这样，那就把这些变量放在一堆，如全都放进一个对象中，现在这个对象就相当于一个仓库，我们为仓库编写存、取、更改里面属性的方法。这样我们通过调用对象方法便实现了对状态的管理。</p><p>在一个小的环境中，我们可能不需要状态管理，因为需要管理的状态数实在是太少，如果封装一个对象来管理状态，这样显得臃肿而且并没有带来太大的好处。但是当我们需要管理大量的内容时，状态管理的优点就凸显出来了，把变量集中起来，使用统一的方法进行增、删、改、查，使代码逻辑变得清晰，同样，因为状态容器将内外隔离开来，也避免了变量出现污染的情况，变量也更加安全，因为你不能直接访问到，需要特定的方法，甚至需要验证，这也避免了很多错误的发生。</p><p>在当下流行的组件化开发中，每一个组件就是小环境，整个 SPA 应用可以看作大环境，如果仅仅是在不大的组件中使用状态管理，可能会使代码变得臃肿，所以在使用状态管理的时候先问问自己我使用状态管理的投入/产出是值得的吗。通常我们在整个应用中使用一个状态管理，并且你需要在应用中频繁的增删改很多全局使用的内容。</p><h1 id="他们之间的关系"><a href="#他们之间的关系" class="headerlink" title="他们之间的关系"></a>他们之间的关系</h1><p>使用过其中任一状态管理工具的朋友或多或少都会听说过<code>Flux</code>，<code>Flux</code>既是一种架构也是一个状态管理工具，三者都是根据<code>Flux</code>架构的原理进行设计的，所以搞清楚<code>Flux</code>架构就能轻松掌握三种状态管理工具，这个系列将分三次讲诉：</p><ol><li><code>Flux</code>架构</li><li><code>Redux</code>基础</li><li><code>Vuex</code>基础</li></ol><p><code>Flux</code>架构是三大状态管理的工具的基础，搞懂<code>Flux</code>架构，从此的学习一马平川。</p><h1 id="Flux-架构"><a href="#Flux-架构" class="headerlink" title="Flux 架构"></a>Flux 架构</h1><h2 id="什么是-Flux"><a href="#什么是-Flux" class="headerlink" title="什么是 Flux"></a>什么是 Flux</h2><p>Flux 是管理应用程序中数据流（状态管理）的一种模式，其核心思想是数据向一个方向流动。数据的流动方向如下图所示：</p><p><img src="https://i.loli.net/2020/10/01/s73pcAQrt9ZvoDS.png" alt="flux-overview.png"></p><p>从上图可以看到数据在 Dispatcher、Store、View、Action 之间形成了一个闭环，并且流动方向都是单向的，这样做的好处是使逻辑组织更加清晰，并且更方便管理。</p><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>在我看来 Action 在数据改变的过程中充当信使的作用，Action 本质上是一个包含 type 属性的对象，用 TypeScript 表示，其接口类似于下面这样：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Action &#123;</span><br><span class="line">    <span class="keyword">type</span>: <span class="built_in">string</span>;</span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h3><p>中文译作”调度器“，和其名字一样，作用是根据传递过来的 Action 的 type 类型控制执行哪些函数，起到了调度器的作用。</p><h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>Flux 架构通常应用于 APP 全局，Store 就是整个应用的中心仓库，本质也是一个对象，可以储存所有你想要在应用中使用的变量，这些变量的值通常被称为状态，如果将 Store 用于整个应用，那么在应用销毁之前，在应用内任何地方都能访问到 Store 中的内容，如果将 Store 应用于某个组件，那么 Store 将伴随着组件的生命周期重新创建和销毁，仅能在该组件存在的时候在该组件或者子组件内访问到。</p><h2 id="各个部分是如何配合完成状态更新的"><a href="#各个部分是如何配合完成状态更新的" class="headerlink" title="各个部分是如何配合完成状态更新的"></a>各个部分是如何配合完成状态更新的</h2><p>模拟一个真实的需求场景，网站的登陆状态几乎是页面所有组件都需要获取的，现在需要根据登录状态显示个性化内容，一开始并没有登录这个网站，现在点击登录，使用 Flux 架构，数据应该是这样改变的：</p><ol><li>经过后台验证后（验证成功），创建一个 Action 对象</li><li>这时候我们向 Dispatcher 传入准备好的 Action</li><li>Dispatcher 匹配到 Action 的 type 属性，调用对应的函数改变 Store 中的登录状态</li><li>Store 是一个订阅兑对象，当 Store 发生变化时，订阅 Store 相应内容的对象就会收到订阅改变的事件，执行相应的回调或者更新视图。</li></ol><h1 id="Flux-实战"><a href="#Flux-实战" class="headerlink" title="Flux 实战"></a>Flux 实战</h1><p>通过上面的讲解，也许你还不太能理解，接下来，将通过简单的代码实现来深入理解这个过程。</p><article class="message message-immersive is-warning"><div class="message-body"><p>本文作者：KylinLee</p><p>本文链接：<a href="https://kylin.dev/2020/09/24/一次性搞懂Flux，Redux和Vuex">https://kylin.dev/2020/09/24/一次性搞懂Flux，Redux和Vuex</a></p><p>版权声明：本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p></div></article>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次的野心有点大，想要一次性讲清楚三个状态管理工具，但是毫不夸张，这篇文章将带你快速理解并掌握这三个工具，本篇将介绍最重要的&lt;code&gt;Flux&lt;/code&gt;架构。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Code" scheme="https://kylin.dev/categories/Code/"/>
    
    
      <category term="JavaScript" scheme="https://kylin.dev/tags/JavaScript/"/>
    
      <category term="Concept" scheme="https://kylin.dev/tags/Concept/"/>
    
  </entry>
  
  <entry>
    <title>自省-细数那些曾经乐此不疲的事</title>
    <link href="https://kylin.dev/2020/07/16/%E8%87%AA%E7%9C%81-%E7%BB%86%E6%95%B0%E9%82%A3%E4%BA%9B%E6%9B%BE%E7%BB%8F%E4%B9%90%E6%AD%A4%E4%B8%8D%E7%96%B2%E7%9A%84%E4%BA%8B/"/>
    <id>https://kylin.dev/2020/07/16/%E8%87%AA%E7%9C%81-%E7%BB%86%E6%95%B0%E9%82%A3%E4%BA%9B%E6%9B%BE%E7%BB%8F%E4%B9%90%E6%AD%A4%E4%B8%8D%E7%96%B2%E7%9A%84%E4%BA%8B/</id>
    <published>2020-07-16T12:32:50.000Z</published>
    <updated>2020-10-20T12:08:44.840Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在成长的过程中不妨也回头看看当年的自己，这篇文章就来说一说我曾经乐此不疲但又没什么用处的事，简称瞎折腾。</p><a id="more"></a><h1 id="写作初衷"><a href="#写作初衷" class="headerlink" title="写作初衷"></a>写作初衷</h1><p>看到标题你就会明白，为什么是“曾经乐此不疲”，也许你也和我一样，在很长一段时间内兴致勃勃的做同一件事，最后发现，这些事其实并没有什么用，甚至是绕了一圈又回到原地，有些懊恼，却又有些怀念。</p><p>并不是说这种折腾毫无用处，其实我在折腾中学到了很多，写这篇文章是站在现在看过去的自己，才发现在成长的过程中。</p><h1 id="怀念那颗超级好奇的心"><a href="#怀念那颗超级好奇的心" class="headerlink" title="怀念那颗超级好奇的心"></a>怀念那颗超级好奇的心</h1><p>一个人年龄越大，经历的越多，什么事都司空见惯，好奇心逐渐就没了，所以老人往往更稳重，感觉自己便是刚经历了这么一段什么事都好奇的一段时期，回过头来看那时为了什么而折腾半天，还真的有些想笑，“笑”当时能为一点小小的突破高兴一天，“笑”为了做一件事而不断地用不同的方式折腾，“笑”不值得熬夜的熬夜······</p><h1 id="细数那些乐此不疲的事"><a href="#细数那些乐此不疲的事" class="headerlink" title="细数那些乐此不疲的事"></a>细数那些乐此不疲的事</h1><p>和大都数人一样，都喜欢视觉上的折腾，总结起来就是：</p><ol><li>折腾主题、折腾皮肤</li><li>折腾系统</li><li>折腾博客</li></ol><h2 id="折腾主题、皮肤"><a href="#折腾主题、皮肤" class="headerlink" title="折腾主题、皮肤"></a>折腾主题、皮肤</h2><p>可能是人类共有的一种“本领”，而且，那些商家正好抓住了这种心理，比如 LOL 买几个皮肤、主题商店买几套主题。</p><p>高中那会儿，开始折腾手机主题，不会画图标，就从别人的包里边找一堆拼在一起，不会编程，XML 布局全部靠 copy，就这样拿着别人的的主题来自己组装，玩的不亦乐乎。后来不知怎么的就觉得没什么意思了，学到的其实不多，但至少我了解到的足够让我指导一个新人如何去制作主题包，那时很菜的我在群里解答一个新人问题也是比较有自豪感的。</p><p>至于皮肤，我不玩游戏，所以不是指游戏皮肤啦，我说的是输入法皮肤，那时候看到输入法 14 键觉得很新奇，然后寻他千百度，终于找到了来源，具体可以查看我的这篇文章：<a href="/2019/06/20/%E8%BE%93%E5%85%A5%E6%B3%95%E5%A2%9E%E5%BC%BA/" title="输入法增强">输入法增强</a>，关于皮肤作者的一系列主题我基本上都用过，着实花了不少时间来换。</p><p>你不得不承认，换皮肤、主题这种不是刚需的功能，其实是很容易让你掏腰包的。</p><h2 id="折腾系统"><a href="#折腾系统" class="headerlink" title="折腾系统"></a>折腾系统</h2><p>最开始是搞安卓系统，当时我连刷机的不知道，后来参加了 OPPO 的系统内测，涉及到降级，在刷降级包的时候才知道刷机的一般手法，也不是什么系统都刷，我只是用刷机工具刷了别人制作好的精简版 root 系统。因为只有一个手机，刷坏了就完了，所以我并没有养成刷机的习惯。</p><p>大一下期，自己掏钱换了台电脑，多了台闲置的电脑，果不其然养成了我爱折腾系统的毛病。在换电脑之前我还是挣扎了一下，本来机子是 x64 的，但人家给装的 x86，然后我换成了 Windows 10 x64，本以为这样能快一点，可 14 年 i3 的机子托 x64 的系统显得更慢了，换了条 8G 内存条也无果，最后选择换电脑。所以我就在这台闲置电脑上装多系统，最开始装的是 Deepin，也是我迄今为止体验过最棒的 Linux 桌面系统。后来在电脑上装好几个系统，有<a href="https://www.microsoft.com/zh-cn/windows/">Windows 10</a>，<a href="https://www.microsoft.com/zh-cn/windows/">Deepin 15</a>，<a href="https://ubuntu.com/">Ubuntu</a>，<a href="https://manjaro.org/">Manjaro</a>，还有大多数人不知道的<a href="http://www.gd-linux.com/">新支点操作系统</a>，ChromeOS 的一个第三方发行版<a href="https://fydeos.com/">FydeOS</a>，其实现在想一想，装这么多系统没有什么实用性，让我慢慢停止这种做法的原因就在于此，注重实用性，所以我又开始折腾 WSL 和 WSL2 了（我真的是生命不息折腾不止）。</p><h2 id="折腾博客和站点"><a href="#折腾博客和站点" class="headerlink" title="折腾博客和站点"></a>折腾博客和站点</h2><h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><p>这个是我今年经常干的事，一开始我的博客站点是使用<a href="https://gridea.dev">Gridea</a>，后来看到别人说<a href="http://typecho.org/">Typecho</a>就去尝试了。可以想象一下将一个静态站点转为动态的苦恼，还好写的文章不算多，迁移没有花太多时间，后来将 Typecho 上的文章迁移到 Hexo 才悔不当初。不管用什么博客平台，换主题是免不了的，我也是主题市场的常客。</p><p><img src="https://i.loli.net/2020/07/24/ofKVTqEl72i9jsI.png" alt="liqilinhub.cloud.png"></p><p><img src="https://i.loli.net/2020/07/24/Frsofka746ILR5Y.png" alt="lqilinhub.cloud-about.png"></p><p>想着服务器上只放个博客太浪费了，于是部署了很多服务在上面。</p><h3 id="Chevereto"><a href="#Chevereto" class="headerlink" title="Chevereto"></a>Chevereto</h3><p><a href="https://chevereto.com/">Chevereto</a>，PHP 作为后端的图床应用：</p><p><img src="https://i.loli.net/2020/07/24/2Wr7yMJSHiGBEmt.jpg" alt="image.liqilinhub.cloud-home.jpg"></p><p><img src="https://i.loli.net/2020/07/24/PCQlIE2eudKOfj5.jpg" alt="image.liqilinhub.cloud-image.jpg"></p><p>我会将我拍的一些照片放在上面。</p><h3 id="Seafile"><a href="#Seafile" class="headerlink" title="Seafile"></a>Seafile</h3><p><a href="https://www.seafile.com/home/">Seafile</a>，开源的网盘应用，我用来搭建私人网盘，可以解决传文件的困苦，同时支持 WEBDAV，做云同步很方便。</p><p><img src="https://i.loli.net/2020/07/24/7zyqcZj5RWXlCK1.png" alt="pan.liqilinhub.cloud.png"></p><h3 id="GOGS"><a href="#GOGS" class="headerlink" title="GOGS"></a>GOGS</h3><p><a href="https://gogs.io/">GOGS</a>，用来搭建自用的 Git 服务，类似于一个轻量级的 GitHub。</p><p><img src="https://i.loli.net/2020/07/24/rcuLDzs47PATy2k.png" alt="git.liqilinhub.cloud.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>就到这里，现在的我总是羡慕过去的自己，做着自己喜欢的事，有很多时间去做。希望未来的我也将保持这种好奇心，什么事总要去尝试一番。</p><article class="message message-immersive is-primary"><div class="message-body"><p>看到这篇文章的朋友，如果对上面提及的应用的使用和部署有疑问，欢迎在下面留言，也许我可以给你提供帮助。</p></div></article><article class="message message-immersive is-warning"><div class="message-body"><p>本文作者：KylinLee</p><p>本文链接：<a href="https://kylin.dev/2020/07/16/自省-细数那些曾经乐此不疲的事">https://kylin.dev/2020/07/16/自省-细数那些曾经乐此不疲的事</a></p><p>版权声明：本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p></div></article>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在成长的过程中不妨也回头看看当年的自己，这篇文章就来说一说我曾经乐此不疲但又没什么用处的事，简称瞎折腾。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Life" scheme="https://kylin.dev/categories/Life/"/>
    
    
      <category term="Other" scheme="https://kylin.dev/tags/Other/"/>
    
      <category term="Essay" scheme="https://kylin.dev/tags/Essay/"/>
    
  </entry>
  
  <entry>
    <title>数据结构：树</title>
    <link href="https://kylin.dev/2020/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91/"/>
    <id>https://kylin.dev/2020/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91/</id>
    <published>2020-07-12T10:54:55.000Z</published>
    <updated>2020-10-19T12:08:03.013Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>树（Tree）是一种抽象数据类型或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。这篇文章主要介绍树的相关概念、性质及数学推论。</p><a id="more"></a><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>树是由 n（n≥0）个有限结点组成一个具有层次关系的集合，当 n=0 时，称这棵树为空树。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下性质：</p><ul><li>每个结点都只有有限个子结点或无子结点</li><li>没有父结点的结点称为根结点</li><li>每一个非根结点有且只有一个父结点</li><li>除了根结点外，每个子结点可以分为多个不相交的子树</li><li>树里面没有环路(cycle)</li></ul><h1 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h1><p>在学习树的过程中，你可能会遇到以下名词：<br><strong>理解这些词应该优先从树或子树的角度出发。</strong></p><ul><li><strong>结点</strong><br>树中的一个独立单元，之前我们说了，树是一个集合，结点就是这个集合中的一个元素。</li><li><strong>结点的度</strong><br>结点拥有的子树数称为结点的度。</li><li><strong>树的度</strong><br>树的度是树内各结点度的最大值。</li><li><strong>叶子（叶子结点）</strong><br>度为 0 的结点称为叶子或终端结点。</li><li><strong>非终端结点（分支结点）</strong><br>度不为 0 的结点称为非终端结点或分支结点。除根结点之外，非终端结点也称为内部结点。</li><li><strong>双亲（双亲结点）、孩子（孩子结点）</strong><br>结点的子树的根称为该结点的孩子，相应地，该结点称为孩子的双亲。</li><li><strong>兄弟（结点）</strong><br>同一个双亲的孩子之间互称兄弟。</li><li><strong>祖先（祖先结点）</strong><br>从根到该结点所经分支上的所有结点。</li><li><strong>子孙（子孙结点）</strong><br>以某结点为根的子树中的任一结点都称为该结点的子孙。</li><li><strong>层次</strong><br>结点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中任一结点的层次等千其双亲结点的层次加 1。</li><li><strong>堂兄弟（堂兄弟结点）</strong><br>双亲在同一层的结点互为堂兄弟。</li><li><strong>树的深度、树的高度</strong><br>树的深度或高度数值上等于树中结点的最大层次，深度以根结点为 1 向叶子结点递增，高度以叶子结点为 1 向根结点递增。</li><li><strong>结点的深度、结点的高度</strong><br>结点的深度或高度数值上等于以该结点为根结点的子树的最大层次，深度以目标结点为 1 向叶子结点递增，高度以叶子结点为 1 向目标结点递增。</li><li><strong>有序树和无序树</strong><br>如果将树中结点的各子树看成从左至右是有次序的（即不能互换），则称该树为有序树，否则称为无序树。在有序树中最左边的子树的根称为第一个孩子，最右边的称为最后一个孩子。</li><li><strong>森林</strong><br>m (m≥0)棵互不相交的树的集合。</li><li><strong>路径</strong><br>两个结点之间经过的结点序列，路径的方向为子结点指向子结点（自上而下）。</li><li><strong>路径长度</strong><br>一条路径中经过的边的条数。</li><li><strong>n 叉树</strong><br>一棵树中允许结点拥有子树的最大数目，如二叉树允许一个结点最多可拥有两个子树。</li></ul><h1 id="形象描述"><a href="#形象描述" class="headerlink" title="形象描述"></a>形象描述</h1><p>为了便于更形象的理解二叉树，我们可以用图形来表示树，通常用圆形表示一个结点，用线段表示结点之间的关系，下面的图中因为某些限制，结点之间的连接是折线，事实上用直线来连接更好一点，此外，连接是具有方向性的，为父结点指向子结点，你可以使用箭头线段来连接，一棵树看起来是这样的：</p><p><img src="https://i.loli.net/2020/10/01/OFgvi1Lhw5Bea6C.png" alt="tree.png"></p><p>这棵树有 7 个结点，1 结点的度为 2，2 结点的度为 3，3 结点的度为 1，其他结点（4,5,6,7）的度为 0，这些度为 0 结点被称为叶子结点，其他结点为非终端结点（他们的度不为 0），整棵树的度为 3，深度也为 3。</p><h1 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h1><p>树的存储可以使用顺序存储或链式存储实现，顺序存储结构不是很灵活，通常用于储存特定的 M 叉树，如二叉树的存储可以使用顺序存储。最通用的方式是使用链式存储。无论哪种存储结构，其每个结点的结构都是相似的，都有数据区和指针区，因为一个结点可以有很多孩子结点，所以指针区相对于链表要复杂一点，如果说链表的每一个结点的指针域都指向空或者唯一的结点，而树中每一个结点的指针指向多少结点是不确定的。</p><h2 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h2><p>一个结点可能没有孩子结点，但一定有一个唯一的双亲结点（除根节点外），利用这个方式可以很快的找到双亲结点。但是如果仅仅是这样表示，只能连接两个结点，要表示一棵完整的树还需要指针将所有节点连接起来，最简单的方式是利用顺序存储结构，可以避免手动创建指针，当然，你也可以利用链表将他们连起来。<br><img src="https://i.loli.net/2020/10/19/WLvg9IZ1k3CNfP6.png" alt="parent-tree.png"><br>这种方法能方便的找到父节点，但要找到兄弟节点和孩子节点比较复杂。</p><h2 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h2><p>树的孩子表示法通过线性表来实现，首先将每个结点存入顺序表中，顺序表的每一个结点除了保存树中每个结点的信息，还包含一个指针域，指向该结点的直接子元素构成的链表。</p><p><img src="https://i.loli.net/2020/10/19/f9NTdtKJk73RXr2.png" alt="parent-child-tree.png"><br>这种方法可以很快的找到某个节点的孩子节点，但找到兄弟节点比较困难。</p><h2 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h2><p>孩子兄弟表示法完全采用链表实现，在链表的每一个节点中，有三个域，分别为孩子指针域、数据域、兄弟指针域，逻辑结构如下：<br><img src="https://i.loli.net/2020/10/19/Pti8RWGKyngJFDO.png" alt="child-brother-tree.png"><br>这种表示方法可以很轻松的查找兄弟很孩子节点，但查找父节点比较麻烦。</p><h1 id="树的相关推论"><a href="#树的相关推论" class="headerlink" title="树的相关推论"></a>树的相关推论</h1><h2 id="结点拥有的结点数为所有结点的度数-1"><a href="#结点拥有的结点数为所有结点的度数-1" class="headerlink" title="结点拥有的结点数为所有结点的度数+1"></a>结点拥有的结点数为所有结点的度数+1</h2><h3 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h3><p><code>由结点的度和孩子结点的概念可得，结点的度数=该结点孩子结点的个数</code></p><p><code>∵ 除根结点外其余结点都可以作为孩子结点</code></p><p><code>∴ 树的结点总数=孩子结点总数+根结点数=所有结点的度数+根结点数=所有结点的度数+1</code></p><h2 id="一棵有-n-个结点的树有-n-1-条边（结点之间的连线）"><a href="#一棵有-n-个结点的树有-n-1-条边（结点之间的连线）" class="headerlink" title="一棵有 n 个结点的树有 n-1 条边（结点之间的连线）"></a>一棵有 n 个结点的树有 n-1 条边（结点之间的连线）</h2><h3 id="证明：-1"><a href="#证明：-1" class="headerlink" title="证明："></a>证明：</h3><p><code>∵ 树中除根结点外每个结点都有一个父结点，即这些结点都有一条线与父结点连接</code></p><p><code>∴ 边的数目为结点数减去根结点数 1</code></p><h2 id="度为-m-的树中第-i-层最多有-mi-1个结点（i≥1）"><a href="#度为-m-的树中第-i-层最多有-mi-1个结点（i≥1）" class="headerlink" title="度为 m 的树中第 i 层最多有 mi-1个结点（i≥1）"></a>度为 m 的树中第 i 层最多有 m<sup>i-1</sup>个结点（i≥1）</h2><h3 id="证明：-2"><a href="#证明：-2" class="headerlink" title="证明："></a>证明：</h3><p><code>若考虑最多的情况，则每一个结点的度都为 m，即每一个结点都有 m 个孩子结点，即第 i 层的每一个结点在第 i+1 层都会产生 m 个孩子结点。</code></p><p><code>设</code>N(i)<code>为第 i 层的结点数，第 i+1 层结点数可表示为</code> N(i)×m</p><p><code>∵</code>N(i)<code>的个数为</code>N(i-1)×m，<code>可得</code> N(i+1)=N(i-1)×m×m</p><p><code>依次进行如上的转化，可得到</code>N(i+1)=N(i-n)×m<sup>n+1</sup></p><p><code>即</code> N(i)=N(i-n)×m<sup>n</sup></p><p><code>这是一个通式，知道任意一层结点的个数即可推出其他层结点的个数，最好考虑的是第一层</code></p><p><code>∵</code> N(1)=1</p><p><code>∴ 将上面的 i-n 化为 1</code></p><p><code>可得</code>N(i)=N(1)×m<sup>i-1</sup></p><p><code>∴ 度为 m 的树中第 i 层最多有</code>m<sup>i-1</sup><code>个结点</code></p><h3 id="代码验证："><a href="#代码验证：" class="headerlink" title="代码验证："></a>代码验证：</h3><figure class="highlight go"><figcaption><span>Golang</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">degree：树的度</span></span><br><span class="line"><span class="comment">level：层序数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getNodeNum</span><span class="params">(degree, level <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> level != <span class="number">1</span> &#123;</span><br><span class="line">        level--</span><br><span class="line">        <span class="keyword">return</span> getNodeNum(degree, level)*degree</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> degree, level <span class="keyword">int</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;请输入树的度\n&quot;</span>)</span><br><span class="line">    fmt.Scan(&amp;degree)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;请输入层序数\n&quot;</span>)</span><br><span class="line">    fmt.Scan(&amp;level)</span><br><span class="line">    nodeNum := getNodeNum(degree, level)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;度为%d的树中第%d层最多有%d个结点\n&quot;</span>, degree, level, nodeNum)</span><br><span class="line">    main()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的数学证明过程中你应该就想到了用递归的方式实现，代码也是这样做的，让我们检验一下:</p><figure class="highlight powershell"><figcaption><span>点击展开 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">请输入树的度</span><br><span class="line"><span class="number">2</span></span><br><span class="line">请输入层序数</span><br><span class="line"><span class="number">9</span></span><br><span class="line">度为 <span class="number">2</span> 的树中第 <span class="number">9</span> 层最多有 <span class="number">256</span> 个结点</span><br><span class="line">请输入树的度</span><br><span class="line"><span class="number">3</span></span><br><span class="line">请输入层序数</span><br><span class="line"><span class="number">4</span></span><br><span class="line">度为 <span class="number">3</span> 的树中第 <span class="number">4</span> 层最多有 <span class="number">27</span> 个结点</span><br></pre></td></tr></table></figure><p>根据检验，2<sup>9-1</sup>=256，3<sup>4-1</sup>=27，再次证明度为 m 的树中第 i 层最多有 m<sup>i-1</sup>个结点。</p><p>顺便提一句，当度为 2 时，讨论极限条件，这棵树是满二叉树，根据这个结论可以得出它的性质：第 i 层有 2<sup>i-1</sup>个结点，这在以后的文章中便不做推导了。</p><h2 id="高度为-h-的-m-叉树至多有-mh-1-÷-m-1-个结点"><a href="#高度为-h-的-m-叉树至多有-mh-1-÷-m-1-个结点" class="headerlink" title="高度为 h 的 m 叉树至多有 (mh-1)÷(m-1)个结点"></a>高度为 h 的 m 叉树至多有 (m<sup>h</sup>-1)÷(m-1)个结点</h2><p>这个推论接着上一条结论继续往下推，高度为 h 实际上是告诉了我们这棵树的层数，考虑至多的极限情况，m 就是上一条结论中的度，实际上证明这个推论只需要将每一层的结点数求和，首先将每一层的结点数构造成等比数列，再按等比求和公式求和：</p><h3 id="证明：-3"><a href="#证明：-3" class="headerlink" title="证明："></a>证明：</h3><p><code>考虑最多情况，m 叉树的每一个结点都会在下一层产生 m 个结点</code></p><p><code>设</code>N(h)<code>为第 h 层的结点数，第 h+1 层结点数可表示为</code> N(h)×m</p><p><code>设数列</code>{a<sub>h</sub>}，a<sub>1</sub>=N(1)，a<sub>2</sub>=N(2)，a<sub>h</sub>=N(h)，a<sub>h+1</sub>=N(h+1) (h≥1)</p><p><code>由条件可知</code>a<sub>1</sub>=N(1)=1</p><p><code>∵</code>a<sub>h+1</sub>÷a<sub>h</sub>=N(h+1)÷N(h)=m，<code>h≥2</code></p><p><code>根据定义，数列</code>{a<sub>h</sub>}<code>是以首项为1，公比为m(m&gt;0)的等比数列</code></p><p><code>设数列</code>{a<sub>h</sub>}<code>的前n项和为</code>S<sub>h</sub></p><p><code>由求和公式</code></p><p>$$<br>S_n=\frac{a_1\times(1-q^n)}{1-q}, (q\neq1)<br>$$</p><p>a<sub>1</sub>=1，q=m，m≠1，n=h</p><p><code>可得</code></p><p>$$<br>S_n=\frac{(1-m^h)}{1-m}<br>$$</p><h2 id="具有-n-个结点的满-m-叉树的最小高度为-logm-n-m-1-1"><a href="#具有-n-个结点的满-m-叉树的最小高度为-logm-n-m-1-1" class="headerlink" title="具有 n 个结点的满 m 叉树的最小高度为 logm(n(m-1)+1)"></a>具有 n 个结点的满 m 叉树的最小高度为 log<sub>m</sub>(n(m-1)+1)</h2><h3 id="证明：-4"><a href="#证明：-4" class="headerlink" title="证明："></a>证明：</h3><p>考虑极限条件，要求得最小高度，就需要将每一层填满，之前我们已经证明了 m 叉树每一层的最大结点数，这其实是上一个结论的逆向问题，同样的先将每一层的结点数构造成数列，转换为数学问题就是已知通项公式，前 h 项和，求 h 的值，这个证明这个结论需要做的就是得出通项公式和前 h 项和，通项公式在证明上一个结论时已经得出，进而可以得出前 h 项的和为</p><p>$$<br>S_h=\frac{(1-m^h)}{1-m}<br>$$</p><p>令 S<sub>h</sub>=n 反解出 h</p><p>$$<br>h=\log_m{(n(m-1)+1)}<br>$$</p><article class="message message-immersive is-warning"><div class="message-body"><p>本文作者：KylinLee</p><p>本文链接：<a href="https://kylin.dev/2020/07/12/数据结构：树">https://kylin.dev/2020/07/12/数据结构：树</a></p><p>版权声明：本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p></div></article>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;树（Tree）是一种抽象数据类型或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。这篇文章主要介绍树的相关概念、性质及数学推论。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Code" scheme="https://kylin.dev/categories/Code/"/>
    
    
      <category term="Concept" scheme="https://kylin.dev/tags/Concept/"/>
    
      <category term="DataStructure" scheme="https://kylin.dev/tags/DataStructure/"/>
    
  </entry>
  
</feed>
