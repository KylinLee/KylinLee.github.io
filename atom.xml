<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>蝶恋花-等风也等你</title>
  
  <subtitle>等风也等你</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kylin.dev/"/>
  <updated>2020-07-16T14:29:46.228Z</updated>
  <id>https://kylin.dev/</id>
  
  <author>
    <name>Kylin Lee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>自省-细数那些曾经乐此不疲的事</title>
    <link href="https://kylin.dev/2020/07/16/%E8%87%AA%E7%9C%81-%E7%BB%86%E6%95%B0%E9%82%A3%E4%BA%9B%E6%9B%BE%E7%BB%8F%E4%B9%90%E6%AD%A4%E4%B8%8D%E7%96%B2%E7%9A%84%E4%BA%8B/"/>
    <id>https://kylin.dev/2020/07/16/%E8%87%AA%E7%9C%81-%E7%BB%86%E6%95%B0%E9%82%A3%E4%BA%9B%E6%9B%BE%E7%BB%8F%E4%B9%90%E6%AD%A4%E4%B8%8D%E7%96%B2%E7%9A%84%E4%BA%8B/</id>
    <published>2020-07-16T12:32:50.000Z</published>
    <updated>2020-07-16T14:29:46.228Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>一个人要成长，深刻的自我反省是离不开的。</p><a id="more"></a><article class="message message-immersive is-warning"><div class="message-body"><p>本文作者：KylinLee</p><p>本文链接：<a href="https://kylin.dev/2020/07/16/自省-细数那些曾经乐此不疲的事">https://kylin.dev/2020/07/16/自省-细数那些曾经乐此不疲的事</a></p><p>版权声明：本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p></div></article>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个人要成长，深刻的自我反省是离不开的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Life" scheme="https://kylin.dev/categories/Life/"/>
    
    
      <category term="Other" scheme="https://kylin.dev/tags/Other/"/>
    
      <category term="Essay" scheme="https://kylin.dev/tags/Essay/"/>
    
  </entry>
  
  <entry>
    <title>数据结构：树</title>
    <link href="https://kylin.dev/2020/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91/"/>
    <id>https://kylin.dev/2020/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91/</id>
    <published>2020-07-12T10:54:55.000Z</published>
    <updated>2020-07-16T13:02:37.264Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>树（Tree）是一种抽象数据类型或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。这篇文章主要介绍树的相关概念、性质及数学推论。</p><a id="more"></a><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>树是由 n（n≥0）个有限结点组成一个具有层次关系的集合，当 n=0 时，称这棵树为空树。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下性质：</p><ul><li>每个结点都只有有限个子结点或无子结点</li><li>没有父结点的结点称为根结点</li><li>每一个非根结点有且只有一个父结点</li><li>除了根结点外，每个子结点可以分为多个不相交的子树</li><li>树里面没有环路(cycle)</li></ul><h1 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h1><p>在学习树的过程中，你可能会遇到以下名词：<br><strong>理解这些词应该优先从树或子树的角度出发。</strong></p><ul><li><strong>结点</strong><br>树中的一个独立单元，之前我们说了，树是一个集合，结点就是这个集合中的一个元素。</li><li><strong>结点的度</strong><br>结点拥有的子树数称为结点的度。</li><li><strong>树的度</strong><br>树的度是树内各结点度的最大值。</li><li><strong>叶子（叶子结点）</strong><br>度为 0 的结点称为叶子或终端结点。</li><li><strong>非终端结点（分支结点）</strong><br>度不为 0 的结点称为非终端结点或分支结点。除根结点之外，非终端结点也称为内部结点。</li><li><strong>双亲（双亲结点）、孩子（孩子结点）</strong><br>结点的子树的根称为该结点的孩子，相应地，该结点称为孩子的双亲。</li><li><strong>兄弟（结点）</strong><br>同一个双亲的孩子之间互称兄弟。</li><li><strong>祖先（祖先结点）</strong><br>从根到该结点所经分支上的所有结点。</li><li><strong>子孙（子孙结点）</strong><br>以某结点为根的子树中的任一结点都称为该结点的子孙。</li><li><strong>层次</strong><br>结点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中任一结点的层次等千其双亲结点的层次加 1。</li><li><strong>堂兄弟（堂兄弟结点）</strong><br>双亲在同一层的结点互为堂兄弟。</li><li><strong>树的深度、树的高度</strong><br>树的深度或高度数值上等于树中结点的最大层次，深度以根结点为 1 向叶子结点递增，高度以叶子结点为 1 向根结点递增。</li><li><strong>结点的深度、结点的高度</strong><br>结点的深度或高度数值上等于以该结点为根结点的子树的最大层次，深度以目标结点为 1 向叶子结点递增，高度以叶子结点为 1 向目标结点递增。</li><li><strong>有序树和无序树</strong><br>如果将树中结点的各子树看成从左至右是有次序的（即不能互换），则称该树为有序树，否则称为无序树。在有序树中最左边的子树的根称为第一个孩子，最右边的称为最后一个孩子。</li><li><strong>森林</strong><br>m (m≥0)棵互不相交的树的集合。</li><li><strong>路径</strong><br>两个结点之间经过的结点序列，路径的方向为子结点指向子结点（自上而下）。</li><li><strong>路径长度</strong><br>一条路径中经过的边的条数。</li><li><strong>n 叉树</strong><br>一棵树中允许结点拥有子树的最大数目，如二叉树允许一个结点最多可拥有两个子树。</li></ul><h1 id="形象描述"><a href="#形象描述" class="headerlink" title="形象描述"></a>形象描述</h1><p>为了便于更形象的理解二叉树，我们可以用图形来表示树，通常用圆形表示一个结点，用线段表示结点之间的关系，下面的图中因为某些限制，结点之间的连接是折线，事实上用直线来连接更好一点，此外，连接是具有方向性的，为父结点指向子结点，你可以使用箭头线段来连接，一棵树看起来是这样的：</p><pre class="mermaid">graph TB;    A((1))---B((2))    A---C((3));    B---E((4))    B---F((5))    B---H((6))    C---I((7))</pre><p>这棵树有 7 个结点，1 结点的度为 2，2 结点的度为 3，3 结点的度为 1，其他结点（4,5,6,7）的度为 0，这些度为 0 结点被称为叶子结点，其他结点为非终端结点（他们的度不为 0），整棵树的度为 3，深度也为 3。</p><h1 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h1><p>树的存储可以使用顺序存储或链式存储实现，最通用的方式是使用链式存储。树是一个集合，集合中的元素的关系通过指针指向结点元素来表示，还记得单链表吗，单链表有一个存储数据的区域和一个存储下一元素地址的指针区域，它的指针区域通常只有一个，一个结点最多只能连接一个结点，观察我们绘制的树的形象图就能看出树的一个结点后面能连接多个子结点，树的存储结构核心思想就是这样，但我们有很多种方法来储存一棵树。</p><h2 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h2><h2 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h2><h2 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h2><h1 id="树的相关推论"><a href="#树的相关推论" class="headerlink" title="树的相关推论"></a>树的相关推论</h1><h2 id="结点拥有的结点数为所有结点的度数-1"><a href="#结点拥有的结点数为所有结点的度数-1" class="headerlink" title="结点拥有的结点数为所有结点的度数+1"></a>结点拥有的结点数为所有结点的度数+1</h2><h3 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h3><p><code>由结点的度和孩子结点的概念可得，结点的度数=该结点孩子结点的个数</code></p><p><code>∵ 除根结点外其余结点都可以作为孩子结点</code></p><p><code>∴ 树的结点总数=孩子结点总数+根结点数=所有结点的度数+根结点数=所有结点的度数+1</code></p><h2 id="一棵有-n-个结点的树有-n-1-条边（结点之间的连线）"><a href="#一棵有-n-个结点的树有-n-1-条边（结点之间的连线）" class="headerlink" title="一棵有 n 个结点的树有 n-1 条边（结点之间的连线）"></a>一棵有 n 个结点的树有 n-1 条边（结点之间的连线）</h2><h3 id="证明：-1"><a href="#证明：-1" class="headerlink" title="证明："></a>证明：</h3><p><code>∵ 树中除根结点外每个结点都有一个父结点，即这些结点都有一条线与父结点连接</code></p><p><code>∴ 边的数目为结点数减去根结点数 1</code></p><h2 id="度为-m-的树中第-i-层最多有-mi-1个结点（i≥1）"><a href="#度为-m-的树中第-i-层最多有-mi-1个结点（i≥1）" class="headerlink" title="度为 m 的树中第 i 层最多有 mi-1个结点（i≥1）"></a>度为 m 的树中第 i 层最多有 m<sup>i-1</sup>个结点（i≥1）</h2><h3 id="证明：-2"><a href="#证明：-2" class="headerlink" title="证明："></a>证明：</h3><p><code>若考虑最多的情况，则每一个结点的度都为 m，即每一个结点都有 m 个孩子结点，即第 i 层的每一个结点在第 i+1 层都会产生 m 个孩子结点。</code></p><p><code>设</code>N(i)<code>为第 i 层的结点数，第 i+1 层结点数可表示为</code> N(i)×m</p><p><code>∵</code>N(i)<code>的个数为</code>N(i-1)×m，<code>可得</code> N(i+1)=N(i-1)×m×m</p><p><code>依次进行如上的转化，可得到</code>N(i+1)=N(i-n)×m<sup>n+1</sup></p><p><code>即</code> N(i)=N(i-n)×m<sup>n</sup></p><p><code>这是一个通式，知道任意一层结点的个数即可推出其他层结点的个数，最好考虑的是第一层</code></p><p><code>∵</code> N(1)=1</p><p><code>∴ 将上面的 i-n 化为 1</code></p><p><code>可得</code>N(i)=N(1)×m<sup>i-1</sup></p><p><code>∴ 度为 m 的树中第 i 层最多有</code>m<sup>i-1</sup><code>个结点</code></p><h3 id="代码验证："><a href="#代码验证：" class="headerlink" title="代码验证："></a>代码验证：</h3><figure class="highlight go"><figcaption><span>Golang</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">degree：树的度</span></span><br><span class="line"><span class="comment">level：层序数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getNodeNum</span><span class="params">(degree, level <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> level != <span class="number">1</span> &#123;</span><br><span class="line">        level--</span><br><span class="line">        <span class="keyword">return</span> getNodeNum(degree, level)*degree</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> degree, level <span class="keyword">int</span></span><br><span class="line">    fmt.Printf(<span class="string">"请输入树的度\n"</span>)</span><br><span class="line">    fmt.Scan(&amp;degree)</span><br><span class="line">    fmt.Printf(<span class="string">"请输入层序数\n"</span>)</span><br><span class="line">    fmt.Scan(&amp;level)</span><br><span class="line">    nodeNum := getNodeNum(degree, level)</span><br><span class="line">    fmt.Printf(<span class="string">"度为%d的树中第%d层最多有%d个结点\n"</span>, degree, level, nodeNum)</span><br><span class="line">    main()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的数学证明过程中你应该就想到了用递归的方式实现，代码也是这样做的，让我们检验一下:</p><figure class="highlight powershell"><figcaption><span>Powershell</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">请输入树的度</span><br><span class="line"><span class="number">2</span></span><br><span class="line">请输入层序数</span><br><span class="line"><span class="number">9</span></span><br><span class="line">度为 <span class="number">2</span> 的树中第 <span class="number">9</span> 层最多有 <span class="number">256</span> 个结点</span><br><span class="line">请输入树的度</span><br><span class="line"><span class="number">3</span></span><br><span class="line">请输入层序数</span><br><span class="line"><span class="number">4</span></span><br><span class="line">度为 <span class="number">3</span> 的树中第 <span class="number">4</span> 层最多有 <span class="number">27</span> 个结点</span><br></pre></td></tr></table></figure><p>根据检验，2<sup>9-1</sup>=256，3<sup>4-1</sup>=27，再次证明度为 m 的树中第 i 层最多有 m<sup>i-1</sup>个结点。</p><p>顺便提一句，当度为 2 时，讨论极限条件，这棵树是满二叉树，根据这个结论可以得出它的性质：第 i 层有 2<sup>i-1</sup>个结点，这在以后的文章中便不做推导了。</p><h2 id="高度为-h-的-m-叉树至多有-mh-1-÷-m-1-个结点"><a href="#高度为-h-的-m-叉树至多有-mh-1-÷-m-1-个结点" class="headerlink" title="高度为 h 的 m 叉树至多有 (mh-1)÷(m-1)个结点"></a>高度为 h 的 m 叉树至多有 (m<sup>h</sup>-1)÷(m-1)个结点</h2><p>这个推论接着上一条结论继续往下推，高度为 h 实际上是告诉了我们这棵树的层数，考虑至多的极限情况，m 就是上一条结论中的度，实际上证明这个推论只需要将每一层的结点数求和，首先将每一层的结点数构造成等比数列，再按等比求和公式求和：</p><h3 id="证明：-3"><a href="#证明：-3" class="headerlink" title="证明："></a>证明：</h3><p><code>考虑最多情况，m 叉树的每一个结点都会在下一层产生 m 个结点</code></p><p><code>设</code>N(h)<code>为第 h 层的结点数，第 h+1 层结点数可表示为</code> N(h)×m</p><p><code>设数列</code>{a<sub>h</sub>}，a<sub>1</sub>=N(1)，a<sub>2</sub>=N(2)，a<sub>h</sub>=N(h)，a<sub>h+1</sub>=N(h+1) (h≥1)</p><p><code>由条件可知</code>a<sub>1</sub>=N(1)=1</p><p><code>∵</code>a<sub>h+1</sub>÷a<sub>h</sub>=N(h+1)÷N(h)=m，<code>h≥2</code></p><p><code>根据定义，数列</code>{a<sub>h</sub>}<code>是以首项为1，公比为m(m&gt;0)的等比数列</code></p><p><code>设数列</code>{a<sub>h</sub>}<code>的前n项和为</code>S<sub>h</sub></p><p><code>由求和公式</code></p><p>$$<br>S_n=\frac{a_1\times(1-q^n)}{1-q}, (q\neq1)<br>$$</p><p>a<sub>1</sub>=1，q=m，m≠1，n=h</p><p><code>可得</code></p><p>$$<br>S_n=\frac{(1-m^h)}{1-m}<br>$$</p><h2 id="具有-n-个结点的满-m-叉树的最小高度为-logm-n-m-1-1"><a href="#具有-n-个结点的满-m-叉树的最小高度为-logm-n-m-1-1" class="headerlink" title="具有 n 个结点的满 m 叉树的最小高度为 logm(n(m-1)+1)"></a>具有 n 个结点的满 m 叉树的最小高度为 log<sub>m</sub>(n(m-1)+1)</h2><h3 id="证明：-4"><a href="#证明：-4" class="headerlink" title="证明："></a>证明：</h3><p>考虑极限条件，要求得最小高度，就需要将每一层填满，之前我们已经证明了 m 叉树每一层的最大结点数，这其实是上一个结论的逆向问题，同样的先将每一层的结点数构造成数列，转换为数学问题就是已知通项公式，前 h 项和，求 h 的值，这个证明这个结论需要做的就是得出通项公式和前 h 项和，通项公式在证明上一个结论时已经得出，进而可以得出前 h 项的和为</p><p>$$<br>S_h=\frac{(1-m^h)}{1-m}<br>$$</p><p>令 S<sub>h</sub>=n 反解出 h</p><p>$$<br>h=\log_m{(n(m-1)+1)}<br>$$</p><article class="message message-immersive is-warning"><div class="message-body"><p>本文作者：KylinLee</p><p>本文链接：<a href="https://kylin.dev/2020/07/12/数据结构：树">https://kylin.dev/2020/07/12/数据结构：树</a></p><p>版权声明：本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p></div></article><script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script><script>    if (window.mermaid) {      mermaid.initialize({theme: 'forest'});    }</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;树（Tree）是一种抽象数据类型或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。这篇文章主要介绍树的相关概念、性质及数学推论。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Code" scheme="https://kylin.dev/categories/Code/"/>
    
    
      <category term="Concept" scheme="https://kylin.dev/tags/Concept/"/>
    
      <category term="DataStructure" scheme="https://kylin.dev/tags/DataStructure/"/>
    
  </entry>
  
  <entry>
    <title>在Vue中使用GraphQL</title>
    <link href="https://kylin.dev/2020/07/10/%E5%9C%A8Vue%E4%B8%AD%E4%BD%BF%E7%94%A8GraphQL/"/>
    <id>https://kylin.dev/2020/07/10/%E5%9C%A8Vue%E4%B8%AD%E4%BD%BF%E7%94%A8GraphQL/</id>
    <published>2020-07-10T03:51:15.000Z</published>
    <updated>2020-07-12T11:13:51.493Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本文帮助你在 Vue 中使用 GraphQL，也许你尝试使用过<a href="https://github.com/axios/axios">axios</a>，不得不说 axios 并不适合用来发送 GraphQL API 请求，本文介绍一种更简单的方式并且带你上手。如果你对 GraphQL 后端感兴趣可以阅读我的上一篇文章《<a href="/2020/07/07/Apollo-GraphQL%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E6%9C%8D%E5%8A%A1%E7%AB%AF/" title="Apollo-GraphQL快速上手-服务端">Apollo-GraphQL快速上手-服务端</a>》。</p><a id="more"></a><p>官方维护的 Apollo Client 是 React 编写的，我使用的是 Vue，虽然说是由社区维护，但 API 基本是按照 React 版本的来写的，用起来障碍也不大。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>社区维护的 Vue 版本的 Apollo Client 叫<a href="https://apollo.vuejs.org/">vue-apollo</a>，安装也相当简单，首先使用 Vue Cli 创建一个项目，然后在项目文件夹运行命令：<code>vue add apollo</code>。</p><p>由于有<a href="https://apollo.vuejs.org/">中文文档</a>，我就取其精要，带大家简单上手，更高级的操作，大家可以去网站上看一看。<strong>本文的逻辑和文档大不相同，如果你理解本文的思路，你将可以更灵活的操作 GraphQL 请求</strong></p><h1 id="apollo-对象"><a href="#apollo-对象" class="headerlink" title="apollo 对象"></a>apollo 对象</h1><p><strong><code>apollo</code>对象是 apollo-vue 的核心，无论是查询还是变更，只要向可接受<code>apollo</code>对象的地方传入它就可以完成 GraphQL 的查询与变更。</strong>常用的属性和方法有四个：<code>query</code>、<code>variables</code>、<code>mutation</code>、<code>update()</code>，看起来应该是这样的：</p><figure class="highlight javascript"><figcaption><span>template.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apolloObj: &#123;</span><br><span class="line">    query: gql<span class="string">`</span></span><br><span class="line"><span class="string">        query&#123;&#125;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">    mutation: gql<span class="string">`</span></span><br><span class="line"><span class="string">        mutation&#123;&#125;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">    variables: &#123;</span><br><span class="line">        var1: <span class="keyword">this</span>.data.name</span><br><span class="line">    &#125;,</span><br><span class="line">    update()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>query</code>：GraphQL 查询代码</li><li><code>mutation</code>：GraphQL 变更代码</li><li><code>variables</code>：GraphQL 代码中不能使用 js 的变量，<code>variables</code>相当于转换器，将 js 代码转换为 GraphQL 代码并使用，在 GraphQL 中，使用<code>$标识符</code>引用变量。</li><li><code>update()</code>：一个回调函数，当 GraphQL 请求有了返回值之后的下一步操作</li></ul><h1 id="请求发送时机"><a href="#请求发送时机" class="headerlink" title="请求发送时机"></a>请求发送时机</h1><p>前面说了只要向可接受<code>apollo</code>对象的地方传入它就可以完成 GraphQL 的查询与变更，所以我们讨论以下两种请求发送的时机。</p><h2 id="组件实例化时"><a href="#组件实例化时" class="headerlink" title="组件实例化时"></a>组件实例化时</h2><p>这个方案是将<code>apollo</code>对象传入组件中名为<code>apollo</code>的对象中，然后在组件实例化的过程中自动完成 GraphQL 请求，这种方案常用于 query，而且示例也是这样做的，其实你也可以进行 mutation，下面这个例子中有两个<code>apollo</code>对象：<code>books</code>和<code>delBooks</code>，分别进行了 query 和 mutation：</p><figure class="highlight javascript"><figcaption><span>template.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gql <span class="keyword">from</span> <span class="string">"graphql-tag"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            books: [],</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    apollo: &#123;</span><br><span class="line">        books: gql<span class="string">`</span></span><br><span class="line"><span class="string">            query &#123;</span></span><br><span class="line"><span class="string">                books &#123;</span></span><br><span class="line"><span class="string">                    title</span></span><br><span class="line"><span class="string">                    author</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        `</span>,</span><br><span class="line">        delBooks: &#123;</span><br><span class="line">            mutation: gql<span class="string">`</span></span><br><span class="line"><span class="string">                mutation &#123;</span></span><br><span class="line"><span class="string">                    id: 1</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            `</span>,</span><br><span class="line">            update(res) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(res);</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>apollo</code>对象中创建一个与<code>data</code>对象属性同名的属性，<code>apollo</code>会自动将获得的数据挂载到<code>data</code>对象。如上面这段代码<code>apollo</code>对象中的<code>books</code>属性，只需要在<code>data</code>中注册就能自动拿到请求的结果。</p><p><em>如果你的<code>apollo</code>对象中只有<code>query</code>或者只需要<code>mutation</code>，就可以像上面<code>books</code>对象中那样写，只需要将 gql 构造出的代码作为属性的值就行了。</em></p><p><em>TIPS：除了在 js 使用 gql 构造 GraphQL 查询代码，也可以将 GraphQL 查询代码写入<code>.gql</code>文件，在 js 中引用。</em></p><h2 id="手动发送请求"><a href="#手动发送请求" class="headerlink" title="手动发送请求"></a>手动发送请求</h2><p>你可以使用<code>this.$apollo.mutate()</code>方法来发送 GraphQL 请求，它不会自动调用，所以更加灵活，你可以将它放在方法甚至是生命周期中，完全由你控制，它接受 apollo 对象作为参数，使用起来大概是这样的：</p><figure class="highlight javascript"><figcaption><span>template.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gql <span class="keyword">from</span> <span class="string">"graphql-tag"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">        check() &#123;</span><br><span class="line">            <span class="keyword">this</span>.$apollo.mutate(&#123;</span><br><span class="line">                query: gql<span class="string">`</span></span><br><span class="line"><span class="string">                    query &#123;</span></span><br><span class="line"><span class="string">                        books &#123;</span></span><br><span class="line"><span class="string">                            title</span></span><br><span class="line"><span class="string">                        &#125;</span></span><br><span class="line"><span class="string">                    &#125;</span></span><br><span class="line"><span class="string">                `</span>,</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上就是我对 vue-apollo 的使用小结，使用和文档完全不同的思路完全是我的个人理解，如果有不同的见解希望大家留言评论。</p><article class="message message-immersive is-warning"><div class="message-body"><p>本文作者：KylinLee</p><p>本文链接：<a href="https://kylin.dev/2020/07/10/在Vue中使用GraphQL">https://kylin.dev/2020/07/10/在Vue中使用GraphQL</a></p><p>版权声明：本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p></div></article>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文帮助你在 Vue 中使用 GraphQL，也许你尝试使用过&lt;a href=&quot;https://github.com/axios/axios&quot;&gt;axios&lt;/a&gt;，不得不说 axios 并不适合用来发送 GraphQL API 请求，本文介绍一种更简单的方式并且带你上手。如果你对 GraphQL 后端感兴趣可以阅读我的上一篇文章《&lt;a href=&quot;/2020/07/07/Apollo-GraphQL%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E6%9C%8D%E5%8A%A1%E7%AB%AF/&quot; title=&quot;Apollo-GraphQL快速上手-服务端&quot;&gt;Apollo-GraphQL快速上手-服务端&lt;/a&gt;》。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Code" scheme="https://kylin.dev/categories/Code/"/>
    
      <category term="Frontend" scheme="https://kylin.dev/categories/Code/Frontend/"/>
    
    
      <category term="JavaScript" scheme="https://kylin.dev/tags/JavaScript/"/>
    
      <category term="GraphQL" scheme="https://kylin.dev/tags/GraphQL/"/>
    
  </entry>
  
  <entry>
    <title>Apollo-GraphQL快速上手-服务端</title>
    <link href="https://kylin.dev/2020/07/07/Apollo-GraphQL%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    <id>https://kylin.dev/2020/07/07/Apollo-GraphQL%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E6%9C%8D%E5%8A%A1%E7%AB%AF/</id>
    <published>2020-07-07T10:06:26.000Z</published>
    <updated>2020-07-13T06:00:16.790Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>上次课程设计做完之后就放松了一阵子，过了这么久才来更新博客其实内心是不好受的，感觉生活缺少了什么。GraphQL 出现了很多年，一直不温不火，想尝试 GraphQL 服务器开发的朋友们可以参考一下本文，你将理解到一种 GraphQL 服务器的通用逻辑。</p><div class="message message-immersive is-warning"><div class="message-body"><p>本文假设你对GraphQL有一定的了解。</p></div></div><a id="more"></a><p><a href="https://www.apollographql.com/docs/apollo-server/">Apollo Server</a> 是以 Node 为后端的 GraphQL 实现，我选择 Apollo 是因为它是一套完整的服务框架，它包括前端和后端，可拓展性强，并且 Node 也是后端开发最快的方式。</p><p>我不喜欢贴代码，我会从 0 开始搭建一个普通的 web 服务器，从创建一个 GraphQL 的 mock Server 来说明 Apollo Server 的运行逻辑，其实 GraphQL 服务器的运行逻辑也大致如此，最后接入数据库，更接近实战。</p><h1 id="基本服务器监听"><a href="#基本服务器监听" class="headerlink" title="基本服务器监听"></a>基本服务器监听</h1><p><em>本节为搭建基础服务器而不是 GraphQL 服务器，熟练的朋友可跳过。</em></p><p>Apollo Server 可作为一个独立的服务器，我们可以安装 Apollo 后直接启动服务器监听，但功能它的只限于对数据的增删改查，一个服务器可能还需要如下功能：</p><ul><li>模板渲染或 SSR</li><li>身份验证</li><li>文件上传</li><li>…</li></ul><p>为了便于拓展业务功能，我将 Apollo Server 作为 Node 服务器的中间件，你可以选择你喜欢的 Node 服务器框架，或者自己搭建 Node 服务器，我选择的是 <a href="https://www.koajs.com.cn/">Koa</a>，接下来开始搭建整体架构：</p><h2 id="安装-Koa-和-Apollo-Server"><a href="#安装-Koa-和-Apollo-Server" class="headerlink" title="安装 Koa 和 Apollo Server"></a>安装 Koa 和 Apollo Server</h2><figure class="highlight powershell"><figcaption><span>PowerShell</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i koa<span class="literal">-generator</span> <span class="literal">-g</span></span><br><span class="line">koa2 项目名</span><br></pre></td></tr></table></figure><p>生成的目录如下，长的很像 MVC 架构：<br><img src="https://i.loli.net/2020/07/07/6jbzi9kqFVEJWB3.png" alt="origin-dir.png"><br><code>app.js</code> 里引入了必备的库并初始化和定义路由，最终由 <code>bin/www</code> 引用并真正将他们使用起来。</p><p>接下来安装依赖，除了 koa-generator 生成的依赖，还需要安装<code>apollo-server-koa</code>和<code>graphql</code>，这样将 Apollo Server 作为中间件，如果你使用其他 Node 服务器，可以在<a href="https://www.apollographql.com/docs/apollo-server/integrations/middleware/">这里</a>找到适合的中间件。</p><h2 id="开发建议"><a href="#开发建议" class="headerlink" title="开发建议"></a>开发建议</h2><p>每次编辑代码之后查看更改必须要重新启动服务器，koa-generator 自动为我们安装<code>nodemon</code>，它能监听工作区的文件更改，进行热更新。这样的话，你需要将<code>bin/www</code>文件改为<code>bin/www.js</code>，因为<code>nodemon</code>不会监听没有后缀名文件的更改。</p><p>安装依赖后最后使用<code>npm run dev</code>就能启动服务器了，默认端口为 3000，你可以通过<code>localhost:3000</code>访问。</p><h1 id="简单的-GraphQL-服务"><a href="#简单的-GraphQL-服务" class="headerlink" title="简单的 GraphQL 服务"></a>简单的 GraphQL 服务</h1><p><strong>为了方便大家理解本节内容，写这篇博客的时候我也亲自做了一遍，你可以 clone<a href="https://github.com/KylinLee/koa-apollo-template/tree/mock">我的仓库</a>，切换到 mock 分支查看。</strong></p><figure class="highlight bash"><figcaption><span>GitBash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/KylinLee/koa-apollo-template.git</span><br><span class="line">git checkout mock</span><br></pre></td></tr></table></figure><p>Apollo GraphQL 由以下部分组成：</p><ul><li>Schema：图、结构</li><li>Data：数据源</li><li>Resolver：解析器</li></ul><p>为了便于理解，先模拟一个查询书籍相关信息的 GraphQL 服务器：</p><h2 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h2><p>Schema 相当于接口（指 API 接口），定义了客户端可以执行的操作类型，数据结构体，数据字段及类型。在 MVC 架构中，相当于模型，我的理解 Schema 是数据的入口和出口，一个请求传过来首先通过 Schema 校验，响应内容最终也会以 Schema 定义的格式返回，相当于一个模具，固定数据进出的格式。<br>所以新建一个<code>model/schema</code>目录，在目录中建立 Schema 并将其导出备用：</p><figure class="highlight javascript"><figcaption><span>model/schema/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; gql &#125; = <span class="built_in">require</span>(<span class="string">"apollo-server-koa"</span>);</span><br><span class="line"><span class="keyword">const</span> typeDefs = gql<span class="string">`</span></span><br><span class="line"><span class="string">    type Book &#123;</span></span><br><span class="line"><span class="string">        title: String</span></span><br><span class="line"><span class="string">        author: String</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    type Query &#123;</span></span><br><span class="line"><span class="string">        books: [Book]</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = typeDefs;</span><br></pre></td></tr></table></figure><p>GraphQL 中文文档中将类似于上面 <code>Book</code> 的结构叫做“<strong>类型</strong>”，但我认为对于编程人员将它们叫做“<strong>结构体</strong>”更容易理解。</p><h2 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h2><p>数据比较容易理解，客户端需要的内容，服务器可返回的内容就是数据。为了简化流程，便于理解，我们选择使用模拟数据，可以新建<code>data</code>目录，将模拟数据放在这里并导出备用：</p><figure class="highlight javascript"><figcaption><span>data/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> books = [</span><br><span class="line">    &#123;</span><br><span class="line">        title: <span class="string">"Harry Potter and the Chamber of Secrets"</span>,</span><br><span class="line">        author: <span class="string">"J.K. Rowling"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        title: <span class="string">"Jurassic Park"</span>,</span><br><span class="line">        author: <span class="string">"Michael Crichton"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="built_in">module</span>.exports = books;</span><br></pre></td></tr></table></figure><h2 id="Resolver"><a href="#Resolver" class="headerlink" title="Resolver"></a>Resolver</h2><p>解析器的作用是将 Schema 和 Data 联系在一起，即根据客户端传来的查询语句在一大堆 Data 里边找到指定的数据，如果说放在 MVC 里边，可以作为控制器，也可以作为模型，看个人如何理解，其实 MVC 没有很严格的界定，如果你的 Resolver 除了查询数据还具有其他复杂的功能，将其定义为控制器比较合适，如果你的 Resolver 专门用于数据的查询，将其作为模型看待。我将 Resolver 放在<code>model/resolver</code>目录下。</p><p>现在我们可以分析一下，查询<code>Books</code>，需要返回一个数组，数组的每一项需要符合<code>Book</code>的结构，即每一项需要包含<code>title</code>和<code>author</code>字段，巧的是我们模拟的数据<code>book</code>正好符合<code>Books</code>的结构。</p><p><strong>在开发中，这个分析很重要，请不要忽略！！！</strong></p><p>所以我们的 Resolver 这样写：</p><figure class="highlight javascript"><figcaption><span>model/resolver/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> books = <span class="built_in">require</span>(<span class="string">"../../data/index.js"</span>);</span><br><span class="line"><span class="keyword">const</span> resolvers = &#123;</span><br><span class="line">    Query: &#123;</span><br><span class="line">        books: <span class="function"><span class="params">()</span> =&gt;</span> books,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = resolvers;</span><br></pre></td></tr></table></figure><p>为 Schema 中对应的结构体编写同名的函数，并将这些函数作为<code>resolvers</code>对象的键和值，导出<code>resolvers</code>备用。</p><h3 id="Resolver-进阶"><a href="#Resolver-进阶" class="headerlink" title="Resolver 进阶"></a>Resolver 进阶</h3><p>其实你只编写了 Query 中 books 的解析器，books 是以 Book 为单元的数组，但我们并没有编写 Book 结构体的解析器，它还是返回了我们预期的结果。实际上 Apollo 并不是<code>data</code>是什么就返回什么，将<code>data</code>中的<code>author</code>改为<code>authors</code>，只会返回<code>title</code>字段内容。默认情况下，如果你没有编写某个结构体的解析器，Apollo 将会使用默认解析器，它会根据 books 的结果去验证里边的某一项是否符合 Book 解析器，最终返回符合 Book 的结果，起到了过滤的效果，了解默认解析器可以帮助你少编写代码。</p><h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><p>将三部分准备其了，接下来将这三部分接入服务器，供服务器调用，首先在<code>www.js</code>这个执行文件中引入这三部分，然后将他们作为选项传入 Apollo Server，最后将 Apollo Server 作为 Koa 中间件，<strong>关键代码</strong>如下：</p><figure class="highlight javascript"><figcaption><span>bin/www.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">"../app.js"</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; ApolloServer &#125; = <span class="built_in">require</span>(<span class="string">"apollo-server-koa"</span>);</span><br><span class="line"><span class="keyword">const</span> typeDefs = <span class="built_in">require</span>(<span class="string">"../model/schema/index.js"</span>);</span><br><span class="line"><span class="keyword">const</span> resolvers = <span class="built_in">require</span>(<span class="string">"../model/resolver/index.js"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造Apollo Server;</span></span><br><span class="line"><span class="keyword">const</span> server = <span class="keyword">new</span> ApolloServer(&#123;</span><br><span class="line">    typeDefs,</span><br><span class="line">    resolvers,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将server作为中间件</span></span><br><span class="line">server.applyMiddleware(&#123; app &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动监听，注意将原来的server改为app</span></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">    cosneole.log(<span class="string">"please open localhost:3000/graphql"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>打开<code>localhost:3000/graphql</code>，进行 GraphQL 查询，GraphQL 基础这里就不讲了，既然决定用 Apollo Server 相信大家都会，测试如下：<br><img src="https://i.loli.net/2020/07/09/TLayrYwQmhIBKp6.png" alt="test-graphql.png"></p><h1 id="使用-MySQL-作为数据源"><a href="#使用-MySQL-作为数据源" class="headerlink" title="使用 MySQL 作为数据源"></a>使用 MySQL 作为数据源</h1><p><strong>便于大家理解本节，你可以 clone<a href="https://github.com/KylinLee/koa-apollo-template/tree/mysql">我的仓库</a>，切换到 mysql 分支查看。</strong></p><figure class="highlight bash"><figcaption><span>GitBash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/KylinLee/koa-apollo-template.git</span><br><span class="line">git checkout mysql</span><br></pre></td></tr></table></figure><p>通过上面的讲解你已经理解 Apollo Server 的开发流程了吧，上面这个例子中使用的是模拟的数据，是固定不变的，接下来是重头戏——接入数据库。</p><p>我是用的是 MySQL，按照官方文档，可以使用的数据源有数据库和 RESTful API，支持 RESTful API 的原因是帮助使用 RESTful API 的服务迁移到 GraphQL，我使用关系型数据库 MySQL 作为数据源。</p><p>上面的例子中我们向 <code>ApolloServer</code> 构造函数传递了一个配置对象，这个配置对象包含了两个内容<code>typeDefs</code>和<code>resolvers</code>。其中数据源是在 resolver 中引入的，我们也可以将数据源传入 <code>ApolloServer</code> 构造函数，在 <code>ApolloServer</code> 实例化的时候就初始化连接数据库，我们使用 Apollo 社区维护的数据源工具<a href="https://github.com/cvburgess/SQLDataSource">datasource-sql</a>，它是基于<a href="http://knexjs.org/">knex</a>的，<code>knex</code>是一个查询构造器，通过<code>knex</code>我们可以用熟悉的 JavaScript 语法去执行 SQL 查询，<code>datasource-sql</code>的工作是将<code>knex</code>包装成<code>ApolloServer</code>构造函数可接受的对象，让我们先安装它：</p><figure class="highlight powershell"><figcaption><span>PowerShell</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i datasource<span class="literal">-sql</span> mysql -<span class="literal">-save</span></span><br></pre></td></tr></table></figure><p>然后我们需要做三部分的更改：</p><ol><li>配置数据库并实例化数据源工具</li><li>将数据源实例传入<code>ApolloServer</code></li><li>在 resolver 中使用数据源</li></ol><h2 id="配置数据库并实例化数据源工具"><a href="#配置数据库并实例化数据源工具" class="headerlink" title="配置数据库并实例化数据源工具"></a>配置数据库并实例化数据源工具</h2><p>首先配置数据库，在<code>data</code>文件夹创建<code>data/mysql.config.js</code>：</p><figure class="highlight javascript"><figcaption><span>mysql.config.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> knexConfig = &#123;</span><br><span class="line">    client: <span class="string">"mysql"</span>,</span><br><span class="line">    connection: &#123;</span><br><span class="line">        host: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">        port: <span class="number">3306</span>,</span><br><span class="line">        user: <span class="string">"root"</span>,</span><br><span class="line">        password: <span class="string">""</span>,</span><br><span class="line">        database: <span class="string">"Book"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后创建<code>data/methods.js</code>，这里边定义了数据库的操作方法供 resolver 调用，这些方法包含了你需要对数据库进行的所有操作，比如下面这段代码就是获取<code>books</code>表中的所有字段，相当于 SQL 语句:</p><figure class="highlight sql"><figcaption><span>SQL</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> books;</span><br></pre></td></tr></table></figure><p><strong>注意：使用 knex 查询器返回的是 Promise。</strong></p><figure class="highlight javascript"><figcaption><span>data/methods.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SQLDataSource &#125; = <span class="built_in">require</span>(<span class="string">"datasource-sql"</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FetchMethods</span> <span class="keyword">extends</span> <span class="title">SQLDataSource</span> </span>&#123;</span><br><span class="line">    getAllBooks() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.knex(<span class="string">"books"</span>)</span><br><span class="line">            .select(<span class="string">"*"</span>)</span><br><span class="line">            .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.table(res);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;)</span><br><span class="line">            .catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="number">0</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = FetchMethods;</span><br></pre></td></tr></table></figure><p>最终实例化数据库工具的逻辑是：将数据库配置对象传入包含数据库操作方法的类，如下：</p><figure class="highlight javascript"><figcaption><span>data/mysql.config.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyDatabase = <span class="built_in">require</span>(<span class="string">"./methods"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> knexConfig = &#123;</span><br><span class="line">    client: <span class="string">"mysql"</span>,</span><br><span class="line">    connection: &#123;</span><br><span class="line">        host: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">        port: <span class="number">3306</span>,</span><br><span class="line">        user: <span class="string">"root"</span>,</span><br><span class="line">        password: <span class="string">""</span>,</span><br><span class="line">        database: <span class="string">"Book"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db = <span class="keyword">new</span> MyDatabase(knexConfig);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = db;</span><br></pre></td></tr></table></figure><h2 id="将数据源实例传入ApolloServer"><a href="#将数据源实例传入ApolloServer" class="headerlink" title="将数据源实例传入ApolloServer"></a>将数据源实例传入<code>ApolloServer</code></h2><p>通过上面的实例化之后成为了<code>ApolloServer</code>构造函数可接受的数据源对象，对 ApolloServer 配置做如下更改：</p><figure class="highlight javascript"><figcaption><span>bin/www.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">"../app.js"</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; ApolloServer &#125; = <span class="built_in">require</span>(<span class="string">"apollo-server-koa"</span>);</span><br><span class="line"><span class="keyword">const</span> typeDefs = <span class="built_in">require</span>(<span class="string">"../model/schema/index.js"</span>);</span><br><span class="line"><span class="keyword">const</span> resolvers = <span class="built_in">require</span>(<span class="string">"../model/resolver/index.js"</span>);</span><br><span class="line"><span class="comment">// 引入数据源</span></span><br><span class="line"><span class="keyword">const</span> db = <span class="built_in">require</span>(<span class="string">"../data/mysql.config.js"</span>);</span><br><span class="line"><span class="comment">// 实例化 ApolloServer</span></span><br><span class="line"><span class="keyword">const</span> server = <span class="keyword">new</span> ApolloServer(&#123;</span><br><span class="line">    typeDefs,</span><br><span class="line">    resolvers,</span><br><span class="line">    dataSources: <span class="function"><span class="params">()</span> =&gt;</span> (&#123; db &#125;),</span><br><span class="line">    context: <span class="function">(<span class="params">app</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> method = app.ctx.method;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            method,</span><br><span class="line">            uid: <span class="string">"20202020"</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    tracing: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>关键代码是第 6 行和第 11 行。</p><h3 id="context-对象"><a href="#context-对象" class="headerlink" title="context 对象"></a>context 对象</h3><p>另外我往里边传了<code>context</code>对象，这是非必要的，有<code>context</code>对象之后我们可以在 resolver 中使用他们，如上面这段代码中返回了当前请求的方法和一个<code>uid</code>，我们在 resolver 里边就能使用这两个变量，具体怎么使用将在下一小节中阐述。<code>context</code>对象是很有用的，比如通过 JWT 验证请求者身份之后，可以将记录这个身份的信息传给 resolver，接着 resolver 将这个信息作为数据库查询参数。</p><h2 id="在-resolver-中使用数据源"><a href="#在-resolver-中使用数据源" class="headerlink" title="在 resolver 中使用数据源"></a>在 resolver 中使用数据源</h2><p>使用数据源就比较简单了，和我们之前写简单的 GraphQL 服务一样，在<code>model/resolver/index.js</code>中写 resolver 方法：</p><figure class="highlight javascript"><figcaption><span>model/resolver/index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolvers = &#123;</span><br><span class="line">    Query: &#123;</span><br><span class="line">        <span class="keyword">async</span> books(_source, _args, &#123; dataSources &#125;) &#123;</span><br><span class="line">            <span class="keyword">return</span> dataSources.db.getAllBooks();</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = resolvers;</span><br></pre></td></tr></table></figure><p>通过前面的一系列构造，我们之前编写的数据库操作方法可以通过<code>dataSources.db</code>来访问，你可以使用<code>await</code>，也可以不使用，因为 resolver 的返回值可以是 Promise 对象，这主要取决于你的数据库操作方法是如何写的。</p><p>我们注意到每一个结构的<code>resolver</code>还有几个参数，resolver 可以接收四个参数，最常用的就是上面这段代码中写到的前三个参数。</p><h3 id="第一个参数parent"><a href="#第一个参数parent" class="headerlink" title="第一个参数parent"></a>第一个参数<code>parent</code></h3><p>上面的代码中是<code>_source</code>，代表上一级解析器的返回值，因为 Schema 中定义的结构体是可以嵌套的，所以出现了多级选择器的概念，GraphQL 的解析顺序是从最外层解析的，返回最外层的解析结果之后才进行下一级解析，我们可以通过这个参数获取上一级的返回值然后将这个值作为下一级的参数。</p><h3 id="第二个参数args"><a href="#第二个参数args" class="headerlink" title="第二个参数args"></a>第二个参数<code>args</code></h3><p>上面的代码中是<code>_args</code>，顾名思义是参数的意思，指 GraphQL 查询中传递的参数如：</p><figure class="highlight plain"><figcaption><span>GraphQL</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">    book(id: 10)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设这是查询 id 为 10 的书籍信息，那么 resolver 中可以这样写：</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolvers = &#123;</span><br><span class="line">    Query: &#123;</span><br><span class="line">        <span class="keyword">async</span> books(_source, _args, &#123; dataSources &#125;) &#123;</span><br><span class="line">            <span class="keyword">return</span> dataSources.db.getAllBooks(_args.id);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = resolvers;</span><br></pre></td></tr></table></figure><p>然后在数据库操作方法的函数中接收这个参数。</p><h3 id="第三个参数context"><a href="#第三个参数context" class="headerlink" title="第三个参数context"></a>第三个参数<code>context</code></h3><p>第三个参数是上下文，由此可见，构造器其实是将我们的数据源<code>db</code>放在了上下文之中，<code>dataSources.db</code>则是我们的数据源，还记得之前传入<code>ApolloServer</code>的配置文件吗，我传入了一个 context 对象，ApolloServer 将它作为<code>db</code>对象的一个属性，这一点我不清楚为什么要这么设计，访问配置文件中传入的<code>context</code>对象通过如下方式获取：</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolvers = &#123;</span><br><span class="line">    Query: &#123;</span><br><span class="line">        <span class="keyword">async</span> books(_source, _args, &#123; dataSources &#125;) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(dataSourses.db.context.uid); <span class="comment">// 20202020</span></span><br><span class="line">            <span class="keyword">return</span> dataSources.db.getAllBooks();</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果你从头看完，至此相信你已经从零入门了，以上讲述的内容已经足够你开发一个功能完善的 GraphQL 服务器了，此外，不理解的话可以去 Apollo GraphQL 的<a href="https://www.apollographql.com/">官方网站</a>看看。</p><p><em>如果你不想重复的配置项目，可以从<a href="https://github.com/KylinLee/koa-apollo-template">我的仓库</a>拉取代码初始化项目。</em></p><article class="message message-immersive is-warning"><div class="message-body"><p>本文作者：KylinLee</p><p>本文链接：<a href="https://kylin.dev/2020/07/07/Apollo-GraphQL快速上手-服务端/">https://kylin.dev/https://kylin.dev/2020/07/07/Apollo-GraphQL快速上手-服务端</a></p><p>版权声明：本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p></div></article>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上次课程设计做完之后就放松了一阵子，过了这么久才来更新博客其实内心是不好受的，感觉生活缺少了什么。GraphQL 出现了很多年，一直不温不火，想尝试 GraphQL 服务器开发的朋友们可以参考一下本文，你将理解到一种 GraphQL 服务器的通用逻辑。&lt;/p&gt;
&lt;div class=&quot;message message-immersive is-warning&quot;&gt;
&lt;div class=&quot;message-body&quot;&gt;
&lt;p&gt;本文假设你对GraphQL有一定的了解。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
    
    </summary>
    
    
      <category term="Code" scheme="https://kylin.dev/categories/Code/"/>
    
      <category term="Backend" scheme="https://kylin.dev/categories/Code/Backend/"/>
    
    
      <category term="JavaScript" scheme="https://kylin.dev/tags/JavaScript/"/>
    
      <category term="GraphQL" scheme="https://kylin.dev/tags/GraphQL/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的协程</title>
    <link href="https://kylin.dev/2020/06/13/JavaScript%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B/"/>
    <id>https://kylin.dev/2020/06/13/JavaScript%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B/</id>
    <published>2020-06-13T15:24:56.000Z</published>
    <updated>2020-07-12T11:28:57.635Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本篇是《<a href="/2020/06/13/%E5%B0%9D%E8%AF%95%E7%94%A8%E9%80%9A%E4%BF%97%E7%9A%84%E6%96%B9%E5%BC%8F%E8%A7%A3%E9%87%8A%E5%8D%8F%E7%A8%8B/" title="尝试用通俗的方式解释协程">尝试用通俗的方式解释协程</a>》的续集，上一篇梳理了一遍协程的概念，现在我们用 JavaScript 为例更深入的了解协程。</p><a id="more"></a><h1 id="协程长啥样"><a href="#协程长啥样" class="headerlink" title="协程长啥样"></a>协程长啥样</h1><p>直接上代码看看 JavaScript 中协程是怎样的：</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">idMaker</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) <span class="keyword">yield</span> index++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> gen = idMaker(); <span class="comment">// "Generator &#123; &#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>没错，就是一个生成器，生成器本身是一个函数，也就是说在 JavaScript 中协程是由一个生成器函数实现的。</p><h1 id="协程如何切换"><a href="#协程如何切换" class="headerlink" title="协程如何切换"></a>协程如何切换</h1><p>协程本身是个函数，协程之间的切换本质是函数执行权的转移。</p><p>生成器函数的<code>yield</code>关键字有可以交出函数的执行权，挂起自身，然后 JavaScript 引擎，去执行这个函数后面的语句，在上面这个例子中，第 8 行调用<code>gen.next()</code>开始执行生成器函数的内容，第一次<code>while</code>循环里<code>yield</code>交出了执行权，JavaScript 引擎转而执行第 9 行，再次调用<code>gen.next()</code>，这时候 JavaScript 接着上次挂起的地方执行，不会重新执行<code>let index = 0</code>语句，然后执行函数内的语句，对于这个例子，使用<code>yield</code>和<code>next()</code>方法就能不断的交出和恢复函数的执行权，怎么样，是不是有点感觉了？站在一个线程的角度看，线程的切换就是这样不断让 CPU 暂停和继续对自己执行。</p><p>上面这个例子是把生成器函数的执行权交给普通函数（你也可以把非协程看做是一个协程整体），也可以在一个协程中调用另一个协程，实现协程之间的切换，比如这个例子：</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">anotherGenerator</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> i + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> i + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generator</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> i;</span><br><span class="line">    <span class="keyword">yield</span>* anotherGenerator(i); <span class="comment">// 移交执行权</span></span><br><span class="line">    <span class="keyword">yield</span> i + <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = generator(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 13</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>第 9 行使用<code>yield*</code>将执行权交给另一个生成器函数，接下来要等到这个生成器函数<code>anotherGenertor()</code>执行完毕执行权才会回到<code>generator</code>函数。这和普通函数表现一致，都是后进先出，如果感兴趣可以去看看 JavaScript 事件循环机制（Event Loop），本篇就不再多说了。</p><h1 id="协程如何实现异步"><a href="#协程如何实现异步" class="headerlink" title="协程如何实现异步"></a>协程如何实现异步</h1><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>搞清楚什么是同步，什么是异步，问题才能很好的讨论下去。先说同步：</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">res = <span class="function"><span class="keyword">function</span> <span class="title">fetchFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 请求资源</span></span><br><span class="line">    <span class="comment">// res = ....</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br></pre></td></tr></table></figure><p>计算机按照程序顺序执行代码，比如这几行代码一定第三行先给<code>res</code>赋值，然后才是打印<code>res</code>，而非同步（即异步）可以先执行后面的<code>console.log(res)</code>，然后再给<code>res</code>赋值。</p><p>为什么需要这么做呢，当一个请求需要耗费大量的时间，程序执行一直停留在这一行，就会引发阻塞，最容易受影响的是<code>eventListener</code>，事件监听没了，在请求数据的时候点击事件都是无效的。</p><p>所以实现异步的关键就是把会阻塞线程函数的执行权交出去，让这个函数等待恢复执行，等待的时间内请求（或者其他异步任务）也该执行完了，这时候再来继续执行这个函数。通过前面对协程的运行方式的讲解我们很容易就能想到用协程来解决这个问题，利用<code>yield</code>挂起这个阻塞线程函数，然后继续执行后面的语句，等这个函数不再阻塞了，再回到这个函数继续执行。那么问题来了，应该什么时候继续执行这个挂起的函数呢？你可能想到大概估计一下阻塞时间，设定时间再回来执行，这个方案。。。有点牵强。</p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>这时候 Promise 就派上用场了，Promise 本质是一个状态机，用于表示一个异步操作的最终完成 (或失败), 及其结果值。它有三个状态：</p><ul><li>pending: 初始状态，既不是成功，也不是失败状态。</li><li>fulfilled: 意味着操作成功完成。</li><li>rejected: 意味着操作失败。</li></ul><p>最终 Promise 会有两种状态，一种成功，一种失败，当 pending 变化的时候，Promise 对象会根据最终的状态调用不同的处理函数。</p><p>根据 Promise 的特点，他是一个状态机，在<code>yield</code>之后可以用 Promise 来表示异步任务是否执行完毕（是否是 pending 状态），并且还能够自动判别异步任务成功与否（fulfilled 还是 rejected）并执行处理函数。如此看来用协程+Promise 可以完美实现异步。</p><p>好的，让我们来根据上面的理论实现一下吧：</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟阻塞事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveAfter2Seconds</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(val);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现生成器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">coroutineFunc</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> resolveAfter2Seconds(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> doIt = coroutineFunc(<span class="string">"OK"</span>);</span><br><span class="line"><span class="keyword">let</span> value = doIt.next().value;</span><br><span class="line"><span class="comment">// value是Promise对象</span></span><br><span class="line">value.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 模拟后面被阻塞的语句</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的输出顺序是 0=&gt;1=&gt;2=&gt;…=&gt;9，两秒之后输出’OK’，从输出顺序来看我们已经实现了异步。其执行过程和之前说的一样，挂起会阻塞运行的函数，继续执行后面的语句，等待 Promise 改变状态并自动执行处理函数。</p><h2 id="使用-Generator、Promise-组合和直接使用-Promise-的区别"><a href="#使用-Generator、Promise-组合和直接使用-Promise-的区别" class="headerlink" title="使用 Generator、Promise 组合和直接使用 Promise 的区别"></a>使用 Generator、Promise 组合和直接使用 Promise 的区别</h2><p>实际上下面这段代码运行顺序的结果和上面一模一样：</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveAfter2Seconds</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(val);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resolveAfter2Seconds(<span class="string">"OK"</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>为什么要使用上面那种复杂的写法呢？为了简化问题，便于理解，我已经简化了代码，在前一个例子中，生成器函数内，11 行以后完全可以写更多的代码，这些代码一定是在异步获取到数据之后才执行的。如果直接使用 Promise 需要把这些代码放在 then 代码块里边才能保证在异步获取到值之后执行，那么当有多个异步事件的时候问题就来了——可怕的嵌套！</p><h1 id="Async、Await"><a href="#Async、Await" class="headerlink" title="Async、Await"></a>Async、Await</h1><p>ECMAscript2017 中提供了更高级的协程控制语法，其被看做是对 Generator 和 Promise 组合的封装，使异步函数看起来更像同步函数，减轻开发者的痛苦。上面的例子改写：</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveAfter2Seconds</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(x);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="keyword">await</span> resolveAfter2Seconds(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(x); <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 Async、Await 实现了 Generator 的自动迭代，不需要手动使用<code>next()</code>方法来继续执行。正因为 Async、Await 是对 Generator 和 Promise 组合的封装，所以 Async 和 Await 基本上就只能用来实现异步和并发了，而不具有协程的其他作用。</p><article class="message message-immersive is-warning"><div class="message-body"><p>本文作者：KylinLee</p><p>本文链接：<a href="https://kylin.dev/2020/06/13/JavaScript中的协程">https://kylin.dev/2020/06/13/JavaScript中的协程</a></p><p>版权声明：本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p></div></article>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇是《&lt;a href=&quot;/2020/06/13/%E5%B0%9D%E8%AF%95%E7%94%A8%E9%80%9A%E4%BF%97%E7%9A%84%E6%96%B9%E5%BC%8F%E8%A7%A3%E9%87%8A%E5%8D%8F%E7%A8%8B/&quot; title=&quot;尝试用通俗的方式解释协程&quot;&gt;尝试用通俗的方式解释协程&lt;/a&gt;》的续集，上一篇梳理了一遍协程的概念，现在我们用 JavaScript 为例更深入的了解协程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Code" scheme="https://kylin.dev/categories/Code/"/>
    
      <category term="Frontend" scheme="https://kylin.dev/categories/Code/Frontend/"/>
    
    
      <category term="JavaScript" scheme="https://kylin.dev/tags/JavaScript/"/>
    
  </entry>
  
</feed>
